





Groupe de travail du réseau R. Fielding
Demande de commentaires : 2616 UC Irvine
Obsolète : 2068 J. Gettys
Catégorie : Suivi des normes Compaq/W3C
J. Mogul
Compaq
H. Fristyk
W3C/MIT
L. Masinter
Photocopier
P. Leach
Microsoft
T. Berners-Lee
W3C/MIT
juin 1999


Protocole de transfert hypertexte -- HTTP/1.1

Statut de ce mémo

Ce document spécifie un protocole de normalisation Internet pour le
communauté Internet, et demande des discussions et des suggestions pour
améliorations. Veuillez vous référer à l'édition actuelle du "Internet
Normes de protocole officielles" (STD 1) pour l'État de normalisation
et le statut de ce protocole. La diffusion de ce mémo est illimitée.

Copyright

Copyright (C) L'Internet Society (1999). Tous droits réservés.

Abstrait

Le protocole HTTP (Hypertext Transfer Protocol) est un protocole au niveau de l'application.
protocole pour les informations distribuées, collaboratives et hypermédia
systèmes. Il s'agit d'un protocole générique, sans état, qui peut être utilisé pour
de nombreuses tâches au-delà de son utilisation pour l'hypertexte, telles que les serveurs de noms et
systèmes de gestion d'objets distribués, grâce à l'extension de ses
méthodes de requête, codes d’erreur et en-têtes [47]. Une fonctionnalité de HTTP est
le typage et la négociation de la représentation des données, permettant aux systèmes
à construire indépendamment des données transférées.

HTTP a été utilisé par les informations mondiales du World-Wide Web
initiative depuis 1990. Cette spécification définit le protocole
appelé "HTTP/1.1", et est une mise à jour de la RFC 2068 [33].






Fielding et coll. Piste des normes [Page 1]
 
RFC 2616 HTTP/1.1 juin 1999


Table des matières

1. Introduction ................................................ ...7
1.1 But................................................ ......7
1.2 Exigences ............................................................ .8
1.3 Terminologie ............................................................ ..8
1.4 Fonctionnement global ............................................12
2 Conventions de notation et grammaire générique ..................14
2.1 BNF augmenté ....................................................... 14
2.2 Règles de base ....................................................... ..15
3 Paramètres du protocole .......................................17
3.1 Version HTTP ............................................................ .17
3.2 Identificateurs de ressources uniformes ................................18
3.2.1 Syntaxe générale ..................................................19
3.2.2 URL http .................................................. ....19
3.2.3 Comparaison des URI ..............................................20
3.3 Formats date/heure ..............................................20
3.3.1 Date complète .................................................. ...20
3.3.2 Delta secondes ..................................................21
3.4 Jeux de caractères ..............................................21
3.4.1 Jeu de caractères manquant .......................................22
3.5 Codages de contenu ..................................................23
3.6 Codages de transfert ..................................................24
3.6.1 Codage de transfert fragmenté ................................25
3.7 Types de médias .................................................. ..26
3.7.1 Canonicalisation et paramètres de texte par défaut ................27
3.7.2 Types en plusieurs parties ..................................27
3.8 Jetons de produit ..................................................28
3.9 Valeurs de qualité ..................................................29
3.10 Balises de langue .................................................. 29
3.11 Balises d'entité .................................................. ..30
3.12 Unités de portée .................................................. ..30
4 Messages HTTP ............................................................ ...31
4.1 Types de messages .................................................. 31
4.2 En-têtes de message ............................................31
4.3 Corps du message .............................................. .32
4.4 Longueur du message ............................................33
4.5 Champs d'en-tête généraux .......................................34
5 Demande ............................................................ .......35
5.1 Ligne de demande .................................................. ..35
5.1.1 Méthode .............................................................. .....36
5.1.2 URI de requête .................................................. ..36
5.2 La ressource identifiée par une requête ......................38
5.3 Champs d'en-tête de demande ..................................38
6 Réponse ............................................................ ......39
6.1 Ligne d'état .............................................. ...39
6.1.1 Code d'état et phrase de raison ............................39
6.2 Champs d'en-tête de réponse ................................41



Fielding et coll. Piste des normes [Page 2]
 
RFC 2616 HTTP/1.1 juin 1999


7 Entité ............................................................ ........42
7.1 Champs d'en-tête d'entité ......................................42
7.2 Corps de l'entité .................................................. ..43
7.2.1 Type ...................................................... .......43
7.2.2 Longueur de l'entité ............................................43
8 Connexions ............................................................ ...44
8.1 Connexions persistantes .......................................44
8.1.1 Objet .............................................................. ....44
8.1.2 Fonctionnement global ............................................45
8.1.3 Serveurs proxy .......................................46
8.1.4 Considérations pratiques ................................46
8.2 Exigences de transmission des messages ..................47
8.2.1 Connexions persistantes et contrôle de flux ................47
8.2.2 Surveillance des connexions pour les messages d'état d'erreur .........48
8.2.3 Utilisation du statut 100 (Continuer) ......................48
8.2.4 Comportement du client si le serveur ferme prématurément la connexion ..50
9 Définitions des méthodes ............................................51
9.1 Méthodes sûres et idempotentes ............................51
9.1.1 Méthodes sûres .................................................. 51
9.1.2 Méthodes idempotentes .......................................51
9.2 OPTIONS ............................................................ .....52
9.3 OBTENIR .............................................. .........53
9.4 TÊTE ............................................... ........54
9.5 PUBLICATION .............................................. ........54
9.6 METTRE ...................................................... .........55
9.7 SUPPRIMER .................................................. ......56
9.8 TRAÇAGE .............................................. .......56
9.9 CONNEXION .................................................. .....57
10 Définitions des codes d'état ..................................57
10.1 Informations 1xx ..................................................57
10.1.1 100 Suite .............................................. 58
10.1.2 101 Protocoles de commutation .................................58
10.2 2xx réussi ..................................................58
10.2.1 200 OK .................................................. ......58
10.2.2 201 Créé .................................................. .59
10.2.3 202 Accepté .................................................. 59
10.2.4 203 Informations ne faisant pas autorité .......................59
10.2.5 204 Aucun contenu ..............................................60
10.2.6 205 Réinitialiser le contenu ......................................60
10.2.7 206 Contenu partiel ......................................60
10.3 Redirection 3xx .......................................................61
10.3.1 300 choix multiples ............................................61
10.3.2 301 Déplacé de façon permanente ................................62
10.3.3 302 Trouvé .................................................. ...62
10.3.4 303 Voir Autres .................................................. 63
10.3.5 304 Non modifié ......................................................63
10.3.6 305 Utiliser un proxy ............................................ 64
10.3.7 306 (Inutilisé) .............................................. ..64



Fielding et coll. Piste des normes [Page 3]
 
RFC 2616 HTTP/1.1 juin 1999


10.3.8 307 Redirection temporaire ......................................65
10.4 Erreur client 4xx ..................................................65
10.4.1 400 Requêtes incorrectes ............................65
10.4.2 401 Non autorisé ............................................66
10.4.3 402 Paiement requis ............................................66
10.4.4 403 Interdit ......................................................66
10.4.5 404 introuvable ..........................................66
10.4.6 Méthode 405 non autorisée .......................................66
10.4.7 406 Non acceptable ......................................................67
10.4.8 407 Authentification proxy requise .......................67
10.4.9 Expiration du délai de demande 408 .......................67
10.4.10 409 Conflit ......................................................67
10.4.11 410 Disparu .............................................. ...68
10.4.12 411 Longueur requise ............................................68
10.4.13 412 Échec de la condition préalable ..........................68
10.4.14 413 Entité de requête trop grande ..........................69
10.4.15 414 URI de requête trop long ..........................69
10.4.16 415 Type de support non pris en charge ..........................69
10.4.17 416 Plage demandée non satisfaisable ...............69
10.4.18 417 Échec de l'attente ...............................70
10.5 Erreur de serveur 5xx ............................................70
10.5.1 500 Erreur de serveur interne ..........................70
10.5.2 501 Non mis en œuvre ......................................70
10.5.3 502 Passerelle défectueuse ..................................70
10.5.4 Service 503 indisponible .................................70
10.5.5 Délai d'expiration de la passerelle 504 ............................71
10.5.6 Version HTTP 505 non prise en charge ..........................71
11 Authentification d'accès ............................................71
12 Négociation de contenu .......................................71
12.1 Négociation pilotée par le serveur ..........................72
12.2 Négociation pilotée par l'agent ............................73
12.3 Négociation transparente .......................................74
13 Mise en cache en HTTP .................................................. 74
13.1.1 Exactitude du cache ..................................................75
13.1.2 Avertissements .................................................. ...76
13.1.3 Mécanismes de contrôle du cache ............................77
13.1.4 Avertissements explicites de l'agent utilisateur ..........................78
13.1.5 Exceptions aux règles et avertissements .......................78
13.1.6 Comportement contrôlé par le client ..........................79
13.2 Modèle d'expiration ..................................................79
13.2.1 Expiration spécifiée par le serveur ..........................79
13.2.2 Expiration heuristique .......................................80
13.2.3 Calculs de l'âge ............................................80
13.2.4 Calculs d'expiration ...............................................83
13.2.5 Lever l'ambiguïté des valeurs d'expiration ..........................84
13.2.6 Lever l'ambiguïté des réponses multiples ........................84
13.3 Modèle de validation ..................................................85
13.3.1 Dates de dernière modification ......................................86



Fielding et coll. Piste des normes [Page 4]
 
RFC 2616 HTTP/1.1 juin 1999


13.3.2 Validateurs de cache de balises d'entité ..........................86
13.3.3 Validateurs faibles et forts ............................86
13.3.4 Règles pour savoir quand utiliser les balises d'entité et les dates de dernière modification.89
13.3.5 Conditions non validantes ..............................90
13.4 Mise en cache des réponses .......................................91
13.5 Construire des réponses à partir des caches ..........................92
13.5.1 En-têtes de bout en bout et saut par saut ............92
13.5.2 En-têtes non modifiables ......................................92
13.5.3 Combinaison d'en-têtes ......................................94
13.5.4 Combinaison de plages d'octets ............................95
13.6 Mise en cache des réponses négociées ..........................95
13.7 Caches partagés et non partagés ............................96
13.8 Erreurs ou comportement du cache de réponses incomplètes ................97
13.9 Effets secondaires de GET et HEAD ............................97
13.10 Invalidation après mises à jour ou suppressions ..............97
13.11 Écriture obligatoire ............................................98
13.12 Remplacement du cache ................................................99
13.13 Listes d'historique ..................................................99
14 Définitions des champs d'en-tête ................................100
14.1 Accepter ............................................................ .....100
14.2 Accepter le jeu de caractères ..................................102
14.3 Accepter l'encodage .......................................102
14.4 Accepter la langue ..................................................104
14.5 Plages d'acceptation .................................................. 105
14.6 Âge ............................................................ ........106
14.7 Autoriser ............................................... ......106
14.8 Autorisation ..................................................107
14.9 Contrôle du cache .................................................. 108
14.9.1 Qu'est-ce qui peut être mis en cache ............................109
14.9.2 Ce qui peut être stocké dans les caches ......................110
14.9.3 Modifications du mécanisme d'expiration de base .........111
14.9.4 Contrôles de revalidation et de rechargement du cache ..............113
14.9.5 Directive de non-transformation ................................115
14.9.6 Extensions de contrôle du cache ................................116
14.10 Connexion ..................................................117
14.11 Codage du contenu ............................................118
14.12 Contenu-Langage ..........................................118
14.13 Longueur du contenu ..................................................119
14.14 Emplacement du contenu ............................................120
14.15 Contenu-MD5 .................................................. 121
14.16 Plage de contenu ..................................................122
14.17 Type de contenu ..................................................124
14.18Date ............................................................ .....124
14.18.1 Fonctionnement du serveur Origin sans horloge .......125
14.19 Etag.................................................. .....126
14.20 Attendez-vous ............................................ ...126
14.21 Expire .................................................. ..127
14.22 De .............................................................. .....128



Fielding et coll. Piste des normes [Page 5]
 
RFC 2616 HTTP/1.1 juin 1999


14.23 Hôte .............................................. .....128
14.24 Si-correspondance .............................................. ...129
14.25 Si-Modifié-Depuis ......................................130
14.26 Si aucune correspondance ..................................................... 132
14.27 Plage If .................................................. ...133
14.28 Si-non modifié-depuis ......................................134
14.29 Dernière modification ..................................................134
14h30 Localisation .............................................. .135
14.31 Avances maximales ..................................................136
14.32 Pragma .................................................. ...136
14.33 Authentification par proxy ................................137
14.34 Autorisation par procuration ......................................137
14.35 Portée .............................................. ....138
14.35.1 Plages d'octets ..........................................138
14.35.2 Requêtes de récupération de plage ..............................139
14.36 Référent ....................................................... ..140
14.37 Réessayer après .................................................. 141
14.38 Serveur .............................................. ...141
14.39 TE .................................................. .......142
14.40 Remorque .............................................. ..143
14.41 Transfert-Encodage..................................................143
14.42 Mise à niveau .............................................. ..144
14.43 Agent utilisateur .................................................. .145
14.44 Varier .................................................. .....145
14h45 Par .............................................. ......146
14.46 Avertissement .............................................. ..148
14.47 WWW-Authentifier ..................................................150
15 Considérations relatives à la sécurité ................................150
15.1 Informations personnelles............................................151
15.1.1 Abus des informations du journal du serveur ............................ 151
15.1.2 Transfert d'informations sensibles .......................151
15.1.3 Codage des informations sensibles dans les URI ...............152
15.1.4 Problèmes de confidentialité liés à l'acceptation des en-têtes .......152
15.2 Attaques basées sur les noms de fichiers et de chemins d'accès .......153
15.3 Usurpation DNS .................................................. 154
15.4 En-têtes d'emplacement et usurpation d'identité ..............................154
15.5 Problèmes de disposition du contenu ................................154
15.6 Identifiants d'authentification et clients inactifs ..............155
15.7 Proxy et mise en cache ................................................155
15.7.1 Attaques par déni de service sur les proxys.................156
16 Remerciements ..................................................156
17 Références ............................................................ ..158
18 Adresses des auteurs .......................................162
19 Annexes ............................................................ ..164
19.1 Type de média Internet message/http et application/http ......164
19.2 Type de média Internet multipart/byteranges .................165
19.3 Applications tolérantes ......................................166
19.4 Différences entre les entités HTTP et les entités RFC 2045 .......167



Fielding et coll. Piste des normes [Page 6]
 
RFC 2616 HTTP/1.1 juin 1999


19.4.1 Version MIME .................................................. 167
19.4.2 Conversion en forme canonique ............................167
19.4.3 Conversion des formats de date ..............................168
19.4.4 Introduction du codage de contenu ........................168
19.4.5 Aucun encodage de transfert de contenu ..............................168
19.4.6 Introduction du codage par transfert ..................169
19.4.7 Limitations de MHTML et de longueur de ligne .................169
19.5 Fonctionnalités supplémentaires ..................................169
19.5.1 Disposition du contenu ..................................170
19.6 Compatibilité avec les versions précédentes ..................170
19.6.1 Modifications par rapport à HTTP/1.0 ..............................171
19.6.2 Compatibilité avec les connexions persistantes HTTP/1.0 ......172
19.6.3 Modifications par rapport à la RFC 2068 ..............................172
20 Index ............................................................ .......175
21 Déclaration complète de droits d'auteur ................................176

1. Introduction

1.1 But

Le protocole HTTP (Hypertext Transfer Protocol) est un protocole au niveau de l'application.
protocole pour les informations distribuées, collaboratives et hypermédia
systèmes. HTTP a été utilisé par le Web mondial
initiative d'information depuis 1990. La première version de HTTP,
appelé HTTP/0.9, était un protocole simple pour le transfert de données brutes
sur Internet. HTTP/1.0, tel que défini par RFC 1945 [6], amélioré
le protocole en permettant aux messages d'être au format de type MIME
messages, contenant des métainformations sur les données transférées et
modificateurs sur la sémantique requête/réponse. Cependant, HTTP/1.0 ne
ne prend pas suffisamment en compte les effets de la hiérarchie
proxys, mise en cache, besoin de connexions persistantes ou virtuelles
hôtes. En outre, la prolifération de mesures incomplètement mises en œuvre
applications se faisant appeler "HTTP/1.0" a nécessité un
changement de version du protocole afin que deux applications communicantes
pour déterminer les véritables capacités de chacun.

Cette spécification définit le protocole appelé « HTTP/1.1 ».
Ce protocole inclut des exigences plus strictes que HTTP/1.0 dans
afin d’assurer une mise en œuvre fiable de ses fonctionnalités.

Les systèmes d’information pratiques nécessitent plus de fonctionnalités que de simples
récupération, y compris la recherche, la mise à jour frontale et l'annotation. HTTP
permet un ensemble ouvert de méthodes et d'en-têtes qui indiquent le
but d’une demande [47]. Il s'appuie sur la discipline de référence
fourni par l'Uniform Resource Identifier (URI) [3], en tant qu'emplacement
(URL) [4] ou nom (URN) [20], pour indiquer la ressource à laquelle un





Fielding et coll. Piste des normes [Page 7]
 
RFC 2616 HTTP/1.1 juin 1999


méthode doit être appliquée. Les messages sont transmis dans un format similaire à
celui utilisé par la messagerie Internet [9] tel que défini par le MultiPurpose
Extensions de messagerie Internet (MIME) [7].

HTTP est également utilisé comme protocole générique pour la communication entre
agents utilisateurs et proxys/passerelles vers d'autres systèmes Internet, y compris
ceux supportés par le SMTP [16], NNTP [13], FTP [18], Gopher [2],
et les protocoles WAIS [10]. De cette manière, HTTP permet l'hypermédia de base
accès aux ressources disponibles à partir de diverses applications.

1.2 Exigences

Les mots clés « DOIT », « NE DOIT PAS », « OBLIGATOIRE », « DEVRA », « NE DOIT PAS »,
« DEVRAIT », « NE DEVRAIT PAS », « RECOMMANDÉ », « PEUT » et « OPTIONNEL » dans ce
document doivent être interprétés comme décrit dans la RFC 2119 [34].

Une implémentation n'est pas conforme si elle ne satisfait pas à un ou plusieurs
des exigences de niveau DOIT ou REQUIS pour les protocoles qu'il
met en oeuvre. Une mise en œuvre qui satisfait à tous les DOIT ou REQUIS
le niveau et toutes les exigences de niveau DEVRAIT pour ses protocoles sont dits
être « conforme sans condition » ; celui qui satisfait à tous les MUST
exigences de niveau mais pas toutes les exigences de niveau DEVRAIT pour son
les protocoles sont dits « conformes sous condition ».

1.3 Terminologie

Cette spécification utilise un certain nombre de termes pour désigner les rôles
joué par les participants et les objets de la communication HTTP.

connexion
Un circuit virtuel de couche transport établi entre deux programmes
à des fins de communication.

message
L'unité de base de la communication HTTP, composée d'un
séquence d'octets correspondant à la syntaxe définie à la section 4 et
transmis via la connexion.

demande
Un message de requête HTTP, tel que défini à la section 5.

réponse
Un message de réponse HTTP, tel que défini à la section 6.








Fielding et coll. Piste des normes [Page 8]
 
RFC 2616 HTTP/1.1 juin 1999


Ressource
Un objet ou un service de données réseau pouvant être identifié par un URI,
tel que défini à la section 3.2. Les ressources peuvent être disponibles dans plusieurs
représentations (par exemple plusieurs langues, formats de données, taille et
résolutions) ou varient d’autres manières.

entité
Les informations transférées en tant que charge utile d'une demande ou
réponse. Une entité est constituée de métainformations sous la forme de
champs d'en-tête d'entité et contenu sous la forme d'un corps d'entité, comme
décrit à la section 7.

représentation
Une entité incluse dans une réponse soumise au contenu
négociation, comme décrit à la section 12. Il peut exister plusieurs
représentations associées à un état de réponse particulier.

négociation de contenu
Le mécanisme de sélection de la représentation appropriée lorsque
traiter une demande, comme décrit à l’article 12. Le
la représentation des entités dans toute réponse peut être négociée
(y compris les réponses aux erreurs).

une variante
Une ressource peut avoir une ou plusieurs représentations.
qui lui est associé à un instant donné. Chacun de ces
représentations est appelée une « variante ». Utilisation du terme « variante »
n'implique pas nécessairement que la ressource est soumise à un contenu
négociation.

client
Un programme qui établit des connexions dans le but d'envoyer
demandes.

agent utilisateur
Le client qui initie une demande. Ce sont souvent des navigateurs,
éditeurs, araignées (robots de navigation sur le Web) ou autres outils d'utilisateur final.

serveur
Un programme d'application qui accepte les connexions afin de
demandes de service en renvoyant des réponses. Tout programme donné peut
être capable d'être à la fois client et serveur ; notre utilisation de ceux-ci
Les termes font uniquement référence au rôle joué par le programme pour un
connexion particulière, plutôt qu'aux capacités du programme
en général. De même, n'importe quel serveur peut faire office de serveur d'origine,
proxy, passerelle ou tunnel, comportement de commutation en fonction de la nature
de chaque demande.




Fielding et coll. Piste des normes [Page 9]
 
RFC 2616 HTTP/1.1 juin 1999


serveur d'origine
Le serveur sur lequel une ressource donnée réside ou doit être créée.

Procuration
Un programme intermédiaire qui agit à la fois comme serveur et client
dans le but de faire des demandes pour le compte d’autres clients.
Les demandes sont traitées en interne ou par transmission, avec
traduction possible, vers d'autres serveurs. Un proxy DOIT implémenter
les exigences client et serveur de cette spécification. UN
"proxy transparent" est un proxy qui ne modifie pas la requête ou
réponse au-delà de ce qui est requis pour l'authentification du proxy et
identification. Un « proxy non transparent » est un proxy qui modifie
la demande ou la réponse afin de fournir un service supplémentaire à
l'agent utilisateur, tel que les services d'annotation de groupe, le type de média
transformation, réduction de protocole ou filtrage d’anonymat. Sauf
où un comportement transparent ou non transparent est explicitement
indiqué, les exigences du proxy HTTP s'appliquent aux deux types de
procurations.

passerelle
Un serveur qui sert d'intermédiaire pour un autre serveur.
Contrairement à un proxy, une passerelle reçoit les requêtes comme si elle était le
serveur d'origine pour la ressource demandée ; le client demandeur
il se peut qu'il ne sache pas qu'il communique avec une passerelle.

tunnel
Un programme intermédiaire qui fait office de relais aveugle entre
deux connexions. Une fois actif, un tunnel n'est pas considéré comme une fête
à la communication HTTP, bien que le tunnel ait pu être
initiée par une requête HTTP. Le tunnel cesse d'exister lorsque les deux
les extrémités des connexions relayées sont fermées.

cache
Le magasin local de messages de réponse d'un programme et le sous-système
qui contrôle le stockage, la récupération et la suppression des messages. UN
le cache stocke les réponses pouvant être mises en cache afin de réduire la réponse
consommation de temps et de bande passante réseau sur le futur, équivalent
demandes. Tout client ou serveur peut inclure un cache, bien qu'un cache
ne peut pas être utilisé par un serveur faisant office de tunnel.

pouvant être mis en cache
Une réponse peut être mise en cache si un cache est autorisé à stocker une copie de
le message de réponse à utiliser pour répondre aux demandes ultérieures. Le
les règles permettant de déterminer la possibilité de mise en cache des réponses HTTP sont
défini à la section 13. Même si une ressource peut être mise en cache, il peut y avoir
il y aura des contraintes supplémentaires quant à savoir si un cache peut utiliser le contenu mis en cache
copie pour une demande particulière.




Fielding et coll. Piste des normes [Page 10]
 
RFC 2616 HTTP/1.1 juin 1999


de première main
Une réponse est directe si elle vient directement et sans
retard inutile de la part du serveur d'origine, peut-être via un ou plusieurs
procurations. Une réponse est également directe si sa validité vient d'être confirmée.
été vérifié directement auprès du serveur d'origine.

délai d'expiration explicite
L'heure à laquelle le serveur d'origine prévoit qu'une entité doit
ne seront plus renvoyés par un cache sans autre validation.

délai d'expiration heuristique
Un délai d'expiration attribué par un cache en l'absence d'expiration explicite
le temps est disponible.

âge
L'âge d'une réponse est le temps écoulé depuis son envoi, ou
validé avec succès avec le serveur d'origine.

fraîcheur à vie
Le délai entre la génération d'une réponse et son
date d'expiration.

frais
Une réponse est fraîche si son âge n'a pas encore dépassé sa fraîcheur
durée de vie.

vicié
Une réponse est périmée si son âge a dépassé sa durée de vie de fraîcheur.

sémantiquement transparent
Un cache se comporte de manière « sémantiquement transparente », avec
par rapport à une réponse particulière, lorsque son utilisation n’affecte ni le
client demandeur ni le serveur d'origine, sauf pour améliorer
performance. Lorsqu'un cache est sémantiquement transparent, le client
reçoit exactement la même réponse (sauf pour les en-têtes saut par saut)
qu'il aurait reçu si sa demande avait été traitée directement
par le serveur d'origine.

validateur
Un élément de protocole (par exemple, une balise d'entité ou une heure de dernière modification)
qui est utilisé pour savoir si une entrée de cache est un équivalent
copie d'une entité.

amont Aval
L'amont et l'aval décrivent le flux d'un message : tous
les messages circulent de l’amont vers l’aval.





Fielding et coll. Piste des normes [Page 11]
 
RFC 2616 HTTP/1.1 juin 1999


entrant et sortant
Entrant et sortant font référence aux chemins de demande et de réponse pour
messages : "entrant" signifie "voyager vers le serveur d'origine",
et « sortant » signifie « voyager vers l'agent utilisateur »

1.4 Fonctionnement global

Le protocole HTTP est un protocole de requête/réponse. Un client envoie un
requête au serveur sous la forme d'une méthode de requête, d'un URI et
version du protocole, suivi d'un message de type MIME contenant la requête
modificateurs, informations sur le client et contenu du corps possible sur une
connexion avec un serveur. Le serveur répond avec une ligne d'état,
incluant la version du protocole du message et un code de réussite ou d'erreur,
suivi d'un message de type MIME contenant des informations sur le serveur, l'entité
les métainformations et le contenu éventuel du corps de l'entité. La relation
entre HTTP et MIME est décrit en annexe 19.4.

La plupart des communications HTTP sont initiées par un agent utilisateur et consistent en
une requête à appliquer à une ressource sur un serveur d'origine. Dans le
cas le plus simple, cela peut être réalisé via une seule connexion (v)
entre l'agent utilisateur (UA) et le serveur d'origine (O).

chaîne de requête --------------->
UA -------------------v------------------- O
<----------------------- chaîne de réponse

Une situation plus compliquée se produit lorsqu'un ou plusieurs intermédiaires
sont présents dans la chaîne requête/réponse. Il y a trois choses communes
formes d’intermédiaire : proxy, passerelle et tunnel. Un mandataire est un
transitaire, recevant les demandes d'URI sous sa forme absolue,
réécriture de tout ou partie du message, et transmission du message reformaté
requête vers le serveur identifié par l’URI. Une passerelle est un
agent récepteur, agissant comme une couche au-dessus de certains autres serveurs et, si
nécessaire, traduisant les requêtes vers le serveur sous-jacent
protocole. Un tunnel fait office de point relais entre deux connexions
sans changer les messages ; les tunnels sont utilisés lorsque le
la communication doit passer par un intermédiaire (comme un
pare-feu) même lorsque l'intermédiaire ne peut pas comprendre le contenu
des messages.

chaîne de requêtes -------------------------------------->
UA -----v----- A -----v----- B -----v----- C -----v----- O
-------------------------------------- chaîne de réponse

La figure ci-dessus montre trois intermédiaires (A, B et C) entre le
agent utilisateur et serveur d'origine. Un message de demande ou de réponse qui
parcours, toute la chaîne passera par quatre connexions distinctes.
Cette distinction est importante car certaines options de communication HTTP



Fielding et coll. Piste des normes [Page 12]
 
RFC 2616 HTTP/1.1 juin 1999


ne peut s'appliquer qu'à la connexion avec le réseau non-tunnel le plus proche
voisin, uniquement aux extrémités de la chaîne ou à toutes les connexions
le long de la chaîne. Bien que le diagramme soit linéaire, chaque participant peut
être engagé dans des communications multiples et simultanées. Par exemple, B
peut recevoir des demandes de nombreux clients autres que A, et/ou
transférer les requêtes vers des serveurs autres que C, en même temps qu'il
gère la demande de A.

Toute partie à la communication qui n'agit pas comme tunnel peut
utiliser un cache interne pour gérer les demandes. L'effet d'un cache
est que la chaîne requête/réponse est raccourcie si l'un des
les participants tout au long de la chaîne ont une réponse en cache applicable à cela
demande. Ce qui suit illustre la chaîne résultante si B a un
copie en cache d'une réponse antérieure de O (via C) pour une requête qui
n'a pas été mis en cache par UA ou A.

chaîne de requête ---------->
UA -----v----- A -----v----- B - - - - - - C - - - - - - O
<--------- chaîne de réponse

Toutes les réponses ne peuvent pas être utilement mises en cache et certaines requêtes peuvent
contiennent des modificateurs qui imposent des exigences particulières sur le comportement du cache.
Les exigences HTTP pour le comportement du cache et les réponses pouvant être mises en cache sont
défini à l’article 13.

En fait, il existe une grande variété d'architectures et de configurations
de caches et de proxys actuellement expérimentés ou déployés
à travers le World Wide Web. Ces systèmes comprennent des hiérarchies nationales
de caches proxy pour économiser la bande passante transocéanique, des systèmes qui
entrées de cache de diffusion ou de multidiffusion, organisations qui distribuent
des sous-ensembles de données mises en cache via un CD-ROM, etc. Les systèmes HTTP sont utilisés
dans les intranets d'entreprise via des liens à large bande passante et pour un accès via
PDA avec liaisons radio basse consommation et connectivité intermittente. Le
l'objectif de HTTP/1.1 est de prendre en charge la grande diversité de configurations
déjà déployé tout en introduisant des constructions de protocole qui répondent aux
besoins de ceux qui créent des applications Web qui nécessitent un niveau élevé
fiabilité et, à défaut, des indications au moins fiables de
échec.

La communication HTTP s'effectue généralement via des connexions TCP/IP. Le
le port par défaut est TCP 80 [19], mais d'autres ports peuvent être utilisés. Cela fait
n'empêche pas HTTP d'être implémenté par-dessus tout autre protocole
sur Internet ou sur d'autres réseaux. HTTP suppose seulement un
transport; tout protocole offrant de telles garanties peut être utilisé ;
le mappage des structures de requête et de réponse HTTP/1.1 sur le
les unités de données de transport du protocole en question sont hors du champ d'application
de cette spécification.




Fielding et coll. Piste des normes [Page 13]
 
RFC 2616 HTTP/1.1 juin 1999


Dans HTTP/1.0, la plupart des implémentations utilisaient une nouvelle connexion pour chaque
échange demande/réponse. En HTTP/1.1, une connexion peut être utilisée pour
un ou plusieurs échanges requête/réponse, bien que les connexions puissent être
fermé pour diverses raisons (voir section 8.1).

2 Conventions de notation et grammaire générique

2.1 BNF augmenté

Tous les mécanismes spécifiés dans ce document sont décrits dans
à la fois de la prose et une forme Backus-Naur augmentée (BNF) similaire à celle
utilisé par la RFC 822 [9]. Les responsables de la mise en œuvre devront se familiariser avec
notation afin de comprendre cette spécification. Le BNF augmenté
comprend les constructions suivantes :

nom = définition
Le nom d'une règle est simplement le nom lui-même (sans aucun
entourant "<" et ">") et est séparé de sa définition par le
caractère égal "=". L'espace blanc n'a de sens que dans la mesure où
l'indentation des lignes de continuation est utilisée pour indiquer une règle
définition qui s’étend sur plus d’une ligne. Certaines règles de base sont
en majuscules, comme SP, LWS, HT, CRLF, DIGIT, ALPHA, etc. Angle
les parenthèses sont utilisées dans les définitions chaque fois que leur présence
faciliter le discernement de l’utilisation des noms de règles.

"littéral"
Les guillemets entourent le texte littéral. Sauf indication contraire,
le texte n'est pas sensible à la casse.

règle1 | règle2
Les éléments séparés par une barre ("|") sont des alternatives, par exemple "oui |
non" acceptera oui ou non.

(règle1 règle2)
Les éléments entre parenthèses sont traités comme un seul élément.
Ainsi, "(elem (foo | bar) elem)" autorise les séquences de jetons "elem
foo elem" et "elem bar elem".

*règle
Le caractère "*" précédant un élément indique une répétition. Le
la forme complète est "<n>*<m>élément" indiquant au moins <n> et au plus
<m> occurrences de l'élément. Les valeurs par défaut sont 0 et l'infini donc
que "*(element)" autorise n'importe quel nombre, y compris zéro ; "1*élément"
en nécessite au moins un ; et "1*2element" en autorise un ou deux.

[règle]
Les crochets entourent les éléments facultatifs ; "[foo bar]" est
équivalent à "*1(foo bar)".



Fielding et coll. Piste des normes [Page 14]
 
RFC 2616 HTTP/1.1 juin 1999


Règle N
Répétition spécifique : "<n>(élément)" équivaut à
"<n>*<n>(élément)" ; c'est-à-dire exactement <n> occurrences de (élément).
Ainsi 2DIGIT est un nombre à 2 chiffres et 3ALPHA est une chaîne de trois
caractères alphabétiques.

#règle
Une construction "#" est définie, similaire à "*", pour définir des listes de
éléments. La forme complète est "<n>#<m>element" indiquant au moins
<n> et au plus <m> éléments, chacun séparé par une ou plusieurs virgules
(",") et espace blanc linéaire OPTIONNEL (LWS). Cela rend l'habituel
forme de listes très simple ; une règle telle que
( *Élément LWS *( *LWS "," *Élément LWS ))
peut être montré comme
1#élément
Partout où cette construction est utilisée, les éléments nuls sont autorisés, mais ne le faites pas.
ne contribuent pas au décompte des éléments présents. C'est,
"(élément), , (élément) " est autorisé, mais ne compte que pour deux
éléments. Par conséquent, lorsqu'au moins un élément est requis, à
au moins un élément non nul DOIT être présent. Les valeurs par défaut sont 0
et l'infini pour que "#element" autorise n'importe quel nombre, y compris zéro ;
"1#element" en nécessite au moins un ; et "1#2element" permet un ou
deux.

; commentaire
Un point-virgule, placé à une certaine distance à droite du texte de la règle,
commence un commentaire qui continue jusqu'à la fin de la ligne. C'est un
moyen simple d'inclure des notes utiles en parallèle avec le
Caractéristiques.

implicite *LWS
La grammaire décrite par cette spécification est basée sur les mots. Sauf
là où indiqué autrement, un espace blanc linéaire (LWS) peut être inclus
entre deux mots adjacents (jeton ou chaîne entre guillemets), et
entre les mots adjacents et les séparateurs, sans changer le
interprétation d'un champ. Au moins un délimiteur (LWS et/ou

séparateurs) DOIT exister entre deux jetons (pour la définition
de "jeton" ci-dessous), car ils seraient autrement interprétés comme un
jeton unique.

2.2 Règles de base

Les règles suivantes sont utilisées tout au long de cette spécification pour
décrire les constructions d'analyse de base. Le jeu de caractères codés US-ASCII
est défini par ANSI X3.4-1986 [21].





Fielding et coll. Piste des normes [Page 15]
 
RFC 2616 HTTP/1.1 juin 1999


OCTET = <n'importe quelle séquence de données de 8 bits>
CHAR = <n'importe quel caractère US-ASCII (octets 0 à 127)>
UPALPHA = <n'importe quelle lettre majuscule US-ASCII "A".."Z">
LOALPHA = <n'importe quelle lettre minuscule US-ASCII "a".."z">
ALPHA = UPALPHA | LOALPHA
DIGIT = <n'importe quel chiffre US-ASCII "0".."9">
CTL = <n'importe quel caractère de contrôle US-ASCII
(octets 0 à 31) et DEL (127)>
CR = <US-ASCII CR, retour chariot (13)>
LF = <US-ASCII LF, saut de ligne (10)>
SP = <US-ASCII SP, espace (32)>
HT = <US-ASCII HT, onglet horizontal (9)>
<"> = <Guillemets doubles US-ASCII (34)>

HTTP/1.1 définit la séquence CR LF comme marqueur de fin de ligne pour tous
éléments de protocole à l'exception du corps d'entité (voir l'annexe 19.3 pour
applications tolérantes). Le marqueur de fin de ligne au sein d'une entité-corps
est défini par son type de média associé, comme décrit à la section 3.7.

CRLF = CRLF

Les valeurs des champs d'en-tête HTTP/1.1 peuvent être repliées sur plusieurs lignes si le
la ligne de continuation commence par un espace ou une tabulation horizontale. Tout linéaire
l'espace blanc, y compris le pliage, a la même sémantique que SP. UN
le destinataire PEUT remplacer tout espace blanc linéaire par un seul SP avant
interpréter la valeur du champ ou transmettre le message en aval.

LWS = [CRLF] 1*( SP | HT )

La règle TEXTE n'est utilisée que pour le contenu et les valeurs des champs descriptifs.
qui ne sont pas destinés à être interprétés par l’analyseur de messages. Mots
de *TEXTE PEUT contenir des caractères provenant de jeux de caractères autres que ISO-
8859-1 [22] uniquement lorsqu'il est codé selon les règles de la RFC 2047
[14].

TEXT = <n'importe quel OCTET sauf les CTL,
mais incluant LWS>

Un CRLF est autorisé dans la définition de TEXT uniquement dans le cadre d'un en-tête.
suite du champ. Il est prévu que le LWS pliable soit
remplacé par un seul SP avant l’interprétation de la valeur TEXT.

Les caractères numériques hexadécimaux sont utilisés dans plusieurs éléments du protocole.

HEX = "A" | "B" | "C" | "D" | "E" | "F"
| "un" | "b" | "c" | "d" | "e" | "f" | CHIFFRE





Fielding et coll. Piste des normes [Page 16]
 
RFC 2616 HTTP/1.1 juin 1999


De nombreuses valeurs de champ d'en-tête HTTP/1.1 sont constituées de mots séparés par LWS
ou des caractères spéciaux. Ces caractères spéciaux DOIVENT être entre guillemets
chaîne à utiliser dans une valeur de paramètre (telle que définie dans la section
3.6).

token = 1*<n'importe quel CHAR sauf CTL ou séparateurs>
séparateurs = "(" | ")" | "<" | ">" | "@"
| "," | ";" | ":" | "\" | <">
| "/" | "[" | "]" | "?" | "="
| "{" | "}" | PS | HT

Des commentaires peuvent être inclus dans certains champs d'en-tête HTTP en les entourant
le texte du commentaire entre parenthèses. Les commentaires ne sont autorisés que dans
champs contenant « commentaire » dans le cadre de la définition de leur valeur de champ.
Dans tous les autres champs, les parenthèses sont considérées comme faisant partie du champ
valeur.

comment = "(" *( ctext | paire-citée | commentaire ) ")"
ctext = <tout TEXTE excluant "(" et ")">

Une chaîne de texte est analysée comme un seul mot si elle est citée à l'aide de
guillemets doubles.

chaîne-quoted = ( <"> *(qdtext | paire-quoted ) <"> )
qdtext = <n'importe quel TEXTE sauf <">>

Le caractère barre oblique inverse ("\") PEUT être utilisé comme un seul caractère
mécanisme de citation uniquement dans les constructions de chaînes entre guillemets et de commentaires.

paire-citée = "\" CHAR

3 paramètres de protocole

3.1 Version HTTP

HTTP utilise un schéma de numérotation "<major>.<minor>" pour indiquer les versions
du protocole. La politique de gestion des versions du protocole est destinée à permettre
l'expéditeur d'indiquer le format d'un message et sa capacité de
comprendre davantage la communication HTTP, plutôt que les fonctionnalités
obtenu via cette communication. Aucune modification n'est apportée à la version
numéro pour l'ajout de composants de message qui n'affectent pas
comportement de communication ou qui ne font qu'ajouter aux valeurs des champs extensibles.
Le numéro <mineur> est incrémenté lorsque les modifications apportées au
le protocole ajoute des fonctionnalités qui ne modifient pas l'analyse générale des messages
algorithme, mais qui peut ajouter à la sémantique du message et impliquer
capacités supplémentaires de l'expéditeur. Le numéro <majeur> est
incrémenté lorsque le format d'un message au sein du protocole est
modifié. Voir la RFC 2145 [36] pour une explication plus complète.



Fielding et coll. Piste des normes [Page 17]
 
RFC 2616 HTTP/1.1 juin 1999


La version d'un message HTTP est indiquée par un champ HTTP-Version
dans la première ligne du message.

Version HTTP = "HTTP" "/" 1*DIGIT "." 1 * CHIFFRE

Notez que les nombres majeurs et mineurs DOIVENT être traités séparément.
des nombres entiers et que chacun PEUT être incrémenté au-dessus d’un seul chiffre.
Ainsi, HTTP/2.4 est une version inférieure à HTTP/2.13, qui à son tour est
inférieur à HTTP/12.3. Les zéros non significatifs DOIVENT être ignorés par les destinataires et
NE DOIT PAS être envoyé.

Une application qui envoie une demande ou un message de réponse qui inclut
La version HTTP de « HTTP/1.1 » DOIT être au moins conforme sous certaines conditions
avec cette spécification. Les candidatures au moins conditionnelles
conforme à cette spécification DEVRAIT utiliser une version HTTP de
"HTTP/1.1" dans leurs messages, et DOIT le faire pour tout message qui est
non compatible avec HTTP/1.0. Pour plus de détails sur le moment d'envoyer
valeurs spécifiques de la version HTTP, voir RFC 2145 [36].

La version HTTP d'une application est la version HTTP la plus élevée pour
auquel la demande est conforme au moins sous certaines conditions.

Les applications proxy et passerelle doivent être prudentes lors du transfert
messages dans des versions de protocole différentes de celle de l'application.
Puisque la version du protocole indique la capacité du protocole du
expéditeur, un proxy/passerelle NE DOIT PAS envoyer de message avec une version
indicateur qui est supérieur à sa version réelle. Si un
demande de version est reçue, le proxy/passerelle DOIT soit rétrograder
la version de la requête, ou répondre avec une erreur, ou passer au tunnel
comportement.

En raison de problèmes d'interopérabilité découverts avec les proxys HTTP/1.0
depuis la publication de la RFC 2068[33], les proxys de mise en cache DOIVENT, les passerelles
PEUT, et les tunnels NE DOIVENT PAS mettre à niveau la requête vers la version la plus élevée
ils supportent. La réponse du proxy/passerelle à cette demande DOIT être en
la même version majeure que la demande.

Remarque : La conversion entre les versions de HTTP peut impliquer des modifications
de champs d'en-tête obligatoires ou interdits par les versions concernées.

3.2 Identificateurs de ressources uniformes

Les URI sont connus sous de nombreux noms : adresses WWW, document universel
Identifiants, Identifiants de ressources universels [3], et enfin les
combinaison de localisateurs de ressources uniformes (URL) [4] et de noms (URN)
[20]. En ce qui concerne HTTP, les Uniform Resource Identifiers sont
des chaînes simplement formatées qui identifient - via le nom, l'emplacement ou tout autre
autre caractéristique : une ressource.



Fielding et coll. Piste des normes [Page 18]
 
RFC 2616 HTTP/1.1 juin 1999


3.2.1 Syntaxe générale

Les URI en HTTP peuvent être représentés sous forme absolue ou relative à certains
URI de base connue [11], en fonction du contexte de leur utilisation. Les deux
les formes se différencient par le fait que les URI absolus commencent toujours par
avec un nom de schéma suivi de deux points. Pour des informations définitives sur
Syntaxe et sémantique de l'URL, voir « Uniform Resource Identifiers (URI) :
Syntaxe et sémantique génériques", RFC 2396 [42] (qui remplace les RFC
1738 [4] et RFC 1808 [11]). Cette spécification adopte le
définitions de "URI-référence", "absoluteURI", "relativeURI", "port",
"host", "abs_path", "rel_path" et "authority" à partir de cela
spécification.

Le protocole HTTP n'impose aucune limite a priori à la longueur des
un URI. Les serveurs DOIVENT être capables de gérer l'URI de toute ressource qu'ils
servir, et DEVRAIT être capable de gérer les URI de longueur illimitée s'ils
fournir des formulaires basés sur GET qui pourraient générer de tels URI. Un serveur
DEVRAIT renvoyer le statut 414 (Request-URI Too Long) si un URI est plus long
que le serveur ne peut gérer (voir section 10.4.15).

Remarque : les serveurs doivent faire preuve de prudence en fonction de la longueur des URI.
au-dessus de 255 octets, car certains clients ou proxy plus anciens
les implémentations peuvent ne pas prendre correctement en charge ces longueurs.

3.2.2 URL http

Le schéma "http" est utilisé pour localiser les ressources réseau via le protocole HTTP
protocole. Cette section définit la syntaxe spécifique au schéma et
sémantique des URL http.

http_URL = "http:" "//" hôte [ ":" port ] [ chemin_abs [ "?" requête ]]

Si le port est vide ou n'est pas indiqué, le port 80 est supposé. La sémantique
sont que la ressource identifiée se trouve au niveau du serveur en écoute
pour les connexions TCP sur ce port de cet hôte, et le Request-URI
car la ressource est abs_path (section 5.1.2). L'utilisation des adresses IP
dans les URL DEVRAIT être évité autant que possible (voir RFC 1900 [24]). Si
le abs_path n'est pas présent dans l'URL, il DOIT être donné sous la forme "/" lorsque
utilisé comme Request-URI pour une ressource (section 5.1.2). Si un mandataire
reçoit un nom d'hôte qui n'est pas un nom de domaine pleinement qualifié, il
PEUT ajouter son domaine au nom d'hôte qu'il a reçu. Si un mandataire reçoit
un nom de domaine pleinement qualifié, le proxy NE DOIT PAS changer d'hôte
nom.








Fielding et coll. Piste des normes [Page 19]
 
RFC 2616 HTTP/1.1 juin 1999


3.2.3 Comparaison des URI

Lors de la comparaison de deux URI pour décider s'ils correspondent ou non, un client
DEVRAIT utiliser une comparaison octet par octet sensible à la casse de l'ensemble
URI, avec ces exceptions :

- Un port vide ou non renseigné équivaut à celui par défaut
port pour cette référence URI ;

- Les comparaisons de noms d'hôtes DOIVENT être insensibles à la casse ;

- Les comparaisons de noms de schéma DOIVENT être insensibles à la casse ;

- Un abs_path vide équivaut à un abs_path de "/".

Caractères autres que ceux des jeux "réservés" et "non sécurisés" (voir
RFC 2396 [42]) sont équivalents à leur codage ""%" HEX HEX".

Par exemple, les trois URI suivants sont équivalents :

http://abc.com:80/~smith/home.html
http://ABC.com/%7Esmith/home.html
http://ABC.com:/%7esmith/home.html

3.3 Formats date/heure

3.3.1 Date complète

Les applications HTTP ont historiquement autorisé trois formats différents
pour la représentation des horodatages :

Dimanche 6 novembre 1994 08:49:37 GMT ; RFC 822, mise à jour par RFC 1123
Dimanche 6 novembre 1994 à 08:49:37 GMT ; RFC 850, obsolète par RFC 1036
Dim 6 novembre 08:49:37 1994 ; Format asctime() d'ANSI C

Le premier format est préféré comme norme Internet et représente
un sous-ensemble de longueur fixe de celui défini par la RFC 1123 [8] (une mise à jour de
RFC822 [9]). Le deuxième format est d'usage courant, mais il est basé sur le
format de date obsolète RFC 850 [12] et il lui manque une année à quatre chiffres.
Les clients et serveurs HTTP/1.1 qui analysent la valeur de date DOIVENT accepter
les trois formats (pour la compatibilité avec HTTP/1.0), bien qu'ils DOIVENT
générer uniquement le format RFC 1123 pour représenter les valeurs de date HTTP
dans les champs d'en-tête. Voir la section 19.3 pour plus d'informations.

Remarque : Les destinataires des valeurs de date sont encouragés à faire preuve de robustesse dans
accepter les valeurs de date qui peuvent avoir été envoyées par un protocole non HTTP
applications, comme c'est parfois le cas lors de la récupération ou de la publication
messages via proxys/passerelles vers SMTP ou NNTP.



Fielding et coll. Piste des normes [Page 20]
 
RFC 2616 HTTP/1.1 juin 1999


Tous les horodatages HTTP DOIVENT être représentés en heure moyenne de Greenwich
(GMT), sans exception. Pour les besoins de HTTP, GMT est exactement
égal à UTC (Temps Universel Coordonné). Ceci est indiqué dans le
deux premiers formats par l'inclusion de "GMT" comme code à trois lettres
abréviation de fuseau horaire, et DOIT être supposé lors de la lecture du
format asctime. La date HTTP est sensible à la casse et NE DOIT PAS inclure
LWS supplémentaires au-delà de ceux spécifiquement inclus en tant que SP dans le
grammaire.

Date HTTP = date-rfc1123 | date rfc850 | asctime-date
rfc1123-date = jour semaine "," SP date1 SP heure SP "GMT"
rfc850-date = jour de la semaine "," SP date2 Heure SP SP "GMT"
asctime-date = jour semaine SP date3 SP heure SP 4DIGIT
date1 = 2 CHIFFRES SP mois SP 4 CHIFFRES
; jour mois année (par exemple, 02 juin 1982)
date2 = 2CHIFFRES "-" mois "-" 2CHIFFRES
; jour-mois-année (par exemple, 02-juin-82)
date3 = mois SP ( 2DIGIT | ( SP 1DIGIT ))
; jour du mois (par exemple, 2 juin)
heure = 2 CHIFFRES ":" 2 CHIFFRES ":" 2 CHIFFRES
; 00:00:00 - 23:59:59
jour de la semaine = "Lun" | "Mardi" | "Épouser"
| "Jeudi" | "Vendredi" | "Samedi" | "Soleil"
jour de la semaine = "Lundi" | "Mardi" | "Mercredi"
| "Jeudi" | "Vendredi" | "Samedi" | "Dimanche"
mois = "janvier" | "Février" | "Mars" | "Avr"
| "Mai" | "Juin" | "Juillet" | "Août"
| "Septembre" | "Octobre" | "novembre" | "Déc"

Remarque : les exigences HTTP pour le format d'horodatage s'appliquent uniquement
à leur utilisation dans le flux protocolaire. Les clients et les serveurs sont
pas tenu d'utiliser ces formats pour la présentation de l'utilisateur, demande
journalisation, etc.

3.3.2 Delta secondes

Certains champs d'en-tête HTTP permettent de spécifier une valeur temporelle comme
nombre entier de secondes, représenté en décimal, après l'heure
que le message a été reçu.

delta-secondes = 1*CHIFFRE

3.4 Jeux de caractères

HTTP utilise la même définition du terme « jeu de caractères » que celui
décrit pour MIME :





Fielding et coll. Voie des normes [Page 21]
 
RFC 2616 HTTP/1.1 juin 1999


Le terme « jeu de caractères » est utilisé dans ce document pour désigner un
méthode utilisée avec une ou plusieurs tables pour convertir une séquence d'octets
en une séquence de caractères. Notez que la conversion inconditionnelle dans
l'autre sens n'est pas obligatoire, dans la mesure où tous les caractères ne peuvent pas
être disponible dans un jeu de caractères donné et un jeu de caractères peut fournir
plus d'une séquence d'octets pour représenter un caractère particulier.
Cette définition vise à autoriser différents types de caractères
encodage, depuis de simples mappages de table unique tels que US-ASCII jusqu'à
méthodes de changement de table complexes telles que celles qui utilisent les normes ISO-2022
techniques. Cependant, la définition associée à un caractère MIME
le nom de l'ensemble DOIT spécifier entièrement le mappage à effectuer à partir des octets
aux personnages. En particulier, utilisation d'informations de profilage externes
il n’est pas permis de déterminer la cartographie exacte.

Remarque : Cette utilisation du terme « jeu de caractères » est plus couramment utilisée
appelé « encodage de caractères ». Cependant, puisque HTTP et
MIME partage le même registre, il est important que la terminologie
également être partagé.

Les jeux de caractères HTTP sont identifiés par des jetons insensibles à la casse. Le
l'ensemble complet de jetons est défini par le registre des jeux de caractères IANA
[19].

jeu de caractères = jeton

Bien que HTTP permette d'utiliser un jeton arbitraire comme jeu de caractères
valeur, tout jeton qui a une valeur prédéfinie au sein de l'IANA
Le registre des jeux de caractères [19] DOIT représenter le jeu de caractères défini
par ce registre. Les applications DEVRAIENT limiter leur utilisation du caractère
ensembles à ceux définis par le registre IANA.

Les développeurs doivent être conscients des exigences en matière de jeux de caractères de l'IETF [38]
[41].

3.4.1 Jeu de caractères manquant

Certains logiciels HTTP/1.0 ont interprété un en-tête Content-Type sans
paramètre charset pour signifier à tort « le destinataire doit deviner ».
Les expéditeurs souhaitant vaincre ce comportement PEUVENT inclure un jeu de caractères
paramètre même lorsque le jeu de caractères est ISO-8859-1 et DEVRAIT le faire lorsque
on sait que cela ne confondra pas le destinataire.

Malheureusement, certains anciens clients HTTP/1.0 ne géraient pas correctement
un paramètre charset explicite. Les destinataires HTTP/1.1 DOIVENT respecter les
étiquette de jeu de caractères fournie par l'expéditeur ; et les agents utilisateurs qui ont
une disposition pour "deviner" un jeu de caractères DOIT utiliser le jeu de caractères du





Fielding et coll. Piste des normes [Page 22]
 
RFC 2616 HTTP/1.1 juin 1999


champ de type de contenu s'ils prennent en charge ce jeu de caractères, plutôt que le
préférence du destinataire, lors de l'affichage initial d'un document. Voir
paragraphe 3.7.1.

3.5 Codages de contenu

Les valeurs de codage de contenu indiquent une transformation de codage qui a
été ou peut être appliqué à une entité. Les codages de contenu sont principalement
utilisé pour permettre à un document d'être compressé ou autrement utilement
transformé sans perdre l’identité de son type de média sous-jacent
et sans perte d'informations. Fréquemment, l'entité est stockée dans
forme codée, transmise directement et décodée uniquement par le destinataire.

codage de contenu = jeton

Toutes les valeurs de codage de contenu ne sont pas sensibles à la casse. Utilisations HTTP/1.1
valeurs de codage de contenu dans Accept-Encoding (section 14.3) et
Champs d’en-tête Content-Encoding (section 14.11). Même si la valeur
décrit le codage du contenu, ce qui est plus important est qu'il
indique quel mécanisme de décodage sera nécessaire pour supprimer le
codage.

L'IANA (Internet Assigned Numbers Authority) agit comme un registre pour
jetons de valeur de codage de contenu. Initialement, le registre contient le
jetons suivants :

gzip Un format d'encodage produit par le programme de compression de fichiers
"gzip" (GNU zip) comme décrit dans la RFC 1952 [25]. Ce format est un
Codage Lempel-Ziv (LZ77) avec un CRC 32 bits.

compresse
Le format d'encodage produit par la compression de fichiers UNIX commune
programme "compresser". Ce format est un Lempel-Ziv-Welch adaptatif
codage (LZW).

Utilisation de noms de programmes pour l'identification des formats d'encodage
n’est pas souhaitable et est déconseillé pour les futurs encodages. Leur
l'utilisation ici est représentative de la pratique historique, pas bonne
conception. Pour la compatibilité avec les implémentations précédentes de HTTP,
les applications DEVRAIENT considérer "x-gzip" et "x-compress" comme étant
équivalent à "gzip" et "compress" respectivement.

dégonfler
Le format "zlib" défini dans la RFC 1950 [31] en combinaison avec
le mécanisme de compression "dégonfler" décrit dans la RFC 1951 [29].






Fielding et coll. Piste des normes [Page 23]
 
RFC 2616 HTTP/1.1 juin 1999


identité
Le codage (identité) par défaut ; l'utilisation d'aucune transformation
quoi que ce soit. Ce codage de contenu est utilisé uniquement dans le
En-tête d'encodage et NE DEVRAIT PAS être utilisé dans le Content-Encoding
entête.

De nouveaux jetons de valeur de codage de contenu DEVRAIENT être enregistrés ; autoriser
interopérabilité entre clients et serveurs, spécifications du
les algorithmes de codage de contenu nécessaires pour implémenter une nouvelle valeur DEVRAIENT être
accessible au public et adéquat pour une mise en œuvre indépendante, et
se conformer à l’objectif de codage de contenu défini dans cette section.

3.6 Codages de transfert

Les valeurs de codage de transfert sont utilisées pour indiquer un codage
transformation qui a été, peut être ou doit être appliquée à un
entité-organisme afin d'assurer un « transport sûr » à travers le réseau.
Ceci diffère d'un codage de contenu dans la mesure où le codage de transfert est un
propriété du message, pas de l’entité d’origine.

transfert-codage = "morceaux" | transfert-extension
transfert-extension = jeton *( paramètre ";" )

Les paramètres se présentent sous la forme de paires attribut/valeur.

paramètre = attribut "=" valeur
attribut = jeton
valeur = jeton | chaîne entre guillemets

Toutes les valeurs de codage de transfert ne sont pas sensibles à la casse. Utilisations HTTP/1.1
valeurs de codage de transfert dans le champ d'en-tête TE (section 14.39) et dans
le champ d’en-tête Transfer-Encoding (section 14.41).

Chaque fois qu'un codage de transfert est appliqué à un corps de message, l'ensemble des
les codages de transfert DOIVENT inclure "chunked", sauf si le message est
terminé en fermant la connexion. Lorsque le transfert "en morceaux"-
codage est utilisé, il DOIT s'agir du dernier codage de transfert appliqué au
Corps du message. Le codage de transfert « fragmenté » NE DOIT PAS être appliqué plus
plus d'une fois dans un corps de message. Ces règles permettent au destinataire de
déterminer la longueur de transfert du message (section 4.4).

Les codages de transfert sont analogues au Content-Transfer-Encoding
valeurs de MIME [7], qui ont été conçues pour permettre un transport sûr des
données binaires sur un service de transport 7 bits. Cependant, un transport sûr
a un objectif différent pour un protocole de transfert propre à 8 bits. En HTTP,
la seule caractéristique dangereuse des corps de message est la difficulté à
déterminer la longueur exacte du corps (section 7.2.2), ou le désir de
chiffrer les données sur un transport partagé.



Fielding et coll. Piste des normes [Page 24]
 
RFC 2616 HTTP/1.1 juin 1999


L'IANA (Internet Assigned Numbers Authority) agit comme un registre pour
jetons de valeur de codage de transfert. Initialement, le registre contient le
jetons suivants : "chunked" (section 3.6.1), "identity" (section
3.6.2), "gzip" (section 3.5), "compress" (section 3.5) et "deflate"
(rubrique 3.5).

Les nouveaux jetons de valeur de codage de transfert DEVRAIENT être enregistrés de la même manière
en tant que nouveaux jetons de valeur de codage de contenu (section 3.5).

Un serveur qui reçoit une entité-corps avec un codage de transfert qu'il fait
Je ne comprends pas DEVRAIT renvoyer 501 (non implémenté) et fermer le
connexion. Un serveur NE DOIT PAS envoyer de codes de transfert à un HTTP/1.0
client.

3.6.1 Codage de transfert fragmenté

L'encodage chunked modifie le corps d'un message afin de
transférez-le sous forme d'une série de morceaux, chacun avec son propre indicateur de taille,
suivi d'une bande-annonce FACULTATIF contenant des champs d'en-tête d'entité. Ce
permet de transférer le contenu produit dynamiquement avec le
informations nécessaires au destinataire pour vérifier qu'il a
reçu le message complet.

Corps en morceaux = *morceau
dernier morceau
bande-annonce
CRLF

chunk = taille de morceau [extension de morceau] CRLF
CRLF de données en morceaux
taille du morceau = 1*HEX
dernier morceau = 1*("0") [ extension de morceau ] CRLF

chunk-extension= *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
chunk-ext-name = jeton
chunk-ext-val = jeton | chaîne entre guillemets
chunk-data = chunk-size (OCTET)
trailer = *(entity-header CRLF)

Le champ de taille de bloc est une chaîne de chiffres hexadécimaux indiquant la taille de
le morceau. L'encodage fragmenté se termine par n'importe quel fragment dont la taille est
zéro, suivi de la fin, qui se termine par une ligne vide.

La bande-annonce permet à l'expéditeur d'inclure un en-tête HTTP supplémentaire
champs à la fin du message. Le champ d'en-tête Trailer peut être
utilisé pour indiquer quels champs d'en-tête sont inclus dans une fin (voir
article 14.40).




Fielding et coll. Piste des normes [Page 25]
 
RFC 2616 HTTP/1.1 juin 1999


Un serveur utilisant un codage de transfert fragmenté dans une réponse NE DOIT PAS utiliser le
trailer pour tout champ d'en-tête, sauf si au moins l'un des éléments suivants est
vrai:

a) la demande comprenait un champ d'en-tête TE qui indique que « trailers » est
acceptable dans le codage de transfert de la réponse, comme décrit dans
article 14.39 ; ou,

b)le serveur est le serveur d'origine de la réponse, la fin
les champs sont entièrement constitués de métadonnées facultatives et le destinataire
pourrait utiliser le message (d'une manière acceptable pour le serveur d'origine)
sans recevoir ces métadonnées. En d'autres termes, le serveur d'origine
est prêt à accepter la possibilité que les champs de remorques puissent
être jetés silencieusement tout au long du chemin vers le client.

Cette exigence évite un échec d'interopérabilité lorsque le
le message est reçu par un proxy HTTP/1.1 (ou version ultérieure) et
transmis à un destinataire HTTP/1.0. Cela évite une situation où
le respect du protocole aurait nécessité éventuellement une
tampon infini sur le proxy.

Un exemple de processus de décodage d'un Chunked-Body est présenté dans
annexe 19.4.6.

Toutes les applications HTTP/1.1 DOIVENT être capables de recevoir et de décoder le
codage de transfert « fragmenté » et DOIT ignorer les extensions d'extension de fragments
Ils ne comprennent pas.

3.7 Types de médias

HTTP utilise les types de médias Internet [17] dans le type de contenu (section
14.17) et Accepter (section 14.1) afin de fournir
typage de données ouvert et extensible et négociation de type.

media-type = type "/" sous-type *( paramètre ";" )
type = jeton
sous-type = jeton

Les paramètres PEUVENT suivre le type/sous-type sous forme d'attribut/valeur
paires (telles que définies à la section 3.6).

Les noms d'attribut de type, de sous-type et de paramètre sont en casse.
insensible. Les valeurs des paramètres peuvent ou non être sensibles à la casse,
en fonction de la sémantique du nom du paramètre. Espace blanc linéaire
(LWS) NE DOIT PAS être utilisé entre le type et le sous-type, ni entre un
attribut et sa valeur. La présence ou l'absence d'un paramètre peut
être significatif pour le traitement d'un type de média, en fonction de son
définition dans le registre des types de médias.



Fielding et coll. Voie des normes [Page 26]
 
RFC 2616 HTTP/1.1 juin 1999


Notez que certaines anciennes applications HTTP ne reconnaissent pas le type de média
paramètres. Lors de l'envoi de données vers des applications HTTP plus anciennes,
les implémentations DEVRAIENT utiliser uniquement les paramètres de type de média lorsqu'elles sont
requis par cette définition de type/sous-type.

Les valeurs de type de média sont enregistrées avec le numéro attribué par Internet
Autorité (IANA [19]). Le processus d'enregistrement du type de média est
décrit dans la RFC 1590 [17]. L'utilisation de types de médias non enregistrés est
découragé.

3.7.1 Canonicalisation et paramètres de texte par défaut

Les types de médias Internet sont enregistrés sous une forme canonique. Un
le corps d'entité transféré via des messages HTTP DOIT être représenté dans le
forme canonique appropriée avant sa transmission, sauf
types "texte", tels que définis dans le paragraphe suivant.

Sous forme canonique, les sous-types de média de type "texte" utilisent CRLF comme
le saut de ligne de texte. HTTP assouplit cette exigence et permet au
transport de supports texte avec CR ou LF simples représentant seuls une ligne
pause quand cela est fait de manière cohérente pour une entité-corps entière. HTTP
les applications DOIVENT accepter CRLF, CR nu et LF nu comme étant
représentatif d'un saut de ligne dans un support texte reçu via HTTP. Dans
De plus, si le texte est représenté dans un jeu de caractères qui ne
utiliser les octets 13 et 10 respectivement pour CR et LF, comme c'est le cas pour
certains jeux de caractères multi-octets, HTTP permet l'utilisation de n'importe quel octet
les séquences sont définies par ce jeu de caractères pour représenter le
équivalent de CR et LF pour les sauts de ligne. Cette flexibilité concernant
les sauts de ligne s'appliquent uniquement aux supports texte dans le corps de l'entité ; un CR nu
ou LF NE DOIT PAS être remplacé par CRLF dans aucun des contrôles HTTP
structures (telles que les champs d’en-tête et les limites en plusieurs parties).

Si un corps d'entité est codé avec un codage de contenu, le sous-jacent
les données DOIVENT être sous une forme définie ci-dessus avant d'être codées.

Le paramètre "charset" est utilisé avec certains types de médias pour définir le
jeu de caractères (section 3.4) des données. Lorsqu'il n'y a pas de jeu de caractères explicite
Le paramètre est fourni par l'expéditeur, les sous-types de média du "texte"
type sont définis pour avoir une valeur de jeu de caractères par défaut de "ISO-8859-1" lorsque
reçu via HTTP. Données dans des jeux de caractères autres que "ISO-8859-1" ou
ses sous-ensembles DOIVENT être étiquetés avec une valeur de jeu de caractères appropriée. Voir
section 3.4.1 pour les problèmes de compatibilité.

3.7.2 Types en plusieurs parties

MIME fournit un certain nombre de types "multipart" -- des encapsulations de
une ou plusieurs entités dans un seul corps de message. Tous en plusieurs parties
les types partagent une syntaxe commune, telle que définie dans la section 5.1.1 de la RFC 2046



Fielding et coll. Voie des normes [Page 27]
 
RFC 2616 HTTP/1.1 juin 1999


[40], et DOIT inclure un paramètre de limite dans le cadre du type de média
valeur. Le corps du message est lui-même un élément de protocole et DOIT
utilisez donc uniquement CRLF pour représenter les sauts de ligne entre les parties du corps.
Contrairement à la RFC 2046, l'épilogue de tout message en plusieurs parties DOIT être
vide; Les applications HTTP NE DOIVENT PAS transmettre l'épilogue (même si le
le multipart original contient un épilogue). Ces restrictions existent dans
afin de préserver la nature auto-délimitatrice d'un message en plusieurs parties-
corps, dans lequel la « fin » du corps du message est indiquée par le
fin de la limite en plusieurs parties.

En général, HTTP traite un corps de message en plusieurs parties de la même manière que
tout autre type de média : strictement en tant que charge utile. La seule exception est le
type "multipart/byteranges" (annexe 19.2) lorsqu'il apparaît dans un format 206
(Contenu partiel), qui sera interprétée par certains HTTP
mécanismes de mise en cache tels que décrits dans les sections 13.5.4 et 14.16. Dans tout
dans d'autres cas, un agent utilisateur HTTP DEVRAIT suivre le même ou un comportement similaire
comportement comme le ferait un agent utilisateur MIME à la réception d’un type multipart.
Les champs d'en-tête MIME dans chaque partie du corps d'un message en plusieurs parties.
body n'a aucune signification pour HTTP au-delà de celle définie par
leur sémantique MIME.

En général, un agent utilisateur HTTP DEVRAIT suivre le même ou similaire
comportement comme le ferait un agent utilisateur MIME à la réception d’un type multipart.
Si une application reçoit un sous-type multipart non reconnu, le
l'application DOIT le traiter comme étant équivalent à "multipart/mixed".

Remarque : Le type "multipart/form-data" a été spécifiquement défini
pour transporter des données de formulaire adaptées au traitement via le POST
méthode de requête, comme décrit dans la RFC 1867 [15].

3.8 Jetons de produit

Les jetons de produit sont utilisés pour permettre aux applications communicantes de
s'identifier par le nom et la version du logiciel. La plupart des champs utilisant
les jetons de produits autorisent également les sous-produits qui constituent une part importante
de l'application à lister, séparés par un espace blanc. Par
convention, les produits sont classés par ordre d'importance
pour identifier la demande.

produit = jeton ["/" version-produit]
version du produit = jeton

Exemples:

Agent utilisateur : CERN-LineMode/2.15 libwww/2.17b3
Serveur : Apache/0.8.4





Fielding et coll. Voie des normes [Page 28]
 
RFC 2616 HTTP/1.1 juin 1999


Les jetons de produit DEVRAIENT être courts et précis. Ils NE DOIVENT PAS être
utilisé à des fins publicitaires ou pour d’autres informations non essentielles. Bien que n'importe quel
Le caractère symbolique PEUT apparaître dans une version de produit, ce jeton DEVRAIT
être utilisé uniquement pour un identifiant de version (c'est-à-dire des versions successives de
le même produit DEVRAIT différer uniquement dans la partie version du produit de
la valeur du produit).

3.9 Valeurs de qualité

La négociation de contenu HTTP (section 12) utilise une courte « virgule flottante »
nombres pour indiquer l'importance relative (« poids ») de divers
paramètres négociables. Un poids est normalisé en un nombre réel dans
la plage de 0 à 1, où 0 est le minimum et 1 le maximum
valeur. Si un paramètre a une valeur de qualité de 0, alors contentez-vous de
ce paramètre n'est « pas acceptable » pour le client. HTTP/1.1
les applications NE DOIVENT PAS générer plus de trois chiffres après le
virgule. La configuration utilisateur de ces valeurs DEVRAIT également être
limité de cette façon.

qvalue = ( "0" [ "." 0*3DIGIT ] )
| ( "1" [ "." 0*3("0") ] )

« Valeurs de qualité » est un terme inapproprié, puisque ces valeurs représentent simplement
dégradation relative de la qualité souhaitée.

3.10 Balises de langue

Une balise de langue identifie une langue naturelle parlée, écrite ou
autrement transmis par des êtres humains pour la communication d'informations
envers les autres êtres humains. Les langages informatiques sont explicitement exclus.
HTTP utilise des balises de langue dans les champs Accept-Language et Content-
Champs de langue.

La syntaxe et le registre des balises du langage HTTP sont les mêmes que ceux
défini par la RFC 1766 [1]. En résumé, une balise de langue est composée de 1
ou plusieurs parties : une balise de langue principale et une série éventuellement vide de
sous-balises :

balise-langue = balise-primaire *( sous-balise "-" )
balise primaire = 1*8ALPHA
sous-étiquette = 1*8ALPHA

Les espaces blancs ne sont pas autorisés dans la balise et toutes les balises sont en casse.
insensible. L'espace de noms des balises de langue est géré par le
IANA. Exemples de balises :

fr, fr-US, fr-cockney, i-cherokee, x-pig-latin




Fielding et coll. Voie des normes [Page 29]
 
RFC 2616 HTTP/1.1 juin 1999


où toute balise principale à deux lettres est une abréviation de langue ISO-639
et toute sous-étiquette initiale de deux lettres est un code de pays ISO-3166. (Le
les trois dernières balises ci-dessus ne sont pas des balises enregistrées ; tous sauf le dernier sont
exemples de tags qui pourraient être enregistrés à l'avenir.)

3.11 Balises d'entité

Les balises d'entité sont utilisées pour comparer deux ou plusieurs entités du même
ressource demandée. HTTP/1.1 utilise des balises d'entité dans l'ETag (section
14.19), If-Match (section 14.24), If-None-Match (section 14.26) et
Champs d’en-tête If-Range (section 14.27). La définition de la façon dont ils
sont utilisés et comparés en tant que validateurs de cache dans la section 13.3.3. Un
La balise d'entité consiste en une chaîne opaque entre guillemets, éventuellement préfixée par
un indicateur de faiblesse.

balise-entité = [faible] balise-opaque
faible = "W/"
balise-opaque = chaîne entre guillemets

Une "étiquette d'entité forte" PEUT être partagée par deux entités d'une ressource
seulement s'ils sont équivalents par égalité d'octets.

Une « étiquette d'entité faible », indiquée par le préfixe « W/ », PEUT être partagée par
deux entités d'une ressource seulement si les entités sont équivalentes et
pourraient être substitués les uns aux autres sans changement significatif dans
sémantique. Une balise d’entité faible ne peut être utilisée qu’à des fins de comparaison faible.

Une balise d'entité DOIT être unique dans toutes les versions de toutes les entités
associé à une ressource particulière. Une valeur de balise d'entité donnée PEUT
être utilisé pour les entités obtenues par des requêtes sur différents URI. L'utilisation
de la même valeur de balise d'entité en conjonction avec des entités obtenues par
les requêtes sur des URI différents n’impliquent pas l’équivalence de celles-ci
entités.

3.12 Unités de portée

HTTP/1.1 permet à un client de demander que seule une partie (une plage) du
l’entité de réponse soit incluse dans la réponse. HTTP/1.1 utilise la plage
unités dans la plage (section 14.35) et la plage de contenu (section 14.16)
champs d'en-tête. Une entité peut être décomposée en sous-gammes selon
à diverses unités structurelles.

unité de plage = unité d'octets | unité-autre-gamme
octets-unité = "octets"
autre-range-unité = jeton

La seule unité de plage définie par HTTP/1.1 est les « octets ». HTTP/1.1
les implémentations PEUVENT ignorer les plages spécifiées en utilisant d'autres unités.



Fielding et coll. Piste des normes [Page 30]
 
RFC 2616 HTTP/1.1 juin 1999


HTTP/1.1 a été conçu pour permettre l'implémentation d'applications
qui ne dépendent pas de la connaissance des gammes.

4Messages HTTP

4.1 Types de messages

Les messages HTTP sont constitués de requêtes du client vers le serveur et de réponses
du serveur au client.

Message HTTP = Demande | Réponse ; Messages HTTP/1.1

Les messages de demande (section 5) et de réponse (section 6) utilisent le
format de message de la RFC 822 [9] pour les entités transférantes (la charge utile
du message). Les deux types de messages consistent en une ligne de départ, zéro
ou plusieurs champs d'en-tête (également appelés « en-têtes »), une ligne vide (c'est-à-dire,
une ligne sans rien précédant le CRLF) indiquant la fin du
champs d'en-tête, et éventuellement un corps de message.

message-générique = ligne de départ
*(en-tête de message CRLF)
CRLF
[ Corps du message ]
ligne de départ = Ligne de demande | Ligne d'état

Dans un souci de robustesse, les serveurs DEVRAIENT ignorer tout message vide
ligne(s) reçue(s) là où une Request-Line est attendue. Autrement dit, si
le serveur lit le flux de protocole au début d'un
message et reçoit un CRLF en premier, il doit ignorer le CRLF.

Certaines implémentations client HTTP/1.0 boguées génèrent des CRLF supplémentaires
après une requête POST. Pour rappeler ce qui est explicitement interdit par le
BNF, un client HTTP/1.1 NE DOIT PAS précéder ou suivre une requête par un
CRLF supplémentaire.

4.2 En-têtes de message

Champs d'en-tête HTTP, qui incluent l'en-tête général (section 4.5),
en-tête de requête (section 5.3), en-tête de réponse (section 6.2) et
les champs d'en-tête d'entité (section 7.1), suivent le même format générique que
celle donnée à la section 3.1 de la RFC 822 [9]. Chaque champ d'en-tête comprend
d'un nom suivi de deux points (":") et de la valeur du champ. Noms des champs
ne sont pas sensibles à la casse. La valeur du champ PEUT être précédée de n'importe quel montant
de LWS, bien qu’un seul SP soit préférable. Les champs d'en-tête peuvent être
étendu sur plusieurs lignes en faisant précéder chaque ligne supplémentaire d'au
au moins un SP ou HT. Les candidatures doivent suivre un « formulaire commun », où
on est connu ou indiqué, lors de la génération de constructions HTTP, puisque
il peut exister des implémentations qui n'acceptent rien



Fielding et coll. Voie des normes [Page 31]
 
RFC 2616 HTTP/1.1 juin 1999


au-delà des formes communes.

en-tête de message = nom de champ ":" [ valeur de champ ]
nom du champ = jeton
valeur du champ = *( contenu du champ | LWS )
field-content = <les OCTET composant la valeur du champ
et composé soit de *TEXTE, soit de combinaisons
du jeton, des séparateurs et de la chaîne entre guillemets>

Le contenu du champ n'inclut aucun LWS de début ou de fin :
espace blanc linéaire se produisant avant le premier espace non blanc
caractère de la valeur du champ ou après le dernier non-espace
caractère de la valeur du champ. Un tel LWS de début ou de fin PEUT être
supprimé sans modifier la sémantique de la valeur du champ. N'importe quel LWS
qui se produit entre le contenu du champ PEUT être remplacé par un seul SP
avant d'interpréter la valeur du champ ou de transmettre le message
en aval.

L'ordre dans lequel les champs d'en-tête avec des noms de champ différents sont
reçu n’est pas significatif. Cependant, c'est une « bonne pratique » d'envoyer
les champs d'en-tête général en premier, suivis de l'en-tête de demande ou de la réponse.
champs d'en-tête et se terminant par les champs d'en-tête d'entité.

Plusieurs champs d'en-tête de message avec le même nom de champ PEUVENT être
présent dans un message si et seulement si la valeur entière du champ pour ce
le champ d'en-tête est défini comme une liste séparée par des virgules [c'est-à-dire #(valeurs)].
Il DOIT être possible de combiner les plusieurs champs d'en-tête en un seul
paire "nom-champ : valeur-champ", sans changer la sémantique du
message, en ajoutant chaque valeur de champ suivante à la première, chaque
séparés par une virgule. L'ordre dans lequel les champs d'en-tête avec le même
le nom du champ sont reçus est donc important pour le
interprétation de la valeur du champ combiné, et donc un proxy NE DOIT PAS
modifier l'ordre de ces valeurs de champ lorsqu'un message est transféré.

4.3 Corps du message

Le corps du message (le cas échéant) d'un message HTTP est utilisé pour transporter le
corps d'entité associé à la demande ou à la réponse. Le corps du message
ne diffère de l'entité-corps que lorsqu'un transfert-codage a été
appliqué, comme l'indique le champ d'en-tête Transfer-Encoding (section
14.41).

corps du message = corps de l'entité
| <corps d'entité codé selon Transfer-Encoding>

Transfer-Encoding DOIT être utilisé pour indiquer tout codage de transfert
appliqué par une application pour garantir un transfert sûr et approprié du
message. Transfer-Encoding est une propriété du message, pas du



Fielding et coll. Piste des normes [Page 32]
 
RFC 2616 HTTP/1.1 juin 1999


entité, et PEUT donc être ajouté ou supprimé par toute application le long du
chaîne de requête/réponse. (Cependant, la section 3.6 impose des restrictions sur
lorsque certains codages de transfert peuvent être utilisés.)

Les règles régissant le moment où un corps de message est autorisé dans un message diffèrent pour
demandes et réponses.

La présence d'un corps de message dans une requête est signalée par le
inclusion d'un champ d'en-tête Content-Length ou Transfer-Encoding dans
les en-têtes de message de la requête. Un corps de message NE DOIT PAS être inclus dans
une requête si la spécification de la méthode de requête (section 5.1.1)
ne permet pas d'envoyer une entité-corps dans les requêtes. Un serveur DEVRAIT
lire et transmettre un corps de message pour toute demande ; si la méthode de demande
n'inclut pas de sémantique définie pour une entité-corps, alors le
le corps du message DEVRAIT être ignoré lors du traitement de la demande.

Pour les messages de réponse, qu'un corps de message soit inclus ou non avec
un message dépend à la fois de la méthode de requête et de la réponse
code d’état (section 6.1.1). Toutes les réponses à la méthode de requête HEAD
NE DOIT PAS inclure de corps de message, même si la présence d'entité-
les champs d’en-tête pourraient laisser croire que c’est le cas. Tous 1xx
(informatif), 204 (aucun contenu) et 304 (non modifié) réponses
NE DOIT PAS inclure de corps de message. Toutes les autres réponses incluent un
corps du message, bien qu'il PEUT être de longueur nulle.

4.4 Longueur du message

La longueur de transfert d'un message est la longueur du corps du message telle que
il apparaît dans le message ; c'est-à-dire, après que tous les codages de transfert aient été
été appliquée. Lorsqu'un corps de message est inclus dans un message, le
la durée de transfert de ce corps est déterminée par l'un des éléments suivants
(par ordre de priorité) :

1. Tout message de réponse qui « NE DOIT PAS » inclure un corps de message (tel que
comme les réponses 1xx, 204 et 304 et toute réponse à un HEAD
requête) se termine toujours par la première ligne vide après le
champs d'en-tête, quels que soient les champs d'en-tête d'entité présents dans
le message.

2.Si un champ d’en-tête Transfer-Encoding (section 14.41) est présent et
a une valeur autre que « identité », alors la longueur de transfert est
défini par l'utilisation du codage de transfert « fragmenté » (section 3.6),
sauf si le message est terminé en fermant la connexion.

3.Si un champ d'en-tête Content-Length (section 14.13) est présent, son
la valeur décimale dans les OCTET représente à la fois la longueur de l'entité et la
longueur de transfert. Le champ d’en-tête Content-Length NE DOIT PAS être envoyé
si ces deux longueurs sont différentes (c'est-à-dire si un Transfer-Encoding



Fielding et coll. Voie des normes [Page 33]
 
RFC 2616 HTTP/1.1 juin 1999


le champ d'en-tête est présent). Si un message est reçu avec à la fois un
Un champ d'entête Transfer-Encoding et un champ d'entête Content-Length,
ce dernier DOIT être ignoré.

4.Si le message utilise le type de média "multipart/byteranges" et que le
la longueur du transfert n'est pas spécifiée autrement, alors cette
l'élimination du type de média définit la longueur du transfert. Ce type de média
NE DOIT PAS être utilisé à moins que l'expéditeur sache que le destinataire peut
il; la présence dans une requête d'un entête Range à plusieurs octets
les spécificateurs de plage d'un client 1.1 impliquent que le client peut analyser
réponses multipart/byteranges.

Un en-tête de plage peut être transmis par un proxy 1.0 qui ne le fait pas.
comprendre les multiparts/byteranges ; dans ce cas, le serveur DOIT
délimiter le message à l'aide des méthodes définies aux points 1,3 ou 5 de
cette section.

5.Par le serveur fermant la connexion. (Fermeture de la connexion
ne peut pas être utilisé pour indiquer la fin du corps d’une requête, car cela
ne laisserait aucune possibilité au serveur de renvoyer une réponse.)

Pour la compatibilité avec les applications HTTP/1.0, les requêtes HTTP/1.1
contenant un corps de message DOIT inclure un en-tête Content-Length valide
sauf si le serveur est connu pour être conforme à HTTP/1.1. Si un
la requête contient un corps de message et une longueur de contenu n'est pas donnée,
le serveur DEVRAIT répondre par 400 (mauvaise requête) s'il ne peut pas
déterminer la longueur du message, ou avec 411 (longueur requise) si
il souhaite insister pour recevoir une longueur de contenu valide.

Toutes les applications HTTP/1.1 qui reçoivent des entités DOIVENT accepter le
codage de transfert « fragmenté » (section 3.6), permettant ainsi ce mécanisme
à utiliser pour les messages dont la longueur ne peut pas être déterminée
à l'avance.

Les messages NE DOIVENT PAS inclure à la fois un champ d'en-tête Content-Length et un
codage de transfert sans identité. Si le message inclut un non-
Lors du codage de transfert d'identité, la longueur du contenu DOIT être ignorée.

Lorsqu'une longueur de contenu est donnée dans un message où un corps de message est
autorisé, sa valeur de champ DOIT correspondre exactement au nombre d'OCTET dans
le corps du message. Les agents utilisateurs HTTP/1.1 DOIVENT avertir l'utilisateur lorsqu'un
une longueur invalide est reçue et détectée.

4.5 Champs d'en-tête généraux

Il existe quelques champs d'en-tête qui ont une applicabilité générale pour
à la fois des messages de demande et de réponse, mais qui ne s'appliquent pas au
entité transférée. Ces champs d'en-tête s'appliquent uniquement à



Fielding et coll. Voie des normes [Page 34]
 
RFC 2616 HTTP/1.1 juin 1999


message en cours de transmission.

en-tête général = Cache-Control ; Article 14.9
| Connexion ; Article 14.10
| Date ; Article 14.18
| Pragme ; Article 14.32
| Bande-annonce ; Article 14.40
| Transfert-Encodage ; Article 14.41
| Mise à niveau ; Article 14.42
| Via ; Article 14.45
| Avertissement ; Article 14.46

Les noms de champs d'en-tête général ne peuvent être étendus de manière fiable que dans
combinaison avec un changement dans la version du protocole. Cependant, nouveau ou
les champs d'en-tête expérimentaux peuvent recevoir la sémantique des champs généraux
champs d'en-tête si toutes les parties à la communication les reconnaissent pour
être des champs d'en-tête généraux. Les champs d'en-tête non reconnus sont traités comme
champs d’en-tête d’entité.

5 Demande

Un message de requête d'un client à un serveur comprend, dans le
première ligne de ce message, la méthode à appliquer à la ressource,
l'identifiant de la ressource et la version du protocole utilisée.

Demande = Ligne de demande ; Article 5.1
*(( en-tête général ; Section 4.5
| en-tête de requête ; Article 5.3
| en-tête d'entité ) CRLF) ; Article 7.1
CRLF
[ Corps du message ] ; Section 4.3

5.1 Ligne de demande

La Request-Line commence par un jeton de méthode, suivi du
Request-URI et la version du protocole, et se terminant par CRLF. Le
les éléments sont séparés par des caractères SP. Aucun CR ou LF n'est autorisé
sauf dans la séquence CRLF finale.

Request-Line = Méthode SP Request-URI SP HTTP-Version CRLF











Fielding et coll. Voie des normes [Page 35]
 
RFC 2616 HTTP/1.1 juin 1999


5.1.1 Méthode

Le jeton Méthode indique la méthode à exécuter sur le
ressource identifiée par le Request-URI. La méthode est sensible à la casse.

Méthode = "OPTIONS" ; Article 9.2
| "OBTENIR" ; Article 9.3
| "TÊTE" ; Article 9.4
| "POSTE" ; Article 9.5
| "METTRE" ; Article 9.6
| "SUPPRIMER" ; Article 9.7
| "TRACER" ; Article 9.8
| "CONNECTER" ; Article 9.9
| méthode d'extension
méthode d'extension = jeton

La liste des méthodes autorisées par une ressource peut être spécifiée dans un
Autoriser le champ d’en-tête (section 14.7). Le code retour de la réponse
informe toujours le client si une méthode est actuellement autorisée sur un
ressource, puisque l’ensemble des méthodes autorisées peut changer dynamiquement. Un
le serveur d'origine DEVRAIT renvoyer le code d'état 405 (méthode non autorisée)
si la méthode est connue du serveur d'origine mais n'est pas autorisée pour le
ressource demandée, et 501 (Non implémenté) si la méthode est
non reconnu ou non implémenté par le serveur d'origine. Les méthodes GET
et HEAD DOIT être pris en charge par tous les serveurs à usage général. Tous les autres
les méthodes sont FACULTATIVES ; cependant, si les méthodes ci-dessus sont mises en œuvre,
ils DOIVENT être implémentés avec la même sémantique que celles spécifiées
à l'article 9.

5.1.2 URI de requête

Le Request-URI est un identifiant de ressource uniforme (section 3.2) et
identifie la ressource sur laquelle appliquer la demande.

URI de requête = "*" | URI absolu | abs_path | autorité

Les quatre options pour Request-URI dépendent de la nature du
demande. L'astérisque « * » signifie que la demande ne s'applique pas à un
ressource particulière, mais au serveur lui-même, et n'est autorisé que
lorsque la méthode utilisée ne s’applique pas nécessairement à une ressource. Un
un exemple serait

OPTIONS * HTTP/1.1

Le formulaire AbsoluteURI est OBLIGATOIRE lorsque la demande est adressée à un
Procuration. Le mandataire est prié de transmettre la demande ou de la signifier
à partir d'un cache valide et renvoie la réponse. Notez que le proxy PEUT
transmettre la requête à un autre proxy ou directement au serveur



Fielding et coll. Voie des normes [Page 36]
 
RFC 2616 HTTP/1.1 juin 1999


spécifié par l'URI absolu. Afin d'éviter les boucles de requêtes, un
le proxy DOIT être capable de reconnaître tous ses noms de serveur, y compris
tous les alias, variantes locales et adresse IP numérique. Un exemple
La ligne de demande serait :

OBTENIR http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1

Pour permettre la transition vers les URI absolus dans toutes les requêtes à l'avenir
versions de HTTP, tous les serveurs HTTP/1.1 DOIVENT accepter l'URI absolu
formulaire dans les requêtes, même si les clients HTTP/1.1 ne généreront que
eux dans les demandes de procuration.

La forme d'autorité n'est utilisée que par la méthode CONNECT (section 9.9).

La forme la plus courante de Request-URI est celle utilisée pour identifier un
ressource sur un serveur ou une passerelle d’origine. Dans ce cas, l'absolu
Le chemin de l'URI DOIT être transmis (voir section 3.2.1, abs_path) comme
le Request-URI et l'emplacement réseau de l'URI (autorité) DOIVENT
être transmis dans un champ d’en-tête Host. Par exemple, un client souhaitant
récupérer la ressource ci-dessus directement depuis le serveur d'origine serait
créez une connexion TCP sur le port 80 de l'hôte "www.w3.org" et envoyez
les lignes:

OBTENIR /pub/WWW/TheProject.html HTTP/1.1
Hébergeur : www.w3.org

suivi du reste de la demande. Notez que le chemin absolu
ne peux pas être vide; si aucun n'est présent dans l'URI d'origine, il DOIT l'être
donné sous la forme "/" (la racine du serveur).

Le Request-URI est transmis dans le format spécifié dans la section
3.2.1. Si le Request-URI est codé en utilisant le codage "% HEX HEX"
[42], le serveur d'origine DOIT décoder le Request-URI afin de
interpréter correctement la demande. Les serveurs DEVRAIENT répondre à un message invalide
URI de requête avec un code d’état approprié.

Un proxy transparent NE DOIT PAS réécrire la partie "abs_path" du
reçu Request-URI lors de son transfert vers le prochain serveur entrant,
sauf comme indiqué ci-dessus pour remplacer un abs_path nul par "/".

Remarque : La règle « pas de réécriture » ​​empêche le proxy de modifier le
signification de la requête lorsque le serveur d'origine utilise de manière inappropriée
un caractère URI non réservé dans un but réservé. Réalisateurs
devez savoir que certains proxys pré-HTTP/1.1 sont connus pour
réécrivez le Request-URI.






Fielding et coll. Voie des normes [Page 37]
 
RFC 2616 HTTP/1.1 juin 1999


5.2 La ressource identifiée par une requête

La ressource exacte identifiée par une requête Internet est déterminée par
en examinant à la fois le Request-URI et le champ d’en-tête Host.

Un serveur d'origine qui ne permet pas aux ressources de différer selon le
l'hôte demandé PEUT ignorer la valeur du champ d'en-tête Host lorsque
déterminer la ressource identifiée par une requête HTTP/1.1. (Mais voyez
section 19.6.1.1 pour d'autres exigences sur la prise en charge de l'hôte dans HTTP/1.1.)

Un serveur d'origine qui différencie les ressources en fonction de l'hôte
demandé (parfois appelé hôtes virtuels ou hôte personnalisé
noms) DOIT utiliser les règles suivantes pour déterminer les noms demandés
ressource sur une requête HTTP/1.1 :

1. Si Request-URI est un absoluURI, l'hôte fait partie du
URI de requête. Toute valeur de champ d'en-tête Host dans la demande DOIT être
ignoré.

2. Si le Request-URI n'est pas un absoluURI et que la requête inclut
un champ d'en-tête Host, l'hôte est déterminé par l'en-tête Host
valeur du champ.

3. Si l'hôte tel que déterminé par la règle 1 ou 2 n'est pas un hôte valide sur
le serveur, la réponse DOIT être un message d'erreur 400 (Bad Request).

Les destinataires d'une requête HTTP/1.0 dépourvue de champ d'en-tête Host PEUVENT
tenter d'utiliser des heuristiques (par exemple, examen du chemin URI pour
quelque chose d'unique à un hôte particulier) afin de déterminer ce
la ressource exacte est demandée.

5.3 Champs d'en-tête de demande

Les champs d'en-tête de requête permettent au client de transmettre des
informations sur la demande et sur le client lui-même, au
serveur. Ces champs agissent comme des modificateurs de requête, avec une sémantique
équivalent aux paramètres d'une méthode de langage de programmation
invocation.

en-tête de demande = Accepter ; Article 14.1
| Accepter-Charset ; Article 14.2
| Accepter-Encodage ; Article 14.3
| Accepter-Langue ; Article 14.4
| Autorisation ; Article 14.8
| Attendre ; Article 14.20
| Depuis ; Article 14.22
| Hôte ; Article 14.23
| Si-Match ; Article 14.24



Fielding et coll. Voie des normes [Page 38]
 
RFC 2616 HTTP/1.1 juin 1999


| Si-Modifié-Depuis ; Article 14.25
| Si-Aucun-Match ; Article 14.26
| Si-Plage ; Article 14.27
| Si-non modifié-depuis ; Article 14.28
| Max-Forwards ; Article 14.31
| Autorisation par procuration ; Article 14.34
| Gamme ; Article 14.35
| Référent ; Article 14.36
| TE ; Article 14.39
| Agent utilisateur ; Article 14.43

Les noms de champs d'en-tête de requête peuvent être étendus de manière fiable uniquement dans
combinaison avec un changement dans la version du protocole. Cependant, nouveau ou
les champs d'en-tête expérimentaux PEUVENT recevoir la sémantique de la requête.
champs d'en-tête si toutes les parties à la communication les reconnaissent pour
être des champs d’en-tête de demande. Les champs d'en-tête non reconnus sont traités comme
champs d’en-tête d’entité.

6 Réponse

Après avoir reçu et interprété un message de requête, un serveur répond
avec un message de réponse HTTP.

Réponse = Ligne d'état ; Article 6.1
*(( en-tête général ; Section 4.5
| en-tête de réponse ; Article 6.2
| en-tête d'entité ) CRLF) ; Article 7.1
CRLF
[ Corps du message ] ; Article 7.2

6.1 Ligne d'état

La première ligne d'un message de réponse est la Status-Line, composée
de la version du protocole suivi d'un code d'état numérique et de son
phrase textuelle associée, avec chaque élément séparé par SP
personnages. Aucun CR ou LF n'est autorisé sauf dans la séquence CRLF finale.

Ligne d'état = Version HTTP SP Code d'état SP Raison-Phrase CRLF

6.1.1 Code d'état et phrase de raison

L'élément Status-Code est un code de résultat entier à 3 chiffres du
tenter de comprendre et de satisfaire la demande. Ces codes sont entièrement
défini à la section 10. La phrase-raison est destinée à donner un bref
description textuelle du code d'état. Le code d'état est destiné
pour une utilisation par les automates et la phrase-raison est destinée à l'homme
utilisateur. Le client n'est pas tenu d'examiner ou d'afficher le motif.
Phrase.



Fielding et coll. Voie des normes [Page 39]
 
RFC 2616 HTTP/1.1 juin 1999


Le premier chiffre du Status-Code définit la classe de réponse. Le
les deux derniers chiffres n'ont aucun rôle de catégorisation. Il y en a 5
valeurs pour le premier chiffre :

- 1xx : Information – Demande reçue, processus en cours

- 2xx : Succès - L'action a été reçue avec succès,
compris et accepté

- 3xx : Redirection - Des mesures supplémentaires doivent être prises pour
compléter la demande

- 4xx : Erreur client - La requête contient une mauvaise syntaxe ou ne peut pas
être comblé

- 5xx : Erreur du serveur - Le serveur n'a apparemment pas réussi à remplir une
demande valide

Les valeurs individuelles des codes d'état numériques définis pour
HTTP/1.1 et un exemple d'ensemble de phrases de raison correspondantes sont
présenté ci-dessous. Les phrases de raison répertoriées ici sont uniquement
recommandations -- elles PEUVENT être remplacées par des équivalents locaux sans
affectant le protocole.

Code d'état =
"100" ; Section 10.1.1 : Continuer
| "101" ; Section 10.1.2 : Protocoles de commutation
| "200" ; Section 10.2.1 : OK
| "201" ; Section 10.2.2 : Créé
| "202" ; Section 10.2.3 : Accepté
| "203" ; Section 10.2.4 : Informations ne faisant pas autorité
| "204" ; Section 10.2.5 : Aucun contenu
| "205" ; Section 10.2.6 : Réinitialiser le contenu
| "206" ; Section 10.2.7 : Contenu partiel
| "300" ; Section 10.3.1 : Choix multiples
| "301" ; Section 10.3.2 : Déplacé de façon permanente
| "302" ; Section 10.3.3 : Trouvé
| "303" ; Section 10.3.4 : Voir Autre
| "304" ; Section 10.3.5 : Non modifié
| "305" ; Section 10.3.6 : Utiliser un proxy
| "307" ; Section 10.3.8 : Redirection temporaire
| "400" ; Section 10.4.1 : Requête incorrecte
| "401" ; Section 10.4.2 : Non autorisé
| "402" ; Section 10.4.3 : Paiement requis
| "403" ; Section 10.4.4 : Interdit
| "404" ; Section 10.4.5 : Introuvable
| "405" ; Section 10.4.6 : Méthode non autorisée
| "406" ; Section 10.4.7 : Non acceptable



Fielding et coll. Voie des normes [Page 40]
 
RFC 2616 HTTP/1.1 juin 1999


| "407" ; Section 10.4.8 : Authentification proxy requise
| "408" ; Section 10.4.9 : Expiration du délai de demande
| "409" ; Section 10.4.10 : Conflit
| "410" ; Section 10.4.11 : Disparu
| "411" ; Section 10.4.12 : Longueur requise
| "412" ; Section 10.4.13 : Échec de la condition préalable
| "413" ; Section 10.4.14 : Entité de requête trop grande
| "414" ; Section 10.4.15 : URI de requête trop grand
| "415" ; Section 10.4.16 : Type de média non pris en charge
| "416" ; Section 10.4.17 : Plage demandée non satisfaisable
| "417" ; Section 10.4.18 : Attente échouée
| "500" ; Section 10.5.1 : Erreur interne du serveur
| "501" ; Section 10.5.2 : Non mis en œuvre
| "502" ; Section 10.5.3 : Passerelle incorrecte
| "503" ; Section 10.5.4 : Service indisponible
| "504" ; Section 10.5.5 : Délai d'expiration de la passerelle
| "505" ; Section 10.5.6 : Version HTTP non prise en charge
| code d'extension

code d'extension = 3DIGIT
Raison-Phrase = *<TEXTE, à l'exclusion de CR, LF>

Les codes d'état HTTP sont extensibles. Les applications HTTP ne sont pas requises
comprendre la signification de tous les codes de statut enregistrés, bien que tels
la compréhension est évidemment souhaitable. Cependant, les candidatures DOIVENT
comprendre la classe de tout code d'état, comme indiqué par le premier
chiffre et traiter toute réponse non reconnue comme étant équivalente au
code d'état x00 de cette classe, à l'exception d'un
une réponse non reconnue NE DOIT PAS être mise en cache. Par exemple, si un
le code d'état non reconnu 431 est reçu par le client, il peut
supposer en toute sécurité qu'il y avait quelque chose de mal avec sa demande et
traiter la réponse comme si elle avait reçu un code d'état 400. Dans un tel
Dans certains cas, les agents utilisateurs DEVRAIENT présenter à l'utilisateur l'entité renvoyée.
avec la réponse, puisque cette entité est susceptible d’inclure des personnes
informations lisibles qui expliqueront le statut inhabituel.

6.2 Champs d'en-tête de réponse

Les champs d'en-tête de réponse permettent au serveur de transmettre des
informations sur la réponse qui ne peuvent pas être placées dans le Status-
Doubler. Ces champs d'en-tête donnent des informations sur le serveur et sur
un accès supplémentaire à la ressource identifiée par le Request-URI.

en-tête de réponse = Accept-Ranges ; Article 14.5
| Âge ; Article 14.6
| Etag ; Article 14.19
| Emplacement ; Article 14.30
| Proxy-Authentifier ; Article 14.33



Fielding et coll. Voie des normes [Page 41]
 
RFC 2616 HTTP/1.1 juin 1999


| Réessayer après ; Article 14.37
| Serveur ; Article 14.38
| Varier ; Article 14.44
| WWW-Authentifier ; Article 14.47

Les noms de champs d'en-tête de réponse ne peuvent être étendus de manière fiable que dans
combinaison avec un changement dans la version du protocole. Cependant, nouveau ou
les champs d'en-tête expérimentaux PEUVENT recevoir la sémantique de la réponse-
champs d'en-tête si toutes les parties à la communication les reconnaissent pour
être des champs d’en-tête de réponse. Les champs d'en-tête non reconnus sont traités comme
champs d’en-tête d’entité.

7 Entité

Les messages de demande et de réponse PEUVENT transférer une entité sauf autrement
limité par la méthode de demande ou le code d’état de la réponse. Une entité
se compose de champs d'en-tête d'entité et d'un corps d'entité, bien que certains
les réponses incluront uniquement les en-têtes d’entité.

Dans cette section, l'expéditeur et le destinataire font référence soit au client
ou le serveur, selon qui envoie et qui reçoit l'entité.

7.1 Champs d'en-tête d'entité

Les champs d'en-tête d'entité définissent des métainformations sur le corps de l'entité ou,
si aucun organisme n'est présent, sur la ressource identifiée par la demande.
Certaines de ces métainformations sont FACULTATIVES ; certains pourraient être EXIGÉS par
parties de cette spécification.

en-tête d'entité = Autoriser ; Article 14.7
| Encodage de contenu ; Article 14.11
| Contenu-Langage ; Article 14.12
| Contenu-Longueur ; Article 14.13
| Emplacement du contenu ; Article 14.14
| Contenu-MD5 ; Article 14.15
| Gamme de contenu ; Article 14.16
| Type de contenu ; Article 14.17
| Expire ; Article 14.21
| Dernière modification ; Article 14.29
| en-tête d'extension

extension-header = message-en-tête

Le mécanisme d'en-tête d'extension autorise des champs d'en-tête d'entité supplémentaires
à définir sans changer le protocole, mais ces champs ne peuvent pas
être supposé reconnaissable par le destinataire. En-tête non reconnu
les champs DEVRAIENT être ignorés par le destinataire et DOIVENT être transmis par
procurations transparentes.



Fielding et coll. Voie des normes [Page 42]
 
RFC 2616 HTTP/1.1 juin 1999


7.2 Corps de l'entité

Le corps de l'entité (le cas échéant) envoyé avec une requête ou une réponse HTTP est dans
un format et un codage définis par les champs d'en-tête d'entité.

corps-entité = *OCTET

Un corps d'entité n'est présent dans un message que lorsqu'un corps de message est
présents, comme décrit à la section 4.3. L'entité-corps est obtenue
du corps du message en décodant tout Transfer-Encoding qui pourrait
ont été appliqués pour garantir un transfert sûr et approprié du message.

7.2.1 Type

Lorsqu'un corps d'entité est inclus dans un message, le type de données de celui-ci
Le corps est déterminé via les champs d'en-tête Content-Type et Content-
Codage. Ceux-ci définissent un modèle de codage ordonné à deux couches :

corps-d'entité := Content-Encoding( Content-Type( data ) )

Content-Type spécifie le type de média des données sous-jacentes.
Content-Encoding peut être utilisé pour indiquer tout contenu supplémentaire
codages appliqués aux données, généralement à des fins de données
compression, qui sont une propriété de la ressource demandée. Il y a
pas d'encodage par défaut.

Tout message HTTP/1.1 contenant un corps d'entité DEVRAIT inclure un
Champ d’en-tête Content-Type définissant le type de média de ce corps. Si
et seulement si le type de média n'est pas donné par un champ Content-Type, le
le destinataire PEUT tenter de deviner le type de média en inspectant son
contenu et/ou la ou les extensions de nom de l'URI utilisées pour identifier le
Ressource. Si le type de média reste inconnu, le destinataire DEVRAIT
traitez-le comme du type "application/octet-stream".

7.2.2 Longueur de l'entité

La longueur de l'entité d'un message est la longueur du corps du message
avant que des codages de transfert aient été appliqués. La section 4.4 définit
comment la longueur de transfert d'un corps de message est déterminée.












Fielding et coll. Voie des normes [Page 43]
 
RFC 2616 HTTP/1.1 juin 1999


8 connexions

8.1 Connexions persistantes

8.1.1 Objectif

Avant les connexions persistantes, une connexion TCP distincte était
établi pour récupérer chaque URL, augmentant ainsi la charge sur les serveurs HTTP
et provoquant une congestion sur Internet. L'utilisation d'images en ligne et
d'autres données associées nécessitent souvent qu'un client fasse plusieurs
requêtes du même serveur dans un court laps de temps. Analyse de
ces problèmes de performances et résultats d'un prototype
des implémentations sont disponibles [26] [30]. Expérience de mise en œuvre et
les mesures des implémentations réelles de HTTP/1.1 (RFC 2068) montrent de bonnes
résultats [39]. Des alternatives ont également été explorées, par exemple,
T/TCP [27].

Les connexions HTTP persistantes présentent de nombreux avantages :

- En ouvrant et fermant moins de connexions TCP, le temps CPU est économisé
dans les routeurs et les hôtes (clients, serveurs, proxys, passerelles,
tunnels ou caches) et la mémoire utilisée pour le contrôle du protocole TCP
les blocs peuvent être enregistrés dans les hôtes.

- Les requêtes et réponses HTTP peuvent être acheminées sur une connexion.
Le pipeline permet à un client de faire plusieurs demandes sans
en attente de chaque réponse, permettant à une seule connexion TCP de
être utilisé beaucoup plus efficacement, avec un temps écoulé beaucoup plus court.

- La congestion du réseau est réduite en réduisant le nombre de paquets
causé par l'ouverture de TCP et en laissant à TCP suffisamment de temps pour
déterminer l'état de congestion du réseau.

- La latence sur les requêtes ultérieures est réduite puisqu'il n'y a pas de temps
dépensé dans la poignée de main d'ouverture de la connexion TCP.

- HTTP peut évoluer plus gracieusement, puisque des erreurs peuvent être signalées
sans la pénalité de fermeture de la connexion TCP. Clients utilisant
les futures versions de HTTP pourraient, avec optimisme, essayer une nouvelle fonctionnalité,
mais si vous communiquez avec un serveur plus ancien, réessayez avec l'ancien
sémantique après qu’une erreur soit signalée.

Les implémentations HTTP DEVRAIENT implémenter des connexions persistantes.








Fielding et coll. Voie des normes [Page 44]
 
RFC 2616 HTTP/1.1 juin 1999


8.1.2 Fonctionnement global

Une différence significative entre HTTP/1.1 et les versions antérieures de
HTTP est que les connexions persistantes sont le comportement par défaut de tout
Connexion HTTP. Autrement dit, sauf indication contraire, le client
DEVRAIT supposer que le serveur maintiendra une connexion persistante,
même après des réponses d'erreur du serveur.

Les connexions persistantes fournissent un mécanisme par lequel un client et un
Le serveur peut signaler la fermeture d'une connexion TCP. Cette signalisation prend
placer à l’aide du champ d’en-tête Connexion (section 14.10). Une fois la clôture
a été signalé, le client NE DOIT PAS envoyer de requêtes supplémentaires à ce sujet
connexion.

8.1.2.1 Négociation

Un serveur HTTP/1.1 PEUT supposer qu'un client HTTP/1.1 a l'intention de
maintenir une connexion persistante à moins qu'un en-tête de connexion comprenant
le jeton de connexion « close » a été envoyé dans la demande. Si le serveur
choisit de fermer la connexion immédiatement après l'envoi du
réponse, il DEVRAIT envoyer un en-tête de connexion incluant le
fermeture du jeton de connexion.

Un client HTTP/1.1 PEUT s'attendre à ce qu'une connexion reste ouverte, mais
décidez de le garder ouvert selon que la réponse d'un serveur
contient un en-tête Connection avec la fermeture du jeton de connexion. Au cas où
le client ne souhaite pas maintenir une connexion plus longtemps que cela
demande, il DEVRAIT envoyer un en-tête de connexion incluant le
fermeture du jeton de connexion.

Si le client ou le serveur envoie le jeton de fermeture dans le
En-tête de connexion, cette requête devient la dernière pour le
connexion.

Les clients et les serveurs NE DEVRAIENT PAS supposer qu'une connexion persistante est
maintenu pour les versions HTTP inférieures à 1.1, sauf si cela est explicitement
signalé. Voir la section 19.6.2 pour plus d'informations sur la marche arrière.
compatibilité avec les clients HTTP/1.0.

Afin de rester persistants, tous les messages sur la connexion DOIVENT
avoir une longueur de message auto-définie (c'est-à-dire non définie par la fermeture
de la connexion), comme décrit dans la section 4.4.









Fielding et coll. Voie des normes [Page 45]
 
RFC 2616 HTTP/1.1 juin 1999


8.1.2.2 Pipeline

Un client qui prend en charge les connexions persistantes PEUT « pipeline » ses
demandes (c'est-à-dire envoyer plusieurs demandes sans attendre chacune
réponse). Un serveur DOIT envoyer ses réponses à ces requêtes dans le
même ordre que les demandes ont été reçues.

Clients qui assument des connexions persistantes et un pipeline immédiatement
après l'établissement de la connexion DEVRAIT être prêt à réessayer son
connexion si la première tentative pipeline échoue. Si un client le fait
une telle nouvelle tentative, il NE DOIT PAS pipeliner avant de savoir que la connexion est établie.
persistant. Les clients DOIVENT également être prêts à renvoyer leurs demandes si
le serveur ferme la connexion avant d'envoyer tous les
réponses correspondantes.

Les clients NE DEVRAIENT PAS canaliser les requêtes en utilisant des méthodes non idempotentes ou
séquences de méthodes non idempotentes (voir section 9.1.2). Sinon, un
une interruption prématurée de la liaison de transport pourrait entraîner
résultats indéterminés. Un client souhaitant envoyer un non-idempotent
demande DEVRAIT attendre pour envoyer cette demande jusqu'à ce qu'elle ait reçu le
état de réponse pour la demande précédente.

8.1.3 Serveurs proxy

Il est particulièrement important que les proxys mettent correctement en œuvre les
propriétés du champ d'en-tête Connexion comme spécifié dans la section
14.10.

Le serveur proxy DOIT signaler les connexions persistantes séparément avec
ses clients et les serveurs d'origine (ou autres serveurs proxy) qu'il
se connecte à. Chaque connexion persistante s'applique à un seul transport
lien.

Un serveur proxy NE DOIT PAS établir de connexion persistante HTTP/1.1
avec un client HTTP/1.0 (mais voir RFC 2068 [33] pour plus d'informations et
discussion des problèmes avec l'en-tête Keep-Alive implémenté par
de nombreux clients HTTP/1.0).

8.1.4 Considérations pratiques

Les serveurs auront généralement un certain délai d'attente au-delà duquel ils
ne maintient plus une connexion inactive. Les serveurs proxy peuvent faire
c'est une valeur plus élevée car il est probable que le client fera
plus de connexions via le même serveur. L'utilisation de persistants
les connexions n’imposent aucune exigence sur la longueur (ou l’existence) des
ce délai d'attente soit pour le client, soit pour le serveur.





Fielding et coll. Voie des normes [Page 46]
 
RFC 2616 HTTP/1.1 juin 1999


Lorsqu'un client ou un serveur souhaite expirer, il DEVRAIT émettre un message gracieux
fermer sur la liaison de transport. Les clients et les serveurs DEVRAIENT tous deux
surveillez constamment l’autre côté du transport, et
y répondre comme il convient. Si un client ou un serveur ne détecte pas
l'autre côté se ferme rapidement, cela pourrait entraîner des ressources inutiles
drainer sur le réseau.

Un client, un serveur ou un proxy PEUT fermer la connexion de transport à tout moment.
temps. Par exemple, un client peut avoir commencé à envoyer une nouvelle demande
en même temps que le serveur a décidé de fermer le "idle"
connexion. Du point de vue du serveur, la connexion est en cours
fermé alors qu'il était inactif, mais du point de vue du client, un
la demande est en cours.

Cela signifie que les clients, les serveurs et les proxys DOIVENT pouvoir récupérer
à partir d’événements de fermeture asynchrones. Le logiciel client DEVRAIT rouvrir le
connexion de transport et retransmettre la séquence de requêtes interrompue
sans interaction de l'utilisateur tant que la séquence de requêtes est
idempotent (voir section 9.1.2). Méthodes ou séquences non idempotentes
NE DOIT PAS être réessayé automatiquement, bien que les agents utilisateurs PEUVENT proposer un
opérateur humain le choix de réessayer la ou les requêtes. Confirmation par
logiciel agent utilisateur avec compréhension sémantique de l'application
PEUT remplacer la confirmation de l'utilisateur. La nouvelle tentative automatique NE DEVRAIT PAS
être répété si la deuxième séquence de requêtes échoue.

Les serveurs DEVRAIENT toujours répondre à au moins une requête par connexion,
Si tout est possible. Les serveurs NE DEVRAIENT PAS fermer une connexion dans le
milieu de transmission d'une réponse, sauf en cas de panne du réseau ou du client
est suspecté.

Les clients qui utilisent des connexions persistantes DEVRAIENT limiter le nombre de
connexions simultanées qu'ils maintiennent à un serveur donné. UN
le client mono-utilisateur NE DEVRAIT PAS maintenir plus de 2 connexions avec
n’importe quel serveur ou proxy. Un proxy DEVRAIT utiliser jusqu'à 2*N connexions pour
un autre serveur ou proxy, où N est le nombre de connexions simultanées
utilisateurs actifs. Ces directives visent à améliorer la réponse HTTP
horaires et éviter les embouteillages.

8.2 Exigences de transmission des messages

8.2.1 Connexions persistantes et contrôle de flux

Les serveurs HTTP/1.1 DEVRAIENT maintenir des connexions persistantes et utiliser TCP
mécanismes de contrôle de flux pour résoudre les surcharges temporaires, plutôt que
mettre fin aux connexions en espérant que les clients réessayeront.
Cette dernière technique peut exacerber la congestion du réseau.





Fielding et coll. Voie des normes [Page 47]
 
RFC 2616 HTTP/1.1 juin 1999


8.2.2 Surveillance des connexions pour les messages d'état d'erreur

Un client HTTP/1.1 (ou version ultérieure) envoyant un corps de message DEVRAIT surveiller
la connexion réseau pour un état d'erreur pendant la transmission
la demande. Si le client voit un statut d'erreur, il DEVRAIT
cessez immédiatement de transmettre le corps. Si le corps est envoyé
en utilisant un codage « fragmenté » (section 3.6), un fragment de longueur nulle et
une bande-annonce vide PEUT être utilisée pour marquer prématurément la fin du message.
Si le corps était précédé d'un en-tête Content-Length, le client DOIT
fermez la connexion.

8.2.3 Utilisation du statut 100 (Continuer)

L'objectif du statut 100 (Continuer) (voir section 10.1.1) est de
autoriser un client qui envoie un message de requête avec un corps de requête
pour déterminer si le serveur d'origine est prêt à accepter la demande
(en fonction des en-têtes de requête) avant que le client n'envoie la requête
corps. Dans certains cas, cela peut être inapproprié ou hautement
inefficace pour le client d'envoyer le corps si le serveur le rejette
le message sans regarder le corps.

Exigences pour les clients HTTP/1.1 :

- Si un client attend une réponse 100 (Continuer) avant
en envoyant le corps de la requête, il DOIT envoyer un en-tête de requête Expect
champ (section 14.20) avec l'attente « 100-continuer ».

- Un client NE DOIT PAS envoyer de champ d'en-tête de requête Expect (section
14.20) avec l'attente "100-continue" s'il n'a pas l'intention
pour envoyer un corps de requête.

En raison de la présence d'implémentations plus anciennes, le protocole permet
situations ambiguës dans lesquelles un client peut envoyer « Attendez : 100-
continuer" sans recevoir un statut 417 (Échec de l'attente)
ou un statut 100 (Continuer). Par conséquent, lorsqu'un client envoie ceci
champ d'en-tête vers un serveur d'origine (éventuellement via un proxy) à partir duquel il
n'a jamais vu un statut 100 (Continuer), le client NE DEVRAIT PAS attendre
pour une durée indéterminée avant l'envoi du corps de requête.

Exigences pour les serveurs d'origine HTTP/1.1 :

- À la réception d'une requête qui inclut un en-tête de requête Expect
champ avec l'attente "100-continue", un serveur d'origine DOIT
soit répondre avec le statut 100 (Continuer) et continuer à lire
à partir du flux d’entrée, ou répondez avec un code d’état final. Le
le serveur d'origine NE DOIT PAS attendre le corps de la requête avant de l'envoyer
la réponse 100 (Continuer). S'il répond avec un statut final
code, il PEUT fermer la connexion de transport ou il PEUT continuer



Fielding et coll. Voie des normes [Page 48]
 
RFC 2616 HTTP/1.1 juin 1999


pour lire et ignorer le reste de la demande. Il NE DOIT PAS
exécutez la méthode demandée si elle renvoie un code d’état final.

- Un serveur d'origine NE DEVRAIT PAS envoyer de réponse 100 (Continuer) si
le message de demande n'inclut pas d'en-tête de demande Expect
champ avec l'attente "100-continue", et NE DOIT PAS envoyer de message
Réponse 100 (Continuer) si une telle requête provient d'un HTTP/1.0
(ou antérieur) client. Il existe une exception à cette règle : pour
compatibilité avec RFC 2068, un serveur PEUT envoyer un 100 (Continuer)
statut en réponse à une requête HTTP/1.1 PUT ou POST qui ne
n'inclut pas de champ d'en-tête de requête Expect avec le "100-
"continuer". Cette exception, dont le but est
minimiser les retards de traitement des clients associés à un
attente non déclarée du statut 100 (Continuer), s'applique uniquement aux
requêtes HTTP/1.1, et non aux requêtes avec d'autres requêtes HTTP-
valeur de version.

- Un serveur d'origine PEUT omettre une réponse 100 (Continuer) s'il a
déjà reçu une partie ou la totalité du corps de la demande pour le
demande correspondante.

- Un serveur d'origine qui envoie une réponse 100 (Continuer) DOIT
finalement envoyer un code d'état final, une fois le corps de la demande
reçu et traité, sauf s'il met fin au transport
connexion prématurément.

- Si un serveur d'origine reçoit une requête qui n'inclut pas de
Attendez-vous à un champ d'en-tête de requête avec l'attente "100-continue",
la requête comprend un corps de requête et le serveur répond
avec un code d'état final avant de lire l'intégralité du corps de la requête
de la connexion de transport, alors le serveur NE DEVRAIT PAS fermer
la liaison de transport jusqu'à ce qu'elle ait lu l'intégralité de la demande,
ou jusqu'à ce que le client ferme la connexion. Sinon, le client
il se peut que le message de réponse ne soit pas reçu de manière fiable. Cependant, ceci
Cette exigence ne doit pas être interprétée comme empêchant un serveur de
se défendre contre les attaques par déni de service, ou contre
implémentations client gravement cassées.

Exigences pour les proxys HTTP/1.1 :

- Si un proxy reçoit une demande qui inclut une demande Expect-
champ d'en-tête avec l'attente "100-continue" et le proxy
soit sait que le serveur du tronçon suivant est conforme à HTTP/1.1, soit
supérieur, ou ne connaît pas la version HTTP du prochain saut
serveur, il DOIT transmettre la demande, y compris l'en-tête Expect
champ.





Fielding et coll. Voie des normes [Page 49]
 
RFC 2616 HTTP/1.1 juin 1999


- Si le proxy sait que la version du serveur du prochain saut est
HTTP/1.0 ou version inférieure, il NE DOIT PAS transmettre la demande, et il DOIT
répondez avec un statut 417 (Échec de l'attente).

- Les proxys DEVRAIENT maintenir un cache enregistrant la version HTTP
numéros reçus des serveurs de saut suivant récemment référencés.

- Un proxy NE DOIT PAS transmettre une réponse 100 (Continuer) si le
le message de demande a été reçu d'un HTTP/1.0 (ou version antérieure)
client et n'incluait pas de champ d'en-tête de requête Expect avec
l'attente "100-continuer". Cette exigence prévaut sur
règle générale pour la transmission des réponses 1xx (voir section 10.1).

8.2.4 Comportement du client si le serveur ferme prématurément la connexion

Si un client HTTP/1.1 envoie une requête qui inclut un corps de requête,
mais qui n'inclut pas de champ d'en-tête de requête Expect avec le
Attente "100-continuer", et si le client n'est pas directement
connecté à un serveur d'origine HTTP/1.1, et si le client voit le
connexion fermée avant de recevoir un statut du serveur, le
le client DEVRAIT réessayer la demande. Si le client réessaye
demande, il PEUT utiliser le "backoff exponentiel binaire" suivant
algorithme pour être assuré d’obtenir une réponse fiable :

1. Initiez une nouvelle connexion au serveur

2. Transmettre les en-têtes de requête

3. Initialisez une variable R au temps aller-retour estimé vers le
serveur (par exemple, en fonction du temps nécessaire à l'établissement du
connexion), ou à une valeur constante de 5 secondes si l'arrondi
le temps de trajet n'est pas disponible.

4. Calculez T = R * (2**N), où N est le nombre de précédents
nouvelles tentatives de cette demande.

5. Attendez soit une réponse d'erreur du serveur, soit T
secondes (selon la première éventualité)

6. Si aucune réponse d'erreur n'est reçue, après T secondes, transmettez le
corps de la demande.

7. Si le client constate que la connexion est fermée prématurément,
répéter à partir de l'étape 1 jusqu'à ce que la demande soit acceptée, une erreur
une réponse est reçue, ou l'utilisateur devient impatient et
termine le processus de nouvelle tentative.





Fielding et coll. Voie des normes [Page 50]
 
RFC 2616 HTTP/1.1 juin 1999


Si à un moment donné un état d'erreur est reçu, le client

- NE DEVRAIT PAS continuer et

- DEVRAIT fermer la connexion s'il n'a pas terminé l'envoi du
message de demande.

9 Définitions des méthodes

L'ensemble des méthodes courantes pour HTTP/1.1 est défini ci-dessous. Bien que
cet ensemble peut être étendu, on ne peut pas supposer que des méthodes supplémentaires
partagent la même sémantique pour les clients et les serveurs étendus séparément.

Le champ d'en-tête de demande d'hôte (section 14.23) DOIT accompagner tous
Requêtes HTTP/1.1.

9.1 Méthodes sûres et idempotentes

9.1.1 Méthodes sûres

Les développeurs doivent être conscients que le logiciel représente l'utilisateur dans
leurs interactions sur Internet et doivent veiller à permettre
l'utilisateur d'être conscient de toutes les actions qu'il pourrait entreprendre et qui pourraient avoir un impact
signification inattendue pour eux-mêmes ou pour les autres.

En particulier, il a été établi une convention selon laquelle l'EEG et
Les méthodes HEAD NE DEVRAIENT PAS avoir l’importance d’entreprendre une action
autre que la récupération. Ces méthodes doivent être considérées comme « sûres ».
Cela permet aux agents utilisateurs de représenter d'autres méthodes, telles que POST, PUT
et SUPPRIMER, de manière particulière, afin que l'utilisateur soit informé du
fait qu'une action potentiellement dangereuse est demandée.

Bien entendu, il n'est pas possible de garantir que le serveur ne
générer des effets secondaires suite à l'exécution d'une requête GET ; dans
en fait, certaines ressources dynamiques considèrent cela comme une fonctionnalité. L'important
la distinction ici est que l'utilisateur n'a pas demandé les effets secondaires,
nous ne pouvons donc en être tenus responsables.

9.1.2 Méthodes idempotentes

Les méthodes peuvent aussi avoir la propriété d'« idempotence » dans la mesure où (mis à part
provenant d'erreurs ou de problèmes d'expiration) les effets secondaires de N > 0 sont identiques
requêtes est la même que pour une requête unique. Les méthodes GET, HEAD,
PUT et DELETE partagent cette propriété. Aussi, les méthodes OPTIONS et
TRACE NE DEVRAIT PAS avoir d’effets secondaires et est donc intrinsèquement idempotent.






Fielding et coll. Voie des normes [Page 51]
 
RFC 2616 HTTP/1.1 juin 1999


Il est cependant possible qu'une séquence de plusieurs requêtes ne soit pas
idempotent, même si toutes les méthodes exécutées dans cette séquence sont
idempotent. (Une séquence est idempotente si une seule exécution du
la séquence entière donne toujours un résultat qui n'est pas modifié par un
réexécution de tout ou partie de cette séquence.) Par exemple, un
une séquence est non idempotente si son résultat dépend d’une valeur qui est
modifié plus tard dans le même ordre.

Une séquence qui n’a jamais d’effets secondaires est idempotente, par définition
(à condition qu'aucune opération simultanée ne soit exécutée sur le
même ensemble de ressources).

9.2 OPTIONS

La méthode OPTIONS représente une demande d'informations sur le
options de communication disponibles sur la chaîne de demande/réponse
identifié par le Request-URI. Cette méthode permet au client de
déterminer les options et/ou exigences associées à une ressource,
ou les capacités d'un serveur, sans impliquer une action de ressource
ou lancer une récupération de ressources.

Les réponses à cette méthode ne peuvent pas être mises en cache.

Si la demande OPTIONS inclut une entité-organisme (comme indiqué par le
présence de Content-Length ou Transfer-Encoding), puis le type de média
DOIT être indiqué par un champ Content-Type. Bien que cela
la spécification ne définit aucune utilisation pour un tel corps, futur
les extensions à HTTP peuvent utiliser le corps OPTIONS pour rendre plus détaillé
requêtes sur le serveur. Un serveur qui ne prend pas en charge un tel
l’extension PEUT rejeter le corps de la demande.

Si le Request-URI est un astérisque ("*"), la requête OPTIONS est
destiné à s'appliquer au serveur en général plutôt qu'à un domaine spécifique
Ressource. Étant donné que les options de communication d'un serveur dépendent généralement de
la ressource, la requête "*" n'est utile que comme "ping" ou "no-op"
type de méthode ; cela ne fait rien d'autre que de permettre au client de tester
les capacités du serveur. Par exemple, cela peut être utilisé pour tester
un proxy pour la conformité HTTP/1.1 (ou son absence).

Si le Request-URI n'est pas un astérisque, la requête OPTIONS s'applique
uniquement aux options disponibles lors de la communication avec ce
Ressource.

Une réponse 200 DEVRAIT inclure tous les champs d'en-tête qui indiquent
fonctionnalités facultatives implémentées par le serveur et applicables à celui-ci
ressource (par exemple, Autoriser), incluant éventuellement des extensions non définies par
cette spécification. Le corps de la réponse, le cas échéant, DEVRAIT également inclure
informations sur les options de communication. Le format d'un tel



Fielding et coll. Voie des normes [Page 52]
 
RFC 2616 HTTP/1.1 juin 1999


body n'est pas défini par cette spécification, mais pourrait l'être par
futures extensions du HTTP. La négociation de contenu PEUT être utilisée pour sélectionner
le format de réponse approprié. Si aucun corps de réponse n'est inclus, le
la réponse DOIT inclure un champ Content-Length avec une valeur de champ de
"0".

Le champ d'en-tête de requête Max-Forwards PEUT être utilisé pour cibler un
proxy spécifique dans la chaîne de requête. Lorsqu'un mandataire reçoit une OPTIONS
requête sur un URI absolu pour lequel le transfert de requête est autorisé,
le mandataire DOIT vérifier un champ Max-Forwards. Si le Max-Forwards
la valeur du champ est zéro ("0"), le mandataire NE DOIT PAS transmettre le message ;
à la place, le mandataire DEVRAIT répondre avec ses propres options de communication.
Si la valeur du champ Max-Forwards est un entier supérieur à zéro, le
le proxy DOIT décrémenter la valeur du champ lorsqu'il transmet la demande. Si
aucun champ Max-Forwards n'est présent dans la requête, alors le transfert
la demande NE DOIT PAS inclure de champ Max-Forwards.

9.3 OBTENIR

La méthode GET consiste à récupérer n'importe quelle information (sous la forme d'un
entité) est identifiée par le Request-URI. Si le Request-URI fait référence
à un processus de production de données, ce sont les données produites qui doivent être
renvoyé en tant qu'entité dans la réponse et non en tant que texte source du
processus, à moins que ce texte ne soit le résultat du processus.

La sémantique de la méthode GET se transforme en "GET conditionnel" si le
Le message de demande inclut un If-Modified-Since, If-Unmodified-Since,
Champ d’en-tête If-Match, If-None-Match ou If-Range. Un GET conditionnel
méthode demande que l’entité soit transférée uniquement sous le régime
circonstances décrites par le(s) champ(s) d’en-tête conditionnel. Le
La méthode GET conditionnelle est destinée à réduire les réseaux inutiles
utilisation en permettant aux entités mises en cache d'être actualisées sans nécessiter
demandes multiples ou transfert de données déjà détenues par le client.

La sémantique de la méthode GET se transforme en "GET partiel" si le
Le message de demande inclut un champ d’en-tête Range. Une requête GET partielle
que seule une partie de l'entité soit transférée, comme décrit à la section
14h35. La méthode GET partielle est destinée à réduire les
l'utilisation du réseau en permettant aux entités partiellement récupérées d'être
réalisé sans transférer les données déjà détenues par le client.

La réponse à une requête GET peut être mise en cache si et seulement si elle répond
les exigences de mise en cache HTTP décrites à la section 13.

Voir la section 15.1.3 pour les considérations de sécurité lors de l'utilisation de formulaires.






Fielding et coll. Voie des normes [Page 53]
 
RFC 2616 HTTP/1.1 juin 1999


9.4 TÊTE

La méthode HEAD est identique à GET sauf que le serveur NE DOIT PAS
renvoie un corps de message dans la réponse. Les métainformations contenues
dans les en-têtes HTTP en réponse à une requête HEAD DEVRAIT être identique
aux informations envoyées en réponse à une requête GET. Cette méthode peut
être utilisé pour obtenir des métainformations sur l'entité impliquée par le
demande sans transférer l’entité-organisme elle-même. Cette méthode est
souvent utilisé pour tester les liens hypertextes en termes de validité, d'accessibilité,
et modification récente.

La réponse à une requête HEAD PEUT être mise en cache dans le sens où le
les informations contenues dans la réponse PEUVENT être utilisées pour mettre à jour un
entité précédemment mise en cache à partir de cette ressource. Si les nouvelles valeurs du champ
indiquer que l'entité mise en cache diffère de l'entité actuelle (comme
serait indiqué par un changement dans Content-Length, Content-MD5, ETag
ou Last-Modified), alors le cache DOIT traiter l'entrée du cache comme
vicié.

9.5 PUBLIER

La méthode POST est utilisée pour demander au serveur d'origine d'accepter le
entité incluse dans la demande en tant que nouveau subordonné de la ressource
identifié par le Request-URI dans la Request-Line. POST est conçu
pour permettre une méthode uniforme pour couvrir les fonctions suivantes :

- Annotation des ressources existantes ;

- Publication d'un message sur un babillard, un groupe de discussion, une liste de diffusion,
ou groupe d'articles similaire ;

- Fournir un bloc de données, tel que le résultat de la soumission d'un
formulaire, à un processus de traitement de données ;

- Extension d'une base de données via une opération d'ajout.

La fonction réelle exécutée par la méthode POST est déterminée par le
serveur et dépend généralement du Request-URI. L'entité publiée
est subordonné à cet URI de la même manière qu'un fichier est subordonné
à un répertoire le contenant, un article d'actualité est subordonné à un
groupe de discussion sur lequel il est publié, ou un enregistrement est subordonné à un
base de données.

L'action effectuée par la méthode POST peut ne pas entraîner de message
ressource qui peut être identifiée par un URI. Dans ce cas, soit 200
(OK) ou 204 (Pas de contenu) est le statut de réponse approprié,
selon que la réponse inclut ou non une entité qui
décrit le résultat.



Fielding et coll. Voie des normes [Page 54]
 
RFC 2616 HTTP/1.1 juin 1999


Si une ressource a été créée sur le serveur d'origine, la réponse
DEVRAIT être 201 (Créé) et contenir une entité qui décrit le
statut de la demande et fait référence à la nouvelle ressource, et un Emplacement
en-tête (voir section 14.30).

Les réponses à cette méthode ne peuvent pas être mises en cache, sauf si la réponse
inclut les champs d’en-tête Cache-Control ou Expires appropriés. Cependant,
la réponse 303 (Voir Autre) peut être utilisée pour diriger l'agent utilisateur vers
récupérer une ressource pouvant être mise en cache.

Les requêtes POST DOIVENT obéir aux exigences de transmission de messages énoncées
à la section 8.2.

Voir la section 15.1.3 pour les considérations de sécurité.

9.6 METTRE

La méthode PUT demande que l'entité incluse soit stockée sous le
fourni l'URI de requête. Si le Request-URI fait référence à un déjà
ressource existante, l'entité incluse DEVRAIT être considérée comme une
version modifiée de celle résidant sur le serveur d'origine. Si la
Request-URI ne pointe pas vers une ressource existante et cet URI est
susceptible d'être défini comme une nouvelle ressource par l'utilisateur demandeur
agent, le serveur d'origine peut créer la ressource avec cet URI. Si un
nouvelle ressource est créée, le serveur d'origine DOIT informer l'agent utilisateur
via la réponse 201 (Créé). Si une ressource existante est modifiée,
soit les codes de réponse 200 (OK) ou 204 (Pas de contenu) DEVRAIENT être envoyés
pour indiquer que la demande a été complétée avec succès. Si la ressource
n'a pas pu être créé ou modifié avec le Request-URI, un
une réponse d'erreur DEVRAIT être donnée qui reflète la nature du
problème. Le destinataire de l'entité NE DOIT PAS ignorer aucun contenu-*
(par exemple Content-Range) les en-têtes qu'il ne comprend pas ou n'implémente pas
et DOIT renvoyer une réponse 501 (Non implémenté) dans de tels cas.

Si la requête passe par un cache et que le Request-URI identifie
une ou plusieurs entités actuellement mises en cache, ces entrées DEVRAIENT être
traité comme périmé. Les réponses à cette méthode ne peuvent pas être mises en cache.

La différence fondamentale entre les requêtes POST et PUT est
reflété dans la signification différente du Request-URI. L'URI dans un
La requête POST identifie la ressource qui gérera le fichier ci-joint
entité. Cette ressource pourrait être un processus d'acceptation de données, une passerelle vers
un autre protocole ou une entité distincte qui accepte les annotations.
En revanche, l'URI dans une requête PUT identifie l'entité incluse
avec la requête -- l'agent utilisateur sait quel URI est prévu et le
le serveur NE DOIT PAS tenter d'appliquer la demande à une autre ressource.
Si le serveur souhaite que la requête soit appliquée à un URI différent,




Fielding et coll. Voie des normes [Page 55]
 
RFC 2616 HTTP/1.1 juin 1999


il DOIT envoyer une réponse 301 (Déplacé de façon permanente) ; l'agent utilisateur PEUT
puis prendre sa propre décision quant à savoir s'il faut ou non rediriger le
demande.

Une seule ressource PEUT être identifiée par de nombreux URI différents. Pour
Par exemple, un article peut avoir un URI pour identifier "le courant
version" qui est distinct de l'URI identifiant chaque
version. Dans ce cas, une requête PUT sur un URI général peut entraîner
plusieurs autres URI étant définis par le serveur d'origine.

HTTP/1.1 ne définit pas comment une méthode PUT affecte l'état d'un
serveur d'origine.

Les requêtes PUT DOIVENT obéir aux exigences de transmission de messages énoncées
à la section 8.2.

Sauf indication contraire pour un en-tête d'entité particulier, le
les en-têtes d'entité dans la requête PUT DEVRAIENT être appliqués à la ressource
créé ou modifié par le PUT.

9.7 SUPPRIMER

La méthode DELETE demande au serveur d'origine de supprimer la ressource
identifié par le Request-URI. Cette méthode PEUT être remplacée par des humains
intervention (ou autre moyen) sur le serveur d'origine. Le client ne peut pas
avoir la garantie que l'opération a été effectuée, même si le
Le code d'état renvoyé par le serveur d'origine indique que l'action
a été complété avec succès. Cependant, le serveur NE DEVRAIT PAS
indiquer un succès à moins que, au moment où la réponse est donnée, elle
a l'intention de supprimer la ressource ou de la déplacer vers un endroit inaccessible
emplacement.

Une réponse réussie DEVRAIT être 200 (OK) si la réponse inclut un
entité décrivant le statut, 202 (Accepté) si l'action n'a pas
n'a pas encore été adoptée, ou 204 (Pas de contenu) si l'action a été adoptée
mais la réponse n'inclut pas d'entité.

Si la requête passe par un cache et que le Request-URI identifie
une ou plusieurs entités actuellement mises en cache, ces entrées DEVRAIENT être
traité comme périmé. Les réponses à cette méthode ne peuvent pas être mises en cache.

9.8 TRAÇAGE

La méthode TRACE est utilisée pour invoquer une boucle distante de couche application.
au dos du message de demande. Le destinataire final de la demande
DEVRAIT refléter le message reçu en retour au client comme le
corps d'entité d'une réponse 200 (OK). Le destinataire final est soit le




Fielding et coll. Voie des normes [Page 56]
 
RFC 2616 HTTP/1.1 juin 1999


serveur d'origine ou le premier proxy ou passerelle à recevoir un Max-Forwards
valeur de zéro (0) dans la demande (voir section 14.31). Une demande TRACE
NE DOIT PAS inclure une entité.

TRACE permet au client de voir ce qui est reçu à l'autre
fin de la chaîne de requête et utiliser ces données à des fins de test ou de diagnostic
information. La valeur du champ d'en-tête Via (section 14.45) est de
intérêt particulier, puisqu’il agit comme une trace de la chaîne des requêtes.
L'utilisation du champ d'en-tête Max-Forwards permet au client de limiter le
longueur de la chaîne de requêtes, ce qui est utile pour tester une chaîne de
les proxys transmettent les messages dans une boucle infinie.

Si la demande est valide, la réponse DEVRAIT contenir l'intégralité de
message de requête dans le corps de l'entité, avec un type de contenu de
"message/http". Les réponses à cette méthode NE DOIVENT PAS être mises en cache.

9.9 CONNEXION

Cette spécification réserve le nom de méthode CONNECT pour une utilisation avec un
proxy qui peut dynamiquement passer au statut de tunnel (par exemple SSL
tunneling [44]).

10 définitions des codes d'état

Chaque code de statut est décrit ci-dessous, y compris une description de celui-ci.
méthode(s) qu'il peut suivre et toute métainformation requise dans le
réponse.

10.1 Informations 1xx

Cette classe de code d'état indique une réponse provisoire,
composé uniquement de la Status-Line et des en-têtes facultatifs, et est
terminé par une ligne vide. Il n'y a pas d'en-têtes requis pour cela
classe de code d’état. Puisque HTTP/1.0 n'a défini aucun statut 1xx
codes, les serveurs NE DOIVENT PAS envoyer de réponse 1xx à un client HTTP/1.0
sauf dans des conditions expérimentales.

Un client DOIT être prêt à accepter une ou plusieurs réponses de statut 1xx
avant une réponse régulière, même si le client ne s'attend pas à un 100
(Continuer) message d'état. Des réponses d'état 1xx inattendues PEUVENT être
ignoré par un agent utilisateur.

Les proxys DOIVENT transmettre les réponses 1xx, à moins que la connexion entre le
le mandataire et son client ont été fermés, ou à moins que le mandataire lui-même
a demandé la génération de la réponse 1xx. (Par exemple, si un






Fielding et coll. Voie des normes [Page 57]
 
RFC 2616 HTTP/1.1 juin 1999


le proxy ajoute un champ "Attendez : 100-continue" lorsqu'il transmet une requête,
alors il n'est pas nécessaire de transmettre les 100 correspondants (Continuer)
réponse(s).)

10.1.1 100 Continuer

Le client DEVRAIT poursuivre sa demande. Cette réponse provisoire est
utilisé pour informer le client que la partie initiale de la demande a été
a été reçu et n'a pas encore été rejeté par le serveur. Le client
DEVRAIT continuer en envoyant le reste de la demande ou, si le
la demande a déjà été complétée, ignorez cette réponse. Le serveur
DOIT envoyer une réponse finale une fois la demande terminée. Voir
section 8.2.3 pour une discussion détaillée de l'utilisation et de la manipulation de ce
code d'état.

10.1.2 101 protocoles de commutation

Le serveur comprend et est disposé à se conformer aux exigences du client.
demande, via le champ d'en-tête du message Upgrade (section 14.42), d'un
changement dans le protocole d’application utilisé sur cette connexion. Le
le serveur basculera les protocoles vers ceux définis par la réponse
Champ d'en-tête de mise à niveau immédiatement après la ligne vide qui
termine la réponse 101.

Le protocole DEVRAIT être commuté uniquement lorsqu'il est avantageux de le faire
donc. Par exemple, passer à une version plus récente de HTTP est avantageux
par rapport aux anciennes versions et en passant à un système synchrone en temps réel
le protocole peut être avantageux lors de la fourniture de ressources qui utilisent
de telles fonctionnalités.

10.2 2xx réussi

Cette classe de code d'état indique que la demande du client a été
reçu, compris et accepté avec succès.

10.2.1 200 OK

La demande a abouti. Les informations renvoyées avec la réponse
dépend de la méthode utilisée dans la requête, par exemple :

GET une entité correspondant à la ressource demandée est envoyée
la réponse;

HEAD les champs d'en-tête d'entité correspondant à l'entité demandée
les ressources sont envoyées dans la réponse sans aucun corps de message ;

POST une entité décrivant ou contenant le résultat de l'action ;




Fielding et coll. Voie des normes [Page 58]
 
RFC 2616 HTTP/1.1 juin 1999


TRACE une entité contenant le message de requête tel que reçu par le
serveur final.

10.2.2 201 Créé

La demande a été satisfaite et a donné lieu à la création d'une nouvelle ressource.
créé. La ressource nouvellement créée peut être référencée par le ou les URI
renvoyé dans l'entité de la réponse, avec l'URI le plus précis
pour la ressource donnée par un champ d'en-tête Location. La réponse
DEVRAIT inclure une entité contenant une liste de ressources
caractéristiques et emplacement(s) à partir desquels l'utilisateur ou l'agent utilisateur peut
choisissez celui qui convient le mieux. Le format de l'entité est spécifié par
le type de média indiqué dans le champ d’en-tête Content-Type. L'origine
le serveur DOIT créer la ressource avant de renvoyer le code d'état 201.
Si l'action ne peut pas être exécutée immédiatement, le serveur DEVRAIT
répondez plutôt par la réponse 202 (Accepté).

Une réponse 201 PEUT contenir un champ d'en-tête de réponse ETag indiquant
la valeur actuelle de la balise d'entité pour la variante demandée
créé, voir la section 14.19.

10.2.3 202 Accepté

La demande a été acceptée pour traitement, mais le traitement a
pas été achevé. La demande pourrait éventuellement être ou non
donné suite, car il pourrait être refusé lorsque le traitement prend réellement
lieu. Il n'existe aucune possibilité de renvoyer un code d'état à partir d'un
opération asynchrone comme celle-ci.

La réponse du 202 est intentionnellement sans engagement. Son but est de
permettre à un serveur d'accepter une demande pour un autre processus (peut-être un
processus orienté batch qui n'est exécuté qu'une fois par jour) sans
exigeant que la connexion de l'agent utilisateur au serveur persiste
jusqu'à ce que le processus soit terminé. L'entité est revenue avec ceci
la réponse DEVRAIT inclure une indication de l'état actuel de la demande
et soit un pointeur vers un moniteur d'état, soit une estimation du moment où le
l'utilisateur peut s'attendre à ce que la demande soit satisfaite.

10.2.4 203 Informations ne faisant pas autorité

Les métainformations renvoyées dans l'en-tête d'entité ne sont pas les
défini comme disponible sur le serveur d'origine, mais est collecté
à partir d’une copie locale ou tierce. L'ensemble présenté PEUT être un sous-ensemble
ou un surensemble de la version originale. Par exemple, y compris les locaux
les informations d'annotation sur la ressource peuvent entraîner un surensemble
des métainformations connues par le serveur d'origine. Utilisation de ceci
Le code de réponse n'est pas requis et n'est approprié que lorsque le
la réponse serait autrement 200 (OK).



Fielding et coll. Voie des normes [Page 59]
 
RFC 2616 HTTP/1.1 juin 1999


10.2.5 204 Aucun contenu

Le serveur a répondu à la demande mais n'a pas besoin de renvoyer de message.
corps d'entité et souhaitera peut-être renvoyer des métainformations mises à jour. Le
la réponse PEUT inclure des métainformations nouvelles ou mises à jour sous la forme de
les en-têtes d'entité, qui, s'ils sont présents, DEVRAIENT être associés au
variante demandée.

Si le client est un agent utilisateur, il NE DEVRAIT PAS changer la vue du document
de celui qui a donné lieu à l'envoi de la demande. Cette réponse est
principalement destiné à permettre la saisie d'actions devant avoir lieu sans
provoquant une modification de la vue active du document de l'agent utilisateur, bien que
toute métainformation nouvelle ou mise à jour DEVRAIT être appliquée au document
actuellement dans la vue active de l'agent utilisateur.

La réponse 204 NE DOIT PAS inclure de corps de message et est donc toujours
terminé par la première ligne vide après les champs d'en-tête.

10.2.6 205 Réinitialiser le contenu

Le serveur a répondu à la demande et l'agent utilisateur DEVRAIT réinitialiser
la vue du document qui a provoqué l'envoi de la demande. Cette réponse
est principalement destiné à permettre la saisie d'actions à effectuer via
saisie de l'utilisateur, suivie d'un effacement du formulaire dans lequel la saisie est
donné afin que l'utilisateur puisse facilement lancer une autre action de saisie. Le
la réponse NE DOIT PAS inclure une entité.

10.2.7 206 Contenu partiel

Le serveur a répondu à la requête GET partielle pour la ressource.
La demande DOIT avoir inclus un champ d'en-tête Range (section 14.35)
indiquant la plage souhaitée, et PEUT avoir inclus un If-Range
champ d’en-tête (section 14.27) pour rendre la demande conditionnelle.

La réponse DOIT inclure les champs d'en-tête suivants :

- Soit un champ d'en-tête Content-Range (section 14.16) indiquant
la plage incluse avec cette réponse, ou un multipart/byteranges
Content-Type comprenant les champs Content-Range pour chaque partie. Si un
Le champ d'en-tête Content-Length est présent dans la réponse, son
La valeur DOIT correspondre au nombre réel d'OCTET transmis dans le
Corps du message.

- Date

- ETag et/ou Content-Location, si l'en-tête aurait été envoyé
dans une réponse 200 à la même demande




Fielding et coll. Voie des normes [Page 60]
 
RFC 2616 HTTP/1.1 juin 1999


- Expire, Cache-Control et/ou Vary, si la valeur du champ peut
différent de celui envoyé dans toute réponse précédente pour le même
une variante

Si la réponse 206 est le résultat d'une requête If-Range qui a utilisé un
validateur de cache fort (voir section 13.3.3), la réponse NE DEVRAIT PAS
inclure d’autres en-têtes d’entité. Si la réponse est le résultat d'une
Requête If-Range qui utilisait un validateur faible, la réponse NE DOIT PAS
inclure d'autres en-têtes d'entité ; cela évite les incohérences entre
Corps d'entité mis en cache et en-têtes mis à jour. Sinon, la réponse
DOIT inclure tous les en-têtes d'entité qui auraient été renvoyés
avec une réponse 200 (OK) à la même demande.

Un cache NE DOIT PAS combiner une réponse 206 avec d'autres réponses précédemment mises en cache
contenu si les en-têtes ETag ou Last-Modified ne correspondent pas exactement,
voir 13.5.4.

Un cache qui ne prend pas en charge les en-têtes Range et Content-Range
NE DOIT PAS mettre en cache les réponses 206 (partielles).

10.3 Redirection 3xx

Cette classe de code d'état indique qu'une action supplémentaire doit être
prises par l'agent utilisateur afin de répondre à la demande. L'action
requis PEUT être effectué par l'agent utilisateur sans interaction
avec l'utilisateur si et seulement si la méthode utilisée dans la deuxième requête est
OBTENIR ou HEAD. Un client DEVRAIT détecter des boucles de redirection infinies, puisque
ces boucles génèrent du trafic réseau pour chaque redirection.

Remarque : les versions précédentes de cette spécification recommandaient un
maximum de cinq redirections. Les développeurs de contenu doivent être conscients
qu'il pourrait y avoir des clients qui implémentent un tel fixe
limitation.

10.3.1 300 choix multiples

La ressource demandée correspond à l'un quelconque d'un ensemble de
représentations, chacune avec son propre emplacement spécifique, et des agents-
des informations sur les négociations pilotées (section 12) sont fournies afin que
l'utilisateur (ou l'agent utilisateur) peut sélectionner une représentation préférée et
rediriger sa demande vers cet emplacement.

Sauf s'il s'agissait d'une requête HEAD, la réponse DEVRAIT inclure une entité
contenant une liste des caractéristiques des ressources et des emplacements de
lequel l'utilisateur ou l'agent utilisateur peut choisir celui le plus approprié. Le
Le format de l'entité est spécifié par le type de média indiqué dans le Content-
Saisissez le champ d’en-tête. En fonction du format et des capacités de




Fielding et coll. Voie des normes [Page 61]
 
RFC 2616 HTTP/1.1 juin 1999


l'agent utilisateur, la sélection du choix le plus approprié PEUT être
effectué automatiquement. Cependant, cette spécification ne définit pas
toute norme pour une telle sélection automatique.

Si le serveur a un choix préféré de représentation, il DEVRAIT
inclure l'URI spécifique pour cette représentation dans l'emplacement
champ; les agents utilisateurs PEUVENT utiliser la valeur du champ Emplacement pour
réorientation. Cette réponse peut être mise en cache, sauf indication contraire.

10.3.2 301 Déplacé de façon permanente

La ressource demandée s'est vu attribuer un nouvel URI permanent et tout
les références futures à cette ressource DEVRAIENT utiliser l'un des éléments renvoyés
URI. Les clients dotés de capacités d'édition de liens devraient automatiquement
relier les références au Request-URI à un ou plusieurs des nouveaux
références renvoyées par le serveur, lorsque cela est possible. Cette réponse est
pouvant être mis en cache, sauf indication contraire.

Le nouvel URI permanent DEVRAIT être donné par le champ Location dans le champ
réponse. Sauf si la méthode de requête était HEAD, l'entité du
la réponse DEVRAIT contenir une courte note hypertexte avec un lien hypertexte vers
le ou les nouveaux URI.

Si le code d'état 301 est reçu en réponse à une demande autre
que GET ou HEAD, l'agent utilisateur NE DOIT PAS rediriger automatiquement le
demande à moins qu'elle puisse être confirmée par l'utilisateur, car cela pourrait
modifier les conditions dans lesquelles la demande a été émise.

Remarque : lors de la redirection automatique d'une requête POST après
recevoir un code d'état 301, certains agents utilisateurs HTTP/1.0 existants
le changera par erreur en une requête GET.

10.3.3 302 trouvés

La ressource demandée réside temporairement sous un URI différent.
Puisque la redirection peut être modifiée à l'occasion, le client DEVRAIT
continuez à utiliser le Request-URI pour les demandes futures. Cette réponse
ne peut être mis en cache que si cela est indiqué par un en-tête Cache-Control ou Expires
champ.

L'URI temporaire DEVRAIT être donné par le champ Emplacement dans le champ
réponse. Sauf si la méthode de requête était HEAD, l'entité du
la réponse DEVRAIT contenir une courte note hypertexte avec un lien hypertexte vers
le ou les nouveaux URI.







Fielding et coll. Voie des normes [Page 62]
 
RFC 2616 HTTP/1.1 juin 1999


Si le code d'état 302 est reçu en réponse à une demande autre
que GET ou HEAD, l'agent utilisateur NE DOIT PAS rediriger automatiquement le
demande à moins qu'elle puisse être confirmée par l'utilisateur, car cela pourrait
modifier les conditions dans lesquelles la demande a été émise.

Remarque : les RFC 1945 et RFC 2068 précisent que le client n'est pas autorisé
pour changer la méthode sur la requête redirigée. Cependant, la plupart
les implémentations d'agent utilisateur existantes traitent 302 comme s'il s'agissait d'un 303
réponse, en effectuant un GET sur la valeur du champ Emplacement indépendamment
de la méthode de demande originale. Les codes d'état 303 et 307 ont
été ajouté pour les serveurs qui souhaitent indiquer clairement quel
type de réaction est attendu du client.

10.3.4 303 Voir Autres

La réponse à la demande peut être trouvée sous un autre URI et
DEVRAIT être récupéré en utilisant une méthode GET sur cette ressource. Cette méthode
existe principalement pour permettre la sortie d'un script activé par POST vers
rediriger l'agent utilisateur vers une ressource sélectionnée. Le nouvel URI n'est pas un
référence de remplacement pour la ressource initialement demandée. Le 303
la réponse NE DOIT PAS être mise en cache, mais la réponse à la seconde
La requête (redirigée) peut être mise en cache.

Les différents URI DEVRAIENT être donnés par le champ Location dans le champ
réponse. Sauf si la méthode de requête était HEAD, l'entité du
la réponse DEVRAIT contenir une courte note hypertexte avec un lien hypertexte vers
le ou les nouveaux URI.

Remarque : De nombreux agents utilisateurs antérieurs à HTTP/1.1 ne comprennent pas le code 303.
statut. Lorsque l'interopérabilité avec de tels clients constitue une préoccupation, le
Le code d'état 302 peut être utilisé à la place, car la plupart des agents utilisateurs réagissent
à une réponse 302 comme décrit ici pour 303.

10.3.5 304 Non modifié

Si le client a effectué une requête GET conditionnelle et que l'accès est
autorisé, mais que le document n'a pas été modifié, le serveur DEVRAIT
répondez avec ce code d’état. La réponse 304 NE DOIT PAS contenir un
corps du message, et est donc toujours terminé par la première ligne vide
après les champs d'en-tête.

La réponse DOIT inclure les champs d'en-tête suivants :

- Date, à moins que son omission soit requise par l'article 14.18.1







Fielding et coll. Voie des normes [Page 63]
 
RFC 2616 HTTP/1.1 juin 1999


Si un serveur d'origine sans horloge obéit à ces règles, et que les proxys et
les clients ajoutent leur propre date à toute réponse reçue sans une (comme
déjà spécifié par la [RFC 2068], section 14.19), les caches fonctionneront
correctement.

- ETag et/ou Content-Location, si l'en-tête aurait été envoyé
dans une réponse 200 à la même demande

- Expire, Cache-Control et/ou Vary, si la valeur du champ peut
différent de celui envoyé dans toute réponse précédente pour le même
une variante

Si le GET conditionnel utilisait un validateur de cache puissant (voir la section
13.3.3), la réponse NE DEVRAIT PAS inclure d'autres en-têtes d'entité.
Sinon (c'est-à-dire que le GET conditionnel utilisait un validateur faible), le
la réponse NE DOIT PAS inclure d'autres en-têtes d'entité ; cela empêche
incohérences entre les corps d'entité mis en cache et les en-têtes mis à jour.

Si une réponse 304 indique une entité non actuellement mise en cache, alors le
le cache DOIT ignorer la réponse et répéter la demande sans le
conditionnel.

Si un cache utilise une réponse 304 reçue pour mettre à jour une entrée de cache, le
le cache DOIT mettre à jour l'entrée pour refléter toute nouvelle valeur de champ donnée dans
la réponse.

10.3.6 305 Utiliser un proxy

La ressource demandée DOIT être accessible via le proxy donné par
le champ Emplacement. Le champ Location donne l'URI du proxy.
Le destinataire est censé répéter cette demande unique via le
Procuration. Les réponses 305 DOIVENT être générées uniquement par les serveurs d'origine.

Remarque : La RFC 2068 n'indiquait pas clairement que 305 était destiné à rediriger un
requête unique et à générer uniquement par les serveurs d'origine. Pas
le respect de ces limitations a des conséquences importantes en matière de sécurité.

10.3.7 306 (inutilisé)

Le code d'état 306 était utilisé dans une version précédente du
spécification, n’est plus utilisé et le code est réservé.










Fielding et coll. Voie des normes [Page 64]
 
RFC 2616 HTTP/1.1 juin 1999


10.3.8 307 Redirection temporaire

La ressource demandée réside temporairement sous un URI différent.
Puisque la redirection PEUT être modifiée à l'occasion, le client DEVRAIT
continuez à utiliser le Request-URI pour les demandes futures. Cette réponse
ne peut être mis en cache que si cela est indiqué par un en-tête Cache-Control ou Expires
champ.

L'URI temporaire DEVRAIT être donné par le champ Emplacement dans le champ
réponse. Sauf si la méthode de requête était HEAD, l'entité du
la réponse DEVRAIT contenir une courte note hypertexte avec un lien hypertexte vers
le ou les nouveaux URI, puisque de nombreux agents utilisateurs pré-HTTP/1.1 ne le font pas
comprendre le statut 307. Par conséquent, la note DEVRAIT contenir le
informations nécessaires à un utilisateur pour répéter la demande initiale sur
le nouvel URI.

Si le code d'état 307 est reçu en réponse à une demande autre
que GET ou HEAD, l'agent utilisateur NE DOIT PAS rediriger automatiquement le
demande à moins qu'elle puisse être confirmée par l'utilisateur, car cela pourrait
modifier les conditions dans lesquelles la demande a été émise.

10.4 Erreur client 4xx

La classe 4xx de code d'état est destinée aux cas dans lesquels le
le client semble s'être trompé. Sauf en réponse à une requête HEAD,
le serveur DEVRAIT inclure une entité contenant une explication du
situation d'erreur et s'il s'agit d'une situation temporaire ou permanente
condition. Ces codes d'état sont applicables à toute méthode de demande.
Les agents utilisateurs DEVRAIENT afficher toute entité incluse à l'utilisateur.

Si le client envoie des données, une implémentation de serveur utilisant TCP
DEVRAIT veiller à ce que le client accuse réception de
le(s) paquet(s) contenant la réponse, avant que le serveur ne ferme le
connexion d'entrée. Si le client continue d'envoyer des données au serveur
après la fermeture, la pile TCP du serveur enverra un paquet de réinitialisation à
le client, ce qui peut effacer les tampons d'entrée non reconnus du client
avant qu'ils puissent être lus et interprétés par l'application HTTP.

10.4.1 400 requêtes incorrectes

La requête n'a pas pu être comprise par le serveur en raison d'un message mal formé.
syntaxe. Le client NE DEVRAIT PAS répéter la demande sans
modifications.








Fielding et coll. Voie des normes [Page 65]
 
RFC 2616 HTTP/1.1 juin 1999


10.4.2 401 Non autorisé

La demande nécessite une authentification de l'utilisateur. La réponse DOIT inclure un
Champ d'en-tête WWW-Authenticate (section 14.47) contenant un défi
applicable à la ressource demandée. Le client PEUT répéter le
demande avec un champ d’en-tête Autorisation approprié (section 14.8). Si
la demande incluait déjà les informations d'identification d'autorisation, puis le 401
La réponse indique que l'autorisation a été refusée pour ceux
informations d'identification. Si la réponse 401 contient le même défi que le
réponse précédente, et l'agent utilisateur a déjà tenté
authentification au moins une fois, alors l'utilisateur DEVRAIT se voir présenter le
entité qui a été donnée dans la réponse, puisque cette entité pourrait
inclure des informations de diagnostic pertinentes. Authentification d'accès HTTP
est expliqué dans « Authentification HTTP : accès de base et Digest
Authentification" [43].

10.4.3 402 Paiement requis

Ce code est réservé pour une utilisation future.

10.4.4 403 Interdit

Le serveur a compris la demande, mais refuse d'y répondre.
L'autorisation n'aidera pas et la demande NE DEVRAIT PAS être répétée.
Si la méthode de requête n'était pas HEAD et que le serveur souhaite effectuer
public pourquoi la demande n'a pas été satisfaite, il DEVRAIT décrire le
motif du refus dans l'entité. Si le serveur ne souhaite pas
mettre ces informations à disposition du client, le code d'état 404
(Not Found) peut être utilisé à la place.

10.4.5 404 introuvable

Le serveur n'a rien trouvé correspondant à l'URI de la demande. Non
une indication est donnée pour savoir si la condition est temporaire ou
permanent. Le code d'état 410 (Gone) DEVRAIT être utilisé si le serveur
sait, grâce à un mécanisme configurable en interne, qu'un ancien
la ressource est définitivement indisponible et n’a pas d’adresse de transfert.
Ce code d'état est couramment utilisé lorsque le serveur ne souhaite pas
révéler exactement pourquoi la demande a été refusée, ou quand aucune autre
la réponse est applicable.

10.4.6 Méthode 405 non autorisée

La méthode spécifiée dans la Request-Line n'est pas autorisée pour le
ressource identifiée par le Request-URI. La réponse DOIT inclure un
Autoriser l'en-tête contenant une liste de méthodes valides pour le demandé
Ressource.




Fielding et coll. Voie des normes [Page 66]
 
RFC 2616 HTTP/1.1 juin 1999


10.4.7 406 Non acceptable

La ressource identifiée par la requête est uniquement capable de générer
entités de réponse dont les caractéristiques de contenu ne sont pas acceptables
selon les en-têtes d'acceptation envoyés dans la demande.

Sauf s'il s'agissait d'une requête HEAD, la réponse DEVRAIT inclure une entité
contenant une liste des caractéristiques et des emplacements d'entité disponibles
parmi lesquels l'utilisateur ou l'agent utilisateur peut choisir celui qui convient le mieux
approprié. Le format de l'entité est spécifié par le type de média donné
dans le champ d’en-tête Content-Type. Selon le format et le
capacités de l'agent utilisateur, sélection du plus approprié
le choix PEUT être effectué automatiquement. Cependant, cette spécification
ne définit aucune norme pour une telle sélection automatique.

Remarque : les serveurs HTTP/1.1 sont autorisés à renvoyer des réponses
pas acceptable selon les en-têtes d'acceptation envoyés dans le
demande. Dans certains cas, cela peut même être préférable à l'envoi d'un
Réponse 406. Les agents utilisateurs sont encouragés à inspecter les en-têtes de
une réponse entrante pour déterminer si elle est acceptable.

Si la réponse peut être inacceptable, un agent utilisateur DEVRAIT
arrêter temporairement la réception de données supplémentaires et demander à l'utilisateur un
décision sur d'autres actions.

10.4.8 Authentification proxy 407 requise

Ce code est similaire au 401 (Non autorisé), mais indique que le
le client doit d'abord s'authentifier auprès du proxy. Le mandataire DOIT
renvoie un champ d'en-tête Proxy-Authenticate (section 14.33) contenant un
défi applicable au proxy de la ressource demandée. Le
le client PEUT répéter la demande avec une autorisation proxy appropriée
champ d’en-tête (section 14.34). L'authentification d'accès HTTP est expliquée
dans "Authentification HTTP : authentification d'accès de base et Digest"
[43].

10.4.9 Expiration du délai de demande 408

Le client n'a pas produit de requête dans le délai imparti au serveur
était prêt à attendre. Le client PEUT répéter la demande sans
modifications ultérieures.

10.4.10 409 Conflit

La demande n'a pas pu être complétée en raison d'un conflit avec le
état de la ressource. Ce code n'est autorisé que dans les situations où
on s'attend à ce que l'utilisateur soit en mesure de résoudre le conflit
et soumettez à nouveau la demande. Le corps de la réponse DEVRAIT inclure suffisamment



Fielding et coll. Voie des normes [Page 67]
 
RFC 2616 HTTP/1.1 juin 1999


informations permettant à l’utilisateur de reconnaître la source du conflit.
Idéalement, l'entité de réponse devrait inclure suffisamment d'informations pour
utilisateur ou agent utilisateur pour résoudre le problème ; cependant, ce n'est peut-être pas le cas
possible et n’est pas obligatoire.

Les conflits sont plus susceptibles de se produire en réponse à une requête PUT. Pour
exemple, si le versioning était utilisé et que l'entité était PUT
incluait des modifications apportées à une ressource qui entraient en conflit avec celles apportées par un
requête antérieure (tiers), le serveur peut utiliser la réponse 409
pour indiquer qu'il ne peut pas terminer la demande. Dans ce cas, le
l'entité de réponse contiendrait probablement une liste des différences
entre les deux versions dans un format défini par la réponse
Type de contenu.

10.4.11 410 Disparu

La ressource demandée n'est plus disponible sur le serveur et aucun
l'adresse de réexpédition est connue. Cette condition devrait être
considéré comme permanent. Les clients dotés de capacités d'édition de liens DEVRAIENT
supprimez les références au Request-URI après l’approbation de l’utilisateur. Si la
le serveur ne sait pas, ou n'a aucune possibilité de déterminer, si oui ou non
la condition est permanente, le code d'état 404 (Introuvable) DEVRAIT être
utilisé à la place. Cette réponse peut être mise en cache, sauf indication contraire.

La réponse 410 est principalement destinée à faciliter la tâche du web
maintenance en notifiant au destinataire que la ressource est
intentionnellement indisponible et que les propriétaires du serveur souhaitent que
les liens distants vers cette ressource soient supprimés. Un tel événement est courant pour
services promotionnels à durée limitée et pour les ressources appartenant à
les personnes ne travaillant plus sur le site du serveur. Ce n'est pas
nécessaire de marquer toutes les ressources définitivement indisponibles comme « parties » ou
conserver la marque pendant un certain temps - cela est laissé au
discrétion du propriétaire du serveur.

10.4.12 411 Longueur requise

Le serveur refuse d'accepter la demande sans contenu défini.
Longueur. Le client PEUT répéter la demande s'il ajoute un
Champ d'en-tête Content-Length contenant la longueur du corps du message
dans le message de demande.

10.4.13 412 Échec de la condition préalable

La condition préalable donnée dans un ou plusieurs champs d'en-tête de requête
évalué à false lors du test sur le serveur. Cette réponse
le code permet au client de placer des conditions préalables sur la ressource actuelle
métainformations (données du champ d'en-tête) et ainsi empêcher la requête
méthode d’être appliquée à une ressource autre que celle prévue.



Fielding et coll. Voie des normes [Page 68]
 
RFC 2616 HTTP/1.1 juin 1999


10.4.14 413 Entité de requête trop grande

Le serveur refuse de traiter une requête car la requête
l'entité est plus grande que ce que le serveur est disposé ou capable de traiter. Le
le serveur PEUT fermer la connexion pour empêcher le client de continuer
la demande.

Si la condition est temporaire, le serveur DEVRAIT inclure un message de nouvelle tentative.
Champ d'en-tête Après pour indiquer qu'il est temporaire et après quoi
fois, le client PEUT réessayer.

10.4.15 414 URI de requête trop long

Le serveur refuse de traiter la requête car le Request-URI
est plus long que ce que le serveur est prêt à interpréter. C'est rare
Cette situation n’est susceptible de se produire que lorsqu’un client a incorrectement
converti une requête POST en requête GET avec une requête longue
informations, lorsque le client est descendu dans un "trou noir" URI de
redirection (par exemple, un préfixe d'URI redirigé qui pointe vers un suffixe de
lui-même), ou lorsque le serveur est attaqué par un client tentant de
exploiter les failles de sécurité présentes dans certains serveurs en utilisant des fichiers de longueur fixe
tampons pour lire ou manipuler le Request-URI.

10.4.16 415 Type de support non pris en charge

Le serveur refuse de répondre à la demande car l'entité de
la demande est dans un format non pris en charge par la ressource demandée
pour la méthode demandée.

10.4.17 416 Plage demandée non satisfaisante

Un serveur DEVRAIT retourner une réponse avec ce code d'état si une demande
incluait un champ d’en-tête de requête Range (section 14.35), et aucun des
les valeurs du spécificateur de plage dans ce champ chevauchent l'étendue actuelle
de la ressource sélectionnée et la demande n'incluait pas de If-Range
champ d’en-tête de demande. (Pour les plages d'octets, cela signifie que le premier
la position d'octet de toutes les valeurs de spécification de plage d'octets était supérieure à la
longueur actuelle de la ressource sélectionnée.)

Lorsque ce code d'état est renvoyé pour une demande de plage d'octets, le
la réponse DEVRAIT inclure un champ d'en-tête d'entité Content-Range
en précisant la longueur actuelle de la ressource sélectionnée (voir section
14.16). Cette réponse NE DOIT PAS utiliser le contenu multipart/byteranges.
taper.







Fielding et coll. Voie des normes [Page 69]
 
RFC 2616 HTTP/1.1 juin 1999


10.4.18 417 Attente échouée

L'attente donnée dans un champ d'en-tête de requête Expect (voir la section
14.20) ne pourrait pas être satisfait par ce serveur, ou, si le serveur est un proxy,
le serveur dispose d'une preuve sans ambiguïté que la demande n'a pas pu être satisfaite
par le serveur du prochain saut.

10.5 Erreur de serveur 5xx

Les codes d'état de réponse commençant par le chiffre « 5 » indiquent les cas dans
dont le serveur est conscient qu'il s'est trompé ou qu'il est incapable de le faire
exécuter la demande. Sauf en réponse à une requête HEAD, le
le serveur DEVRAIT inclure une entité contenant une explication du
situation d'erreur et s'il s'agit d'une situation temporaire ou permanente
condition. Les agents utilisateurs DEVRAIENT afficher toute entité incluse au
utilisateur. Ces codes de réponse sont applicables à n’importe quelle méthode de demande.

10.5.1 500 Erreur de serveur interne

Le serveur a rencontré une condition inattendue qui l'a empêché
de répondre à la demande.

10.5.2 501 Non mis en œuvre

Le serveur ne prend pas en charge les fonctionnalités requises pour remplir les
demande. C'est la réponse appropriée lorsque le serveur ne le fait pas
reconnaître la méthode de requête et n'est pas capable de la prendre en charge pour
n'importe quelle ressource.

10.5.3 502 Passerelle incorrecte

Le serveur, alors qu'il agissait comme passerelle ou proxy, a reçu un message non valide.
réponse du serveur en amont auquel il a accédé en tentant de
remplir la demande.

10.5.4 Service 503 indisponible

Le serveur est actuellement incapable de traiter la demande en raison d'un
surcharge temporaire ou maintenance du serveur. L'implication
est qu'il s'agit d'une condition temporaire qui sera atténuée après
un certain retard. Si elle est connue, la durée du délai PEUT être indiquée dans un
En-tête Réessayer-Après. Si aucun Retry-After n’est donné, le client DEVRAIT
gérer la réponse comme il le ferait pour une réponse 500.

Remarque : L'existence du code d'état 503 n'implique pas qu'un
le serveur doit l'utiliser en cas de surcharge. Certains serveurs peuvent souhaiter
refuser simplement la connexion.




Fielding et coll. Voie des normes [Page 70]
 
RFC 2616 HTTP/1.1 juin 1999


10.5.5 Expiration du délai de la passerelle 504

Le serveur, tout en agissant comme passerelle ou proxy, n'a pas reçu de message
réponse rapide du serveur en amont spécifié par l'URI (par exemple
HTTP, FTP, LDAP) ou un autre serveur auxiliaire (par exemple DNS) dont vous avez besoin
accéder en essayant de compléter la demande.

Remarque : Remarque destinée aux implémenteurs : certains proxys déployés sont connus pour
renvoie 400 ou 500 lorsque les recherches DNS expirent.

10.5.6 Version HTTP 505 non prise en charge

Le serveur ne supporte pas, ou refuse de supporter, le protocole HTTP
version utilisée dans le message de demande. Le serveur est
indiquant qu'il ne peut ou ne veut pas répondre à la demande
en utilisant la même version majeure que le client, comme décrit dans la section
3.1, autrement qu'avec ce message d'erreur. La réponse DEVRAIT contenir
une entité décrivant pourquoi cette version n'est pas prise en charge et quels autres
les protocoles sont pris en charge par ce serveur.

11 Authentification d'accès

HTTP fournit plusieurs authentifications FACULTATIVES par défi-réponse
mécanismes qui peuvent être utilisés par un serveur pour défier un client
demande et par un client pour fournir des informations d'authentification. Le
cadre général pour l'authentification des accès et la spécification des
les authentifications "basic" et "digest", sont spécifiées dans "HTTP
Authentification : authentification d'accès de base et Digest » [43].
la spécification adopte les définitions de « défi » et de « références »
à partir de cette spécification.

12 Négociation de contenu

La plupart des réponses HTTP incluent une entité qui contient des informations pour
interprétation par un utilisateur humain. Naturellement, il est souhaitable de fournir
l'utilisateur possédant la "meilleure entité disponible" correspondant au
demande. Malheureusement pour les serveurs et les caches, tous les utilisateurs n'ont pas la possibilité
mêmes préférences pour ce qui est « le meilleur », et tous les agents utilisateurs ne sont pas
également capable de restituer tous les types d’entités. Pour cette raison, HTTP
contient des dispositions pour plusieurs mécanismes de « négociation de contenu » --
le processus de sélection de la meilleure représentation pour une réponse donnée
lorsqu'il y a plusieurs représentations disponibles.

Remarque : Ceci n'est pas appelé « négociation de format » car le
les représentations alternatives peuvent être du même type de média, mais utilisez
différentes capacités de ce type, être dans différentes langues,
etc.




Fielding et coll. Voie des normes [Page 71]
 
RFC 2616 HTTP/1.1 juin 1999


Toute réponse contenant une entité-corps PEUT faire l'objet de négociation,
y compris les réponses aux erreurs.

Il existe deux types de négociation de contenu possibles dans
HTTP : négociation pilotée par le serveur et par l'agent. Ces deux sortes de
la négociation sont orthogonales et peuvent donc être utilisées séparément ou dans
combinaison. Une méthode de combinaison, dite transparente
négociation, se produit lorsqu'un cache utilise la négociation pilotée par agent
informations fournies par le serveur d'origine afin de fournir
négociation pilotée par le serveur pour les demandes ultérieures.

12.1 Négociation pilotée par le serveur

Si la sélection de la meilleure représentation pour une réponse est faite par
un algorithme situé au niveau du serveur, on l'appelle server-driven
négociation. La sélection est basée sur les représentations disponibles de
la réponse (les dimensions sur lesquelles elle peut varier ; par exemple la langue,
codage de contenu, etc.) et le contenu de champs d'en-tête particuliers dans
le message de demande ou sur d'autres informations relatives à la demande
(comme l'adresse réseau du client).

La négociation pilotée par le serveur est avantageuse lorsque l'algorithme de
choisir parmi les représentations disponibles est difficile à
décrire à l'agent utilisateur, ou lorsque le serveur souhaite envoyer son
"meilleure estimation" au client avec la première réponse (en espérant
éviter le délai aller-retour d'une demande ultérieure si le "meilleur
deviner" est suffisant pour l'utilisateur). Afin d'améliorer les performances du serveur
devinez, l'agent utilisateur PEUT inclure des champs d'en-tête de requête (Accepter,
Accept-Language, Accept-Encoding, etc.) qui décrivent son
préférences pour une telle réponse.

La négociation pilotée par le serveur présente des inconvénients :

1. Il est impossible pour le serveur de déterminer avec précision ce
pourrait être "le meilleur" pour un utilisateur donné, car cela nécessiterait
connaissance complète des capacités de l'agent utilisateur
et l'utilisation prévue de la réponse (par exemple, l'utilisateur souhaite-t-il
le visualiser sur écran ou l'imprimer sur papier ?).

2. Demander à l'agent utilisateur de décrire ses capacités dans chaque
demande peut être à la fois très inefficace (étant donné que seule une petite
pourcentage de réponses ont des représentations multiples) et un
violation potentielle de la vie privée de l'utilisateur.

3. Cela complique la mise en œuvre d'un serveur d'origine et le
algorithmes pour générer des réponses à une demande.





Fielding et coll. Voie des normes [Page 72]
 
RFC 2616 HTTP/1.1 juin 1999


4. Cela peut limiter la capacité d'un cache public à utiliser la même réponse
pour les demandes de plusieurs utilisateurs.

HTTP/1.1 inclut les champs d'en-tête de requête suivants pour activer
négociation pilotée par le serveur via la description de l'agent utilisateur
capacités et préférences de l'utilisateur : Accepter (section 14.1), Accepter-
Charset (section 14.2), Accept-Encoding (section 14.3), Accept-
Langage (section 14.4) et User-Agent (section 14.43). Cependant, un
le serveur d'origine n'est pas limité à ces dimensions et PEUT varier les
réponse basée sur n’importe quel aspect de la demande, y compris les informations
en dehors des champs d'en-tête de requête ou dans les champs d'en-tête d'extension
non défini par cette spécification.

Le champ d'en-tête Vary peut être utilisé pour exprimer les paramètres que
le serveur utilise pour sélectionner une représentation soumise au serveur.
négociation conduite. Voir la section 13.6 pour l'utilisation du champ d'en-tête Vary.
par les caches et la section 14.44 pour l'utilisation du champ d'en-tête Vary by
les serveurs.

12.2 Négociation pilotée par l'agent

Avec négociation dirigée par les agents, sélection de la meilleure représentation
car une réponse est effectuée par l'agent utilisateur après avoir reçu un
réponse initiale du serveur d'origine. La sélection est basée sur une liste
des représentations disponibles de la réponse incluses dans le
champs d'en-tête ou corps d'entité de la réponse initiale, avec chacun
représentation identifiée par son propre URI. Sélection parmi les
les représentations peuvent être effectuées automatiquement (si l'agent utilisateur est
capable de le faire) ou manuellement par l'utilisateur en sélectionnant parmi un
menu généré (éventuellement hypertexte).

La négociation dirigée par l'agent est avantageuse lorsque la réponse varie
sur les dimensions couramment utilisées (telles que le type, la langue ou l'encodage),
lorsque le serveur d'origine est incapable de déterminer le nom d'un agent utilisateur
capacités d’examiner la demande, et généralement lors de la publication
les caches sont utilisés pour répartir la charge du serveur et réduire l'utilisation du réseau.

La négociation dirigée par les agents souffre de l'inconvénient de nécessiter un
deuxième demande pour obtenir la meilleure représentation alternative. Ce
la deuxième requête n'est efficace que lorsque la mise en cache est utilisée. En outre,
cette spécification ne définit aucun mécanisme pour prendre en charge
sélection automatique, mais cela n'empêche pas non plus une telle
mécanisme d’être développé comme une extension et utilisé dans
HTTP/1.1.







Fielding et coll. Voie des normes [Page 73]
 
RFC 2616 HTTP/1.1 juin 1999


HTTP/1.1 définit les 300 (Choix multiples) et 406 (Non acceptable)
codes d'état pour activer la négociation pilotée par agent lorsque le serveur est
ne veut pas ou ne peut pas fournir une réponse variable en utilisant le serveur
négociation.

12.3 Négociation transparente

La négociation transparente est une combinaison de méthodes pilotées par le serveur et
négociation dirigée par les agents. Lorsqu'un cache est fourni avec une forme du
liste des représentations disponibles de la réponse (comme dans
négociation) et les dimensions de la variance sont parfaitement comprises
par le cache, le cache devient alors capable d'effectuer des tâches de serveur
négociation pilotée au nom du serveur d'origine pour les
requêtes sur cette ressource.

Une négociation transparente présente l’avantage de répartir les
travail de négociation qui serait autrement exigé de l'origine
serveur et supprimant également le délai de la deuxième demande de l'agent
négociation lorsque le cache est capable de deviner correctement le bon
réponse.

Cette spécification ne définit aucun mécanisme de transparence
négociation, même si cela n’empêche pas non plus un tel mécanisme de
en cours de développement comme une extension qui pourrait être utilisée dans HTTP/1.1.

13 Mise en cache en HTTP

HTTP est généralement utilisé pour les systèmes d'information distribués, où
les performances peuvent être améliorées par l’utilisation de caches de réponses. Le
Le protocole HTTP/1.1 comprend un certain nombre d'éléments destinés à rendre
travail de mise en cache aussi bien que possible. Parce que ces éléments sont
inextricable des autres aspects du protocole, et parce qu’ils
interagissent les uns avec les autres, il est utile de décrire la mise en cache de base
conception de HTTP séparément des descriptions détaillées des méthodes,
en-têtes, codes de réponse, etc.

La mise en cache serait inutile si elle ne s’améliorait pas de manière significative
performance. L'objectif de la mise en cache dans HTTP/1.1 est d'éliminer le besoin
d'envoyer des demandes dans de nombreux cas et d'éliminer le besoin d'envoyer
des réponses complètes dans de nombreux autres cas. Le premier réduit le nombre de
allers-retours réseau nécessaires à de nombreuses opérations ; nous utilisons un
mécanisme « d’expiration » prévu à cet effet (voir section 13.2). Le
ce dernier réduit les besoins en bande passante du réseau ; nous utilisons une "validation"
mécanisme prévu à cet effet (voir section 13.3).

Exigences de performances, de disponibilité et de déconnexion
opération nous oblige à pouvoir assouplir le but de la sémantique
transparence. Le protocole HTTP/1.1 autorise les serveurs d'origine, les caches,



Fielding et coll. Voie des normes [Page 74]
 
RFC 2616 HTTP/1.1 juin 1999


et les clients de réduire explicitement la transparence lorsque cela est nécessaire.
Cependant, comme une opération non transparente peut confondre les non-experts
utilisateurs et peut être incompatible avec certaines applications serveur
(comme ceux pour commander des marchandises), le protocole exige que
la transparence soit assouplie

- uniquement par une demande explicite au niveau du protocole lorsqu'elle est assouplie par
client ou serveur d'origine

- uniquement avec un avertissement explicite à l'utilisateur final en cas de relâchement par
cache ou client

Par conséquent, le protocole HTTP/1.1 fournit ces éléments importants :

1. Fonctionnalités de protocole qui offrent une transparence sémantique totale lorsque
ceci est exigé par toutes les parties.

2. Fonctionnalités de protocole qui permettent à un serveur d'origine ou à un agent utilisateur de
demander et contrôler explicitement les opérations non transparentes.

3. Fonctionnalités de protocole qui permettent à un cache d'attacher des avertissements à
les réponses qui ne préservent pas l’approximation demandée de
transparence sémantique.

Un principe de base est qu'il doit être possible pour les clients de
détecter tout relâchement potentiel de la transparence sémantique.

Remarque : L'implémenteur du serveur, du cache ou du client peut être confronté à
les décisions de conception ne sont pas explicitement discutées dans cette spécification.
Si une décision peut affecter la transparence sémantique, l'implémenteur
devrait pécher par excès de transparence, à moins qu'un
une analyse minutieuse et complète montre des avantages significatifs dans
briser la transparence.

13.1.1 Exactitude du cache

Un cache correct DOIT répondre à une requête avec le contenu le plus à jour
réponse détenue par le cache et appropriée à la requête (voir
sections 13.2.5, 13.2.6 et 13.12) qui répond à l'un des critères suivants
conditions:

1. Son équivalence a été vérifiée avec ce que le serveur d'origine
serait revenu en revalidant la réponse avec le
serveur d'origine (section 13.3);







Fielding et coll. Voie des normes [Page 75]
 
RFC 2616 HTTP/1.1 juin 1999


2. Il est « suffisamment frais » (voir section 13.2). Dans le cas par défaut,
cela signifie qu'il répond aux exigences de fraîcheur les moins restrictives
du client, du serveur d'origine et du cache (voir section 14.9) ; si
le serveur d'origine le précise, c'est l'exigence de fraîcheur
du serveur d'origine seul.

Si une réponse stockée n'est pas "assez fraîche" pour la plupart
exigence de fraîcheur restrictive du client et du
serveur d'origine, dans des circonstances soigneusement étudiées, le cache
PEUT toujours renvoyer la réponse avec l'avertissement approprié
en-tête (voir sections 13.1.5 et 14.46), à moins qu'une telle réponse
est interdit (par exemple, par une directive de cache "no-store", ou par un
directive de demande de cache « sans cache » ; voir rubrique 14.9).

3. Il s'agit d'un 304 (non modifié), 305 (redirection proxy) approprié.
ou un message de réponse d'erreur (4xx ou 5xx).

Si le cache ne peut pas communiquer avec le serveur d'origine, alors un
le cache correct DEVRAIT répondre comme ci-dessus si la réponse peut être
correctement servi depuis le cache ; sinon, il DOIT renvoyer une erreur ou
avertissement indiquant qu'il y a eu un échec de communication.

Si un cache reçoit une réponse (soit une réponse complète, soit un 304
(Réponse non modifiée)) qu'il transmettrait normalement au
client demandeur et que la réponse reçue n'est plus fraîche, le
le cache DEVRAIT le transmettre au client demandeur sans ajouter de nouveau
Avertissement (mais sans supprimer les en-têtes d'avertissement existants). Une cache
NE DEVRAIT PAS tenter de revalider une réponse simplement parce que cela
la réponse est devenue obsolète pendant le transport ; cela pourrait conduire à une infinité
boucle. Un agent utilisateur qui reçoit une réponse obsolète sans avertissement
PEUT afficher une indication d’avertissement à l’utilisateur.

13.1.2 Avertissements

Chaque fois qu'un cache renvoie une réponse qui n'est ni directe ni directe.
"assez frais" (au sens de la condition 2 de la section 13.1.1), il
DOIT joindre un avertissement à cet effet, en utilisant un en-tête général Warning.
L'en-tête Warning et les avertissements actuellement définis sont décrits
à l'article 14.46. L'avertissement permet aux clients de prendre les mesures appropriées
action.

Les avertissements PEUVENT être utilisés à d'autres fins, à la fois liées au cache et
sinon. L'utilisation d'un avertissement plutôt que d'un code d'état d'erreur,
distinguer ces réponses des véritables échecs.

Les avertissements se voient attribuer des codes d'avertissement à trois chiffres. Le premier chiffre
indique si l'avertissement DOIT ou NE DOIT PAS être supprimé d'un
entrée de cache stockée après une revalidation réussie :



Fielding et coll. Voie des normes [Page 76]
 
RFC 2616 HTTP/1.1 juin 1999


1xx Avertissements décrivant l'état de fraîcheur ou de revalidation de
la réponse, et DOIT donc être supprimé après une réussite
revalidation. Les codes d'avertissement 1XX PEUVENT être générés par un cache uniquement lorsque
valider une entrée en cache. Il NE DOIT PAS être généré par les clients.

2xx Avertissements décrivant certains aspects du corps ou de l'entité de l'entité
en-têtes qui n'est pas rectifié par une revalidation (par exemple, un
compression avec perte des corps de l'entité) et qui NE DOIT PAS être
supprimé après une revalidation réussie.

Voir la section 14.46 pour les définitions des codes eux-mêmes.

Les caches HTTP/1.0 mettront en cache tous les avertissements dans les réponses, sans
en supprimant ceux de la première catégorie. Avertissements dans les réponses qui
sont transmis aux caches HTTP/1.0 et comportent un champ de date d'avertissement supplémentaire,
ce qui empêche un futur destinataire HTTP/1.1 de croire un
Avertissement mis en cache par erreur.

Les avertissements comportent également un texte d'avertissement. Le texte PEUT être dans n'importe quel
langage naturel approprié (peut-être basé sur l'acceptation du client)
en-têtes) et incluent une indication FACULTATIVE du jeu de caractères
utilisé.

Plusieurs avertissements PEUVENT être attachés à une réponse (soit par l'origine
serveur ou par un cache), incluant plusieurs avertissements avec le même code
nombre. Par exemple, un serveur peut fournir le même avertissement avec
textes en anglais et en basque.

Lorsque plusieurs avertissements sont joints à une réponse, il se peut qu'elle ne soit pas
pratique ou raisonnable de tous les afficher à l’utilisateur. Ce
La version HTTP ne spécifie pas de règles de priorité strictes pour décider
quels avertissements afficher et dans quel ordre, mais suggère quelques
heuristique.

13.1.3 Mécanismes de contrôle du cache

Les mécanismes de cache de base dans HTTP/1.1 (expiration spécifiée par le serveur
times et validateurs) sont des directives implicites pour les caches. Dans certaines
Dans certains cas, un serveur ou un client peut avoir besoin de fournir des directives explicites
aux caches HTTP. Nous utilisons l'en-tête Cache-Control à cet effet.

L'en-tête Cache-Control permet à un client ou un serveur de transmettre un
variété de directives dans les demandes ou les réponses. Ces
Les directives remplacent généralement les algorithmes de mise en cache par défaut. Comme un
règle générale, s'il y a un conflit apparent entre l'en-tête
valeurs, l’interprétation la plus restrictive est appliquée (c’est-à-dire la
celui qui est le plus susceptible de préserver la transparence sémantique). Cependant,




Fielding et coll. Voie des normes [Page 77]
 
RFC 2616 HTTP/1.1 juin 1999


dans certains cas, les directives de contrôle du cache sont explicitement spécifiées comme
affaiblissant le rapprochement de la transparence sémantique (par exemple,
"max-stale" ou "public").

Les directives de contrôle du cache sont décrites en détail dans la section 14.9.

13.1.4 Avertissements explicites de l'agent utilisateur

De nombreux agents utilisateurs permettent aux utilisateurs de remplacer les paramètres de base.
mécanismes de mise en cache. Par exemple, l'agent utilisateur peut autoriser l'utilisateur
pour spécifier que les entités mises en cache (même celles explicitement obsolètes) sont
jamais validé. Ou l'agent utilisateur peut habituellement ajouter "Cache-
Contrôle : max-stale=3600" à chaque requête. L'agent utilisateur NE DEVRAIT PAS
par défaut soit un comportement non transparent, soit un comportement qui en résulte
dans une mise en cache anormalement inefficace, mais PEUT être explicitement configuré
de le faire par une action explicite de l'utilisateur.

Si l'utilisateur a remplacé les mécanismes de mise en cache de base, il
l'agent DEVRAIT explicitement indiquer à l'utilisateur chaque fois que cela entraîne
l'affichage d'informations qui pourraient ne pas répondre aux exigences du serveur
exigences de transparence (notamment si l'entité affichée est
connu pour être périmé). Puisque le protocole permet normalement à l'agent utilisateur
pour déterminer si les réponses sont périmées ou non, cette indication doit seulement
être affiché lorsque cela se produit réellement. L'indication ne doit pas nécessairement être une
boite de dialogue; il peut s'agir d'une icône (par exemple, l'image d'un
poisson) ou un autre indicateur.

Si l'utilisateur a remplacé les mécanismes de mise en cache d'une manière qui pourrait
anormalement l'efficacité des caches, l'agent utilisateur DEVRAIT
indiquer en permanence cet état à l'utilisateur (par exemple, par un
affichage d'une image de monnaie en flammes) afin que l'utilisateur ne
consommer par inadvertance des ressources excédentaires ou souffrir d'un
latence.

13.1.5 Exceptions aux règles et avertissements

Dans certains cas, l'opérateur d'un cache PEUT choisir de le configurer pour
renvoie des réponses obsolètes même si elles ne sont pas demandées par les clients. Ce
la décision ne doit pas être prise à la légère, mais peut être nécessaire pour des raisons
de disponibilité ou de performances, surtout lorsque le cache est mal
connecté au serveur d'origine. Chaque fois qu'un cache renvoie un message obsolète
réponse, il DOIT le marquer comme tel (en utilisant un en-tête Warning) permettant
le logiciel client pour alerter l'utilisateur qu'il pourrait y avoir un potentiel
problème.







Fielding et coll. Voie des normes [Page 78]
 
RFC 2616 HTTP/1.1 juin 1999


Cela permet également à l'agent utilisateur de prendre des mesures pour obtenir une information de première main ou
nouvelle réponse. Pour cette raison, un cache NE DEVRAIT PAS renvoyer un
réponse si le client en demande explicitement une de première main ou une nouvelle,
sauf s'il est impossible de s'y conformer pour des raisons techniques ou politiques.

13.1.6 Comportement contrôlé par le client

Alors que le serveur d'origine (et dans une moindre mesure, les caches intermédiaires,
par leur contribution à l'âge d'une réponse) sont les principaux
source d'informations sur l'expiration, dans certains cas, le client peut avoir besoin
pour contrôler la décision d'un cache quant à savoir s'il faut renvoyer un élément mis en cache
réponse sans la valider. Les clients le font en utilisant plusieurs
directives de l’en-tête Cache-Control.

La demande d'un client PEUT préciser l'âge maximum auquel il est prêt à
accepter une réponse non validée ; spécifier une valeur de forces nulles
le(s) cache(s) pour revalider toutes les réponses. Un client PEUT également spécifier
le temps minimum restant avant l'expiration d'une réponse. Ces deux
les options augmentent les contraintes sur le comportement des caches et ne peuvent donc pas
assouplir davantage l'approximation de la transparence sémantique du cache.

Un client PEUT également spécifier qu'il acceptera les réponses périmées, jusqu'à
un maximum d'obsolescence. Cela relâche les contraintes sur le
caches, et pourrait donc violer les spécifications spécifiées par le serveur d'origine
contraintes sur la transparence sémantique, mais pourrait être nécessaire pour
prendre en charge le fonctionnement déconnecté ou la haute disponibilité face à
mauvaise connectivité.

13.2 Modèle d'expiration

13.2.1 Expiration spécifiée par le serveur

La mise en cache HTTP fonctionne mieux lorsque les caches peuvent totalement éviter de créer des problèmes.
requêtes au serveur d'origine. Le principal mécanisme pour éviter
les requêtes consistent pour un serveur d'origine à fournir une expiration explicite
moment dans le futur, indiquant qu'une réponse PEUT être utilisée pour satisfaire
demandes ultérieures. En d’autres termes, un cache peut renvoyer une nouvelle
réponse sans contacter au préalable le serveur.

Nous nous attendons à ce que les serveurs attribuent de futurs
délais d'expiration des réponses dans la conviction que l'entité n'est pas
susceptible de changer, de manière sémantiquement significative, avant le
le délai de péremption est atteint. Cela préserve normalement la sémantique
transparence, à condition que les délais d'expiration du serveur soient soigneusement
choisi.






Fielding et coll. Voie des normes [Page 79]
 
RFC 2616 HTTP/1.1 juin 1999


Le mécanisme d'expiration s'applique uniquement aux réponses extraites d'un cache
et non aux réponses de première main transmises immédiatement au
client demandeur.

Si un serveur d'origine souhaite forcer un cache sémantiquement transparent
pour valider chaque demande, il PEUT attribuer un délai d'expiration explicite
dans le passé. Cela signifie que la réponse est toujours obsolète, et donc le
le cache DEVRAIT le valider avant de l'utiliser pour des requêtes ultérieures. Voir
section 14.9.4 pour une manière plus restrictive de forcer la revalidation.

Si un serveur d'origine souhaite forcer un cache HTTP/1.1, quelle que soit la manière
il est configuré, pour valider chaque demande, il DEVRAIT utiliser le "must-
revalidate" directive de contrôle de cache (voir section 14.9).

Les serveurs spécifient des délais d'expiration explicites à l'aide de l'option Expires
ou la directive max-age de l'en-tête Cache-Control.

Un délai d'expiration ne peut pas être utilisé pour forcer un agent utilisateur à actualiser
son affichage ou rechargement d'une ressource ; sa sémantique s'applique uniquement à la mise en cache
mécanismes, et ces mécanismes n'ont besoin que de vérifier les ressources d'une ressource.
statut d’expiration lorsqu’une nouvelle demande pour cette ressource est lancée.
Voir la section 13.13 pour une explication de la différence entre les caches
et les mécanismes historiques.

13.2.2 Expiration heuristique

Étant donné que les serveurs d'origine ne fournissent pas toujours des délais d'expiration explicites,
Les caches HTTP attribuent généralement des délais d'expiration heuristiques, en utilisant
algorithmes qui utilisent d'autres valeurs d'en-tête (telles que Last-Modified
heure) pour estimer une heure d’expiration plausible. Le HTTP/1.1
la spécification ne fournit pas d'algorithmes spécifiques, mais impose
contraintes les plus défavorables sur leurs résultats. Depuis l'expiration de l'heuristique
les temps pourraient compromettre la transparence sémantique, ils devraient utiliser
avec prudence, et nous encourageons les serveurs d'origine à fournir des
délais d'expiration autant que possible.

13.2.3 Calculs d'âge

Afin de savoir si une entrée mise en cache est récente, un cache doit savoir si
son âge dépasse sa durée de vie fraîcheur. Nous discutons de la façon de calculer
ce dernier à la section 13.2.4 ; cette section décrit comment calculer
l'âge d'une réponse ou d'une entrée de cache.

Dans cette discussion, nous utilisons le terme « maintenant » pour désigner « la valeur actuelle
de l'horloge de l'hôte effectuant le calcul." Les hôtes qui utilisent
HTTP, mais surtout les hôtes exécutant des serveurs d'origine et des caches, DEVRAIT
utiliser NTP [28] ou un protocole similaire pour synchroniser leurs horloges avec
un étalon de temps globalement précis.



Fielding et coll. Voie des normes [Page 80]
 
RFC 2616 HTTP/1.1 juin 1999


HTTP/1.1 nécessite que les serveurs d'origine envoient un en-tête Date, si possible,
avec chaque réponse, en indiquant l'heure à laquelle la réponse a été
généré (voir section 14.18). Nous utilisons le terme « date_value » pour désigner
la valeur de l'en-tête Date, sous une forme appropriée pour l'arithmétique
opérations.

HTTP/1.1 utilise l'en-tête de réponse Age pour transmettre l'âge estimé de
le message de réponse lorsqu'il est obtenu à partir d'un cache. La valeur du champ Âge
est l'estimation du cache du temps écoulé depuis la réponse
générés ou revalidés par le serveur d'origine.

Essentiellement, la valeur Age est la somme du temps pendant lequel la réponse
a résidé dans chacune des caches le long du chemin depuis le
serveur d'origine, plus le temps pendant lequel il a transité
chemins de réseau.

Nous utilisons le terme "age_value" pour désigner la valeur de l'en-tête Age, dans
une forme appropriée pour les opérations arithmétiques.

L'âge d'une réponse peut être calculé de deux manières totalement indépendantes :

1. maintenant moins date_value, si l'horloge locale fonctionne raisonnablement bien
synchronisé avec l'horloge du serveur d'origine. Si le résultat est
négatif, le résultat est remplacé par zéro.

2. age_value, si tous les caches le long du chemin de réponse
implémentez HTTP/1.1.

Étant donné qu’il existe deux manières indépendantes de calculer l’âge d’un
réponse lorsqu'elle est reçue, nous pouvons les combiner comme

corrigé_received_age = max (maintenant - date_value, age_value)

et tant que nous avons soit des horloges presque synchronisées, soit tout-
HTTP/1.1, on obtient un résultat fiable (conservateur).

En raison des retards imposés par le réseau, un intervalle important peut
s'écoule entre le moment où un serveur génère une réponse et le moment
il est reçu au prochain cache ou client sortant. Si non corrigé,
ce retard pourrait entraîner des âges incorrectement bas.

Parce que la requête qui a abouti à la valeur Age renvoyée doit avoir
été initié avant la génération de cette valeur Age, nous pouvons corriger
pour les retards imposés par le réseau en enregistrant l'heure à laquelle le
la demande a été initiée. Ensuite, lorsqu'une valeur Age est reçue, elle DOIT
être interprété par rapport à l'heure à laquelle la demande a été lancée, et non





Fielding et coll. Voie des normes [Page 81]
 
RFC 2616 HTTP/1.1 juin 1999


l'heure à laquelle la réponse a été reçue. Cet algorithme aboutit à
comportement conservateur, quel que soit le retard subi. Alors on
calculer:

corrigé_initial_age = corrigé_received_age
+ (maintenant - request_time)

où "request_time" est l'heure (selon l'horloge locale) à laquelle
la demande qui a suscité cette réponse a été envoyée.

Résumé de l'algorithme de calcul de l'âge, lorsqu'un cache reçoit un
réponse:

/*
* valeur_âge
* est la valeur de Age : en-tête reçu par le cache avec
*cette réponse.
* valeur_date
* est la valeur de l'en-tête Date : du serveur d'origine
* request_time
* est l'heure (locale) à laquelle le cache a fait la demande
* qui a abouti à cette réponse mise en cache
* Temps de réponse
* est l'heure (locale) à laquelle le cache a reçu le
* réponse
* maintenant
* est l'heure (locale) actuelle
*/

apparent_age = max(0, réponse_time - date_value);
corrigé_received_age = max(apparent_age, age_value);
réponse_delay = réponse_time - request_time ;
corrigé_initial_age = corrigé_received_age + réponse_delay ;
résident_time = maintenant - réponse_time ;
current_age = corrigé_initial_age + résident_time ;

Le current_age d'une entrée de cache est calculé en ajoutant le montant
du temps (en secondes) depuis la dernière validation de l'entrée du cache par le
serveur d'origine vers le corrigé_initial_age. Lorsqu'une réponse est
généré à partir d'une entrée de cache, le cache DOIT inclure un seul âge
champ d'en-tête dans la réponse avec une valeur égale à celle de l'entrée du cache
âge actuel.

La présence d'un champ d'en-tête Age dans une réponse implique qu'un
la réponse n’est pas directe. Cependant, l’inverse n’est pas vrai puisque
l'absence de champ d'en-tête Age dans une réponse n'implique pas que le





Fielding et coll. Voie des normes [Page 82]
 
RFC 2616 HTTP/1.1 juin 1999


la réponse est de première main, à moins que tous les caches le long du chemin de la requête ne soient
conforme à HTTP/1.1 (c'est-à-dire que les anciens caches HTTP n'implémentaient pas
le champ d'en-tête Âge).

13.2.4 Calculs d'expiration

Afin de décider si une réponse est nouvelle ou périmée, nous devons
comparez sa durée de vie en termes de fraîcheur à son âge. L'âge est calculé comme
décrit à la section 13.2.3 ; cette section décrit comment calculer
la durée de vie de la fraîcheur et pour déterminer si une réponse a expiré.
Dans la discussion ci-dessous, les valeurs peuvent être représentées sous n'importe quelle forme
approprié pour les opérations arithmétiques.

Nous utilisons le terme "expires_value" pour désigner la valeur de l'Expires
entête. Nous utilisons le terme « max_age_value » pour désigner une
valeur du nombre de secondes portées par la directive "max-age" de
l'en-tête Cache-Control dans une réponse (voir section 14.9.3).

La directive max-age est prioritaire sur Expires, donc si max-age est
présent dans une réponse, le calcul est simplement :

freshness_lifetime = max_age_value

Sinon, si Expires est présent dans la réponse, le calcul est :

freshness_lifetime = expires_value - date_value

Notez qu'aucun de ces calculs n'est vulnérable au décalage d'horloge,
puisque toutes les informations proviennent du serveur d’origine.

Si aucun des éléments n'expire, Cache-Control : max-age ou Cache-Control : s-
maxage (voir section 14.9.3) apparaît dans la réponse, et la réponse
n'inclut pas d'autres restrictions sur la mise en cache, le cache PEUT calculer
une vie de fraîcheur à l'aide d'une heuristique. Le cache DOIT s'attacher Attention
113 à toute réponse dont l'âge est supérieur à 24 heures si un tel avertissement
n'a pas déjà été ajouté.

De plus, si la réponse a une heure de dernière modification, l'heuristique
la valeur d'expiration NE DEVRAIT pas être supérieure à une fraction de l'intervalle
Depuis cette époque. Un réglage typique de cette fraction pourrait être de 10 %.

Le calcul pour déterminer si une réponse a expiré est assez complexe.
simple:

réponse_is_fresh = (freshness_lifetime > current_age)






Fielding et coll. Voie des normes [Page 83]
 
RFC 2616 HTTP/1.1 juin 1999


13.2.5 Lever l'ambiguïté des valeurs d'expiration

Étant donné que les valeurs d'expiration sont attribuées de manière optimiste, il est possible
pour que deux caches contiennent de nouvelles valeurs pour la même ressource qui sont
différent.

Si un client effectuant une récupération reçoit une réponse non directe
pour une requête qui était déjà fraîche dans son propre cache, et la Date
l'en-tête dans son entrée de cache existante est plus récent que la date du nouveau
réponse, alors le client PEUT ignorer la réponse. Si c'est le cas, cela PEUT
réessayez la requête avec une directive "Cache-Control: max-age=0" (voir
section 14.9), pour forcer une vérification auprès du serveur d'origine.

Si un cache a deux nouvelles réponses pour la même représentation avec
différents validateurs, il DOIT utiliser celui avec la date la plus récente
entête. Cette situation peut survenir parce que le cache est en train de se regrouper
réponses d'autres caches, ou parce qu'un client a demandé un
rechargement ou une revalidation d'une entrée de cache apparemment fraîche.

13.2.6 Lever l'ambiguïté des réponses multiples

Étant donné qu'un client peut recevoir des réponses via plusieurs chemins,
que certaines réponses transitent par un ensemble de caches et d'autres
les réponses transitent par un ensemble différent de caches, un client peut
recevoir des réponses dans un ordre différent de celui dans lequel l'origine
le serveur les a envoyés. Nous souhaitons que le client utilise le plus récent
réponse générée, même si des réponses plus anciennes semblent encore
frais.

Ni la balise d'entité ni la valeur d'expiration ne peuvent imposer une
l'ordre des réponses, car il est possible qu'une réponse ultérieure
comporte intentionnellement une date d’expiration antérieure. Les valeurs de Date sont
ordonné à une granularité d’une seconde.

Lorsqu'un client tente de revalider une entrée de cache et que la réponse
reçoit contient un en-tête Date qui semble être plus ancien que celui
pour l'entrée existante, alors le client DEVRAIT répéter la demande
sans condition, et inclure

Contrôle du cache : max-age=0

pour forcer les caches intermédiaires à valider directement leurs copies
avec le serveur d'origine, ou

Cache-Control : pas de cache

pour forcer les caches intermédiaires à obtenir une nouvelle copie depuis l'origine
serveur.



Fielding et coll. Voie des normes [Page 84]
 
RFC 2616 HTTP/1.1 juin 1999


Si les valeurs de Date sont égales, alors le client PEUT utiliser l'une ou l'autre des réponses
(ou PEUT, si c'est extrêmement prudent, demander une nouvelle réponse).
Les serveurs NE DOIVENT PAS dépendre de la capacité des clients à choisir
de manière déterministe entre les réponses générées au cours de la même seconde,
si leurs délais d'expiration se chevauchent.

13.3 Modèle de validation

Lorsqu'un cache contient une entrée obsolète qu'il souhaite utiliser comme
réponse à la demande d'un client, il doit d'abord vérifier auprès de l'origine
serveur (ou éventuellement un cache intermédiaire avec une nouvelle réponse) pour
voir si son entrée en cache est toujours utilisable. Nous appelons cela « valider »
l'entrée du cache. Puisque nous ne voulons pas avoir à payer les frais généraux de
retransmettre la réponse complète si l'entrée mise en cache est bonne, et nous
ne voulez pas payer les frais généraux d'un aller-retour supplémentaire si le cache
l'entrée n'est pas valide, le protocole HTTP/1.1 prend en charge l'utilisation de
méthodes conditionnelles.

Les principales fonctionnalités du protocole pour prendre en charge les méthodes conditionnelles sont
ceux concernés par les « validateurs de cache ». Lorsqu'un serveur d'origine
génère une réponse complète, il y attache une sorte de validateur,
qui est conservé avec l'entrée du cache. Lorsqu'un client (agent utilisateur ou
proxy cache) effectue une demande conditionnelle pour une ressource pour laquelle il
a une entrée de cache, il inclut le validateur associé dans le
demande.

Le serveur vérifie ensuite ce validateur par rapport au validateur actuel
pour l'entité, et, s'ils correspondent (voir section 13.3.3), elle répond
avec un code d'état spécial (généralement 304 (non modifié)) et aucun
entité-corps. Sinon, il renvoie une réponse complète (y compris
entité-corps). Ainsi, nous évitons de transmettre la réponse complète si le
le validateur correspond, et nous évitons un aller-retour supplémentaire si ce n'est pas le cas
correspondre.

Dans HTTP/1.1, une requête conditionnelle ressemble exactement à une requête normale
demande pour la même ressource, sauf qu'elle comporte un
en-tête (qui inclut le validateur) qui transforme implicitement le
méthode (généralement, GET) en condition.

Le protocole inclut des sens de cache à la fois positifs et négatifs.
conditions de validation. Autrement dit, il est possible de demander soit que
une méthode doit être exécutée si et seulement si un validateur correspond ou si et
seulement si aucun validateur ne correspond.








Fielding et coll. Voie des normes [Page 85]
 
RFC 2616 HTTP/1.1 juin 1999


Remarque : une réponse dépourvue de validateur peut toujours être mise en cache, et
servi depuis le cache jusqu'à son expiration, sauf si cela est explicitement indiqué
interdit par une directive de contrôle de cache. Cependant, un cache ne peut pas
effectuer une récupération conditionnelle s'il n'a pas de validateur pour le
entité, ce qui signifie qu’elle ne sera pas actualisable après son expiration.

13.3.1 Dates de dernière modification

La valeur du champ d'en-tête d'entité Last-Modified est souvent utilisée comme cache.
validateur. En termes simples, une entrée de cache est considérée comme valide
si l'entité n'a pas été modifiée depuis la valeur Last-Modified.

13.3.2 Validateurs de cache de balises d'entité

La valeur du champ d'en-tête de réponse ETag, une balise d'entité, fournit un
validateur de cache "opaque". Cela pourrait permettre une validation plus fiable
dans les situations où il n'est pas pratique de stocker les dates de modification,
où la résolution d'une seconde des valeurs de date HTTP n'est pas
suffisant, ou lorsque le serveur d'origine souhaite éviter certaines
paradoxes qui pourraient découler de l’utilisation de dates de modification.

Les balises d’entité sont décrites dans la section 3.11. Les en-têtes utilisés avec
Les balises d'entité sont décrites dans les sections 14.19, 14.24, 14.26 et 14.44.

13.3.3 Validateurs faibles et forts

Puisque les serveurs d'origine et les caches compareront deux validateurs à
décider s'ils représentent des entités identiques ou différentes, une normalement
s'attendrait à ce que si l'entité (l'entité-organisme ou toute entité-
en-têtes) change de quelque manière que ce soit, alors le validateur associé
changer aussi. Si cela est vrai, alors nous appelons ce validateur un
"validateur fort."

Cependant, il peut y avoir des cas où un serveur préfère modifier le
validateur uniquement sur les changements sémantiquement significatifs, et non lorsque
aspects insignifiants du changement d’entité. Un validateur qui ne
changer toujours lorsque la ressource change est un « validateur faible ».

Les balises d'entité sont normalement des « validateurs puissants », mais le protocole
fournit un mécanisme pour marquer une balise d'entité comme « faible ». On peut penser à
un validateur fort comme celui qui change chaque fois que les bits d'une entité
change, tandis qu'une valeur faible change chaque fois que la signification d'une entité
changements. Alternativement, on peut penser à un validateur fort dans le cadre
d'un identifiant pour une entité spécifique, alors qu'un validateur faible est
partie d'un identifiant pour un ensemble d'entités sémantiquement équivalentes.

Remarque : Un exemple de validateur fort est un entier qui est
incrémenté dans le stockage stable à chaque fois qu'une entité est modifiée.



Fielding et coll. Voie des normes [Page 86]
 
RFC 2616 HTTP/1.1 juin 1999


L'heure de modification d'une entité, si elle est représentée par une seconde
résolution, pourrait être un validateur faible, car il est possible que
la ressource peut être modifiée deux fois en une seule seconde.

La prise en charge des validateurs faibles est facultative. Cependant, les validateurs faibles
permettre une mise en cache plus efficace des objets équivalents ; pour
Par exemple, un compteur de visites sur un site est probablement suffisant s'il est
mis à jour tous les quelques jours ou semaines, et toute valeur pendant cette période
est probablement « assez bon » pour être équivalent.

Une "utilisation" d'un validateur se produit soit lorsqu'un client génère une requête
et inclut le validateur dans un champ d'en-tête de validation, ou lorsqu'un
Le serveur compare deux validateurs.

Des validateurs puissants sont utilisables dans n’importe quel contexte. Les validateurs faibles sont seulement
utilisable dans des contextes qui ne dépendent pas de l’égalité exacte d’une entité.
Par exemple, l’un ou l’autre type est utilisable pour un GET conditionnel d’un objet complet.
entité. Cependant, seul un validateur puissant est utilisable pour une sous-gamme
récupération, car sinon le client pourrait se retrouver avec un fichier interne
entité incohérente.

Les clients PEUVENT émettre des requêtes GET simples (sans sous-gamme) avec soit des requêtes faibles
validateurs ou validateurs forts. Les clients NE DOIVENT PAS utiliser de validateurs faibles
dans d'autres formes de demande.

La seule fonction que le protocole HTTP/1.1 définit sur les validateurs est
comparaison. Il existe deux fonctions de comparaison des validateurs, selon
sur la question de savoir si le contexte de comparaison permet l'utilisation de validateurs faibles
ou non:

- La fonction de comparaison forte : pour être considéré comme égal,
les deux validateurs DOIVENT être identiques en tous points, et les deux DOIVENT
NE soyez PAS faible.

- La fonction de comparaison faible : pour être considéré comme égal,
les deux validateurs DOIVENT être identiques en tous points, mais soit ou
les deux PEUVENT être étiquetés comme « faibles » sans affecter le
résultat.

Une balise d’entité est forte à moins qu’elle ne soit explicitement marquée comme faible.
La section 3.11 donne la syntaxe des balises d'entité.

Une heure de dernière modification, lorsqu'elle est utilisée comme validateur dans une requête, est
implicitement faible à moins qu'il soit possible d'en déduire qu'il est fort,
en utilisant les règles suivantes :

- Le validateur est comparé par un serveur d'origine au
validateur actuel réel pour l’entité et,



Fielding et coll. Voie des normes [Page 87]
 
RFC 2616 HTTP/1.1 juin 1999


- Ce serveur d'origine sait de manière fiable que l'entité associée l'a fait
ne change pas deux fois au cours de la seconde couverte par le présenté
validateur.

ou

- Le validateur est sur le point d'être utilisé par un client dans un If-
En-tête Modified-Since ou If-Unmodified-Since, car le client
a une entrée de cache pour l'entité associée, et

- Cette entrée de cache inclut une valeur Date, qui donne l'heure
lorsque le serveur d'origine a envoyé la réponse originale, et

- L'heure de dernière modification présentée est d'au moins 60 secondes avant
la valeur Date.

ou

- Le validateur est comparé par un cache intermédiaire au
validateur stocké dans son entrée de cache pour l'entité, et

- Cette entrée de cache inclut une valeur Date, qui donne l'heure
lorsque le serveur d'origine a envoyé la réponse originale, et

- L'heure de dernière modification présentée est d'au moins 60 secondes avant
la valeur Date.

Cette méthode repose sur le fait que si deux réponses différentes étaient
envoyé par le serveur d'origine au cours de la même seconde, mais les deux avaient le
même heure de dernière modification, alors au moins une de ces réponses serait
avoir une valeur Date égale à son heure de dernière modification. L'arbitraire 60-
la deuxième limite protège contre la possibilité que la date et le dernier
Les valeurs modifiées sont générées à partir de différentes horloges, ou à un rythme quelque peu
différents moments au cours de la préparation de la réponse. Un
l'implémentation PEUT utiliser une valeur supérieure à 60 secondes, si elle est
pensait que 60 secondes, c'était trop court.

Si un client souhaite effectuer une récupération de sous-gamme sur une valeur de
dont il n'a qu'une heure de dernière modification et aucun validateur opaque, il
PEUT le faire uniquement si l'heure de dernière modification est forte dans le sens
décrit ici.

Un serveur de cache ou d'origine recevant une requête conditionnelle, autre que
une requête GET complète, DOIT utiliser la fonction de comparaison forte pour
évaluer l'état.

Ces règles permettent aux caches et aux clients HTTP/1.1 d'effectuer des sous-traitements en toute sécurité.
récupérations de plages sur les valeurs obtenues à partir de HTTP/1.0



Fielding et coll. Voie des normes [Page 88]
 
RFC 2616 HTTP/1.1 juin 1999


les serveurs.

13.3.4 Règles pour savoir quand utiliser les balises d'entité et les dates de dernière modification

Nous adoptons un ensemble de règles et de recommandations pour les serveurs d'origine,
clients et caches concernant le moment où les différents types de validateurs doivent
être utilisé et à quelles fins.

Serveurs d'origine HTTP/1.1 :

- DEVRAIT envoyer un validateur de balise d'entité à moins qu'il ne soit pas possible de
en générer un.

- PEUT envoyer une balise d'entité faible au lieu d'une balise d'entité forte, si
les considérations de performances soutiennent l'utilisation de balises d'entité faibles,
ou s'il est impossible d'envoyer une balise d'entité forte.

- DEVRAIT envoyer une valeur Last-Modified s'il est possible d'en envoyer une,
sauf risque de rupture de la transparence sémantique qui
pourrait résulter de l'utilisation de cette date dans un en-tête If-Modified-Since
entraînerait de graves problèmes.

En d’autres termes, le comportement préféré pour un serveur d’origine HTTP/1.1
consiste à envoyer à la fois une balise d'entité forte et une valeur Last-Modified.

Pour être légale, une balise d'entité forte DOIT changer chaque fois que le
la valeur de l’entité associée change de quelque manière que ce soit. Une balise d'entité faible DEVRAIT
changer chaque fois que l’entité associée change de manière sémantique
manière significative.

Remarque : afin de fournir une mise en cache sémantiquement transparente, un
le serveur d'origine doit éviter de réutiliser une balise d'entité forte spécifique
valeur pour deux entités différentes, ou en réutilisant une valeur faible spécifique
valeur de balise d’entité pour deux entités sémantiquement différentes. Cache
les entrées peuvent persister pendant des périodes arbitrairement longues, indépendamment de
délais d'expiration, il pourrait donc être inapproprié de s'attendre à ce qu'un
le cache ne tentera plus jamais de valider une entrée à l'aide d'un
validateur qu’il a obtenu à un moment donné dans le passé.

Clients HTTP/1.1 :

- Si une balise d'entité a été fournie par le serveur d'origine, DOIT
utiliser cette balise d'entité dans toute requête conditionnelle au cache (en utilisant If-
Correspondance ou Si aucune correspondance).

- Si seule une valeur Last-Modified a été fournie par l'origine
serveur, DEVRAIT utiliser cette valeur dans un cache conditionnel non-sous-plage
demandes (en utilisant If-Modified-Since).



Fielding et coll. Voie des normes [Page 89]
 
RFC 2616 HTTP/1.1 juin 1999


- Si seule une valeur Last-Modified a été fournie par un HTTP/1.0
serveur d'origine, PEUT utiliser cette valeur dans le cache de sous-plage sous condition
requêtes (en utilisant If-Unmodified-Since :). L'agent utilisateur DEVRAIT
fournir un moyen de désactiver cela, en cas de difficulté.

- Si une balise d'entité et une valeur Last-Modified ont été
fourni par le serveur d'origine, DEVRAIT utiliser les deux validateurs dans
requêtes conditionnelles au cache. Cela permet à la fois HTTP/1.0 et
HTTP/1.1 met en cache pour répondre de manière appropriée.

Un serveur d'origine HTTP/1.1, dès réception d'une requête conditionnelle qui
inclut à la fois une date de dernière modification (par exemple, dans un champ If-Modified-Depuis ou
champ d'en-tête If-Unmodified-Since) et une ou plusieurs balises d'entité (par exemple,
dans un champ d'en-tête If-Match, If-None-Match ou If-Range) comme cache
les validateurs, NE DOIVENT PAS renvoyer un statut de réponse de 304 (Non modifié)
à moins que cela soit cohérent avec l'ensemble de l'en-tête conditionnel
champs dans la demande.

Un proxy de mise en cache HTTP/1.1, dès réception d'une requête conditionnelle qui
inclut à la fois une date de dernière modification et une ou plusieurs balises d'entité comme
les validateurs de cache, NE DOIVENT PAS renvoyer une réponse mise en cache localement au
client, sauf si cette réponse mise en cache est cohérente avec tous les
champs d’en-tête conditionnels dans la demande.

Remarque : Le principe général derrière ces règles est que HTTP/1.1
les serveurs et les clients doivent transmettre autant de données non redondantes
informations disponibles dans leurs réponses et demandes.
Les systèmes HTTP/1.1 recevant ces informations tireront le meilleur parti
hypothèses conservatrices sur les validateurs qu’ils reçoivent.

Les clients et caches HTTP/1.0 ignoreront les balises d'entité. En général,
les dernières valeurs modifiées reçues ou utilisées par ces systèmes seront
prendre en charge la mise en cache transparente et efficace, et donc l'origine HTTP/1.1
les serveurs doivent fournir des valeurs Last-Modified. Dans ces rares cas
où l'utilisation d'une valeur Last-Modified comme validateur par un
Le système HTTP/1.0 pourrait entraîner un problème sérieux, alors HTTP/1.1
les serveurs d'origine ne devraient pas en fournir un.

13.3.5 Conditions non validantes

Le principe derrière les balises d'entité est que seul l'auteur du service
connaît suffisamment bien la sémantique d'une ressource pour en sélectionner un
mécanisme de validation du cache approprié et la spécification de tout
fonction de comparaison du validateur plus complexe que ne le ferait l'égalité d'octets
ouvrez une boîte de Pandore. Ainsi, les comparaisons de tout autre en-tête
(sauf Last-Modified, pour compatibilité avec HTTP/1.0) ne sont jamais
utilisé à des fins de validation d’une entrée de cache.




Fielding et coll. Voie des normes [Page 90]
 
RFC 2616 HTTP/1.1 juin 1999


13.4 Mise en cache des réponses

Sauf contrainte spécifique par un contrôle de cache (section 14.9)
directive, un système de mise en cache PEUT toujours stocker une réponse réussie
(voir section 13.8) comme entrée de cache, PEUT la renvoyer sans validation
s'il est frais, et PEUT le renvoyer après une validation réussie. Si
il n'y a ni validateur de cache ni délai d'expiration explicite
associé à une réponse, nous ne nous attendons pas à ce qu'elle soit mise en cache, mais
certains caches PEUVENT violer cette attente (par exemple, lorsque peu de
ou aucune connectivité réseau n'est disponible). Un client peut généralement détecter
qu'une telle réponse a été extraite d'un cache en comparant la Date
en-tête à l’heure actuelle.

Remarque : certains caches HTTP/1.0 sont connus pour violer cette attente
sans fournir aucun avertissement.

Cependant, dans certains cas, il peut être inapproprié qu'un cache
conserver une entité, ou la restituer en réponse à une demande ultérieure
demande. Cela pourrait être dû au fait qu’une transparence sémantique absolue est
jugé nécessaire par l'auteur du service, ou pour des raisons de sécurité ou
considérations de confidentialité. Certaines directives de contrôle du cache sont
donc prévu pour que le serveur puisse indiquer que certains
les entités de ressources, ou des parties de celles-ci, ne doivent pas être mises en cache
indépendamment d’autres considérations.

Notez que la section 14.8 empêche normalement la sauvegarde d'un cache partagé.
et renvoyer une réponse à une demande précédente si cette demande
comprenait un en-tête Authorization.

Une réponse reçue avec un code d'état de 200, 203, 206, 300, 301 ou
410 PEUT être stocké par un cache et utilisé en réponse à une requête ultérieure.
demande, soumise au mécanisme d'expiration, à moins qu'un contrôle de cache
La directive interdit la mise en cache. Cependant, un cache qui ne prend pas en charge
les en-têtes Range et Content-Range NE DOIVENT PAS mettre en cache 206 (Partial
Contenu) réponses.

Une réponse reçue avec tout autre code d'état (par exemple les codes d'état 302
et 307) NE DOIT PAS être retourné dans une réponse à une demande ultérieure
sauf s'il existe des directives de contrôle de cache ou un ou plusieurs autres en-têtes qui
l'autoriser explicitement. Par exemple, il s'agit des éléments suivants : un
En-tête Expire (section 14.21) ; un "max-age", "s-maxage", "doit-
revalidate", "proxy-revalidate", "public" ou "privé" contrôle du cache
directive (article 14.9).








Fielding et coll. Voie des normes [Page 91]
 
RFC 2616 HTTP/1.1 juin 1999


13.5 Construction de réponses à partir des caches

Le but d'un cache HTTP est de stocker les informations reçues dans
réponse aux demandes d’utilisation pour répondre aux demandes futures. Dans
dans de nombreux cas, un cache renvoie simplement les parties appropriées d'un
réponse au demandeur. Cependant, si le cache contient une entrée de cache
sur la base d'une réponse précédente, il devra peut-être combiner des parties d'un nouveau
réponse avec ce qui est contenu dans l’entrée du cache.

13.5.1 En-têtes de bout en bout et saut par saut

Dans le but de définir le comportement des caches et du non-caching
proxys, nous divisons les en-têtes HTTP en deux catégories :

- Les en-têtes de bout en bout, qui sont transmis au final
destinataire d’une demande ou d’une réponse. En-têtes de bout en bout dans
les réponses DOIVENT être stockées dans le cadre d'une entrée de cache et DOIVENT être
transmis dans toute réponse formée à partir d’une entrée de cache.

- Les en-têtes saut par saut, qui n'ont de sens que pour un seul
connexion au niveau du transport et ne sont pas stockés dans les caches ou
transmis par procuration.

Les en-têtes HTTP/1.1 suivants sont des en-têtes saut par saut :

- Connexion
- Rester en vie
- Proxy-Authentifier
- Autorisation par procuration
-TE
- Bandes annonces
- Transfert-Encodage
- Mise à niveau

Tous les autres en-têtes définis par HTTP/1.1 sont des en-têtes de bout en bout.

Les autres en-têtes saut par saut DOIVENT être répertoriés dans un en-tête de connexion,
(section 14.10) à introduire dans HTTP/1.1 (ou version ultérieure).

13.5.2 En-têtes non modifiables

Certaines fonctionnalités du protocole HTTP/1.1, comme Digest
L'authentification dépend de la valeur de certains en-têtes de bout en bout. UN
le proxy transparent NE DEVRAIT PAS modifier un en-tête de bout en bout à moins que le
la définition de cet en-tête l'exige ou le permet spécifiquement.






Fielding et coll. Voie des normes [Page 92]
 
RFC 2616 HTTP/1.1 juin 1999


Un proxy transparent NE DOIT PAS modifier aucun des champs suivants dans un
demande ou réponse, et il NE DOIT PAS ajouter aucun de ces champs sinon
déjà présent :

- Emplacement du contenu

- Contenu-MD5

- ETag

- Dernière modification

Un proxy transparent NE DOIT PAS modifier aucun des champs suivants dans un
réponse:

- Expire

mais il PEUT ajouter n'importe lequel de ces champs s'il n'est pas déjà présent. Si un
L'en-tête Expires est ajouté, il DOIT recevoir une valeur de champ identique à
celui de l’en-tête Date dans cette réponse.

Un mandataire NE DOIT PAS modifier ou ajouter aucun des champs suivants dans un
message qui contient la directive de contrôle de cache sans transformation, ou dans
des demandes:

- Encodage de contenu

- Gamme de contenu

- Type de contenu

Un proxy non transparent PEUT modifier ou ajouter ces champs à un message
cela n'inclut pas la non-transformation, mais s'il le fait, il DOIT ajouter un
Avertissement 214 (Transformation appliquée) si celui-ci n'apparaît pas déjà
dans le message (voir section 14.46).

Attention : une modification inutile des en-têtes de bout en bout pourrait
provoquer des échecs d'authentification si une authentification plus forte
les mécanismes sont introduits dans les versions ultérieures de HTTP. Tel
les mécanismes d'authentification PEUVENT s'appuyer sur les valeurs des champs d'en-tête
pas répertorié ici.

Le champ Content-Length d'une demande ou d'une réponse est ajouté ou supprimé
selon les règles de la section 4.4. Un proxy transparent DOIT
conserver la longueur de l'entité (section 7.2.2) de l'entité-corps,
bien que cela PEUT changer la longueur de transfert (section 4.4).





Fielding et coll. Voie des normes [Page 93]
 
RFC 2616 HTTP/1.1 juin 1999


13.5.3 Combinaison d'en-têtes

Lorsqu'un cache fait une requête de validation à un serveur et que le serveur
fournit une réponse 304 (Non modifié) ou 206 (Contenu partiel)
réponse, le cache construit ensuite une réponse à envoyer au
client demandeur.

Si le code d'état est 304 (Non modifié), le cache utilise l'entité-
corps stocké dans l'entrée du cache en tant qu'entité-corps de ce message sortant
réponse. Si le code d'état est 206 (Contenu partiel) et que l'ETag ou
Les en-têtes Last-Modified correspondent exactement, le cache PEUT combiner les
contenu stocké dans l'entrée du cache avec le nouveau contenu reçu dans
la réponse et utiliser le résultat comme entité-corps de ce message sortant
réponse (voir 13.5.4).

Les en-têtes de bout en bout stockés dans l'entrée du cache sont utilisés pour le
réponse construite, sauf que

- tous les en-têtes d'avertissement stockés avec le code d'avertissement 1xx (voir la section
14.46) DOIT être supprimé de l'entrée du cache et le message transmis
réponse.

- tous les en-têtes d'avertissement stockés avec le code d'avertissement 2xx DOIVENT être conservés
dans l'entrée du cache et la réponse transmise.

- tout en-tête de bout en bout fourni dans la réponse 304 ou 206 DOIT
remplacez les en-têtes correspondants de l’entrée du cache.

À moins que le cache décide de supprimer l'entrée du cache, il DOIT également
remplacez les en-têtes de bout en bout stockés avec l'entrée de cache par
en-têtes correspondants reçus dans la réponse entrante, à l'exception de
En-têtes d’avertissement comme décrit immédiatement ci-dessus. Si un champ d'en-tête-
le nom dans la réponse entrante correspond à plusieurs en-têtes dans le
entrée du cache, tous ces anciens en-têtes DOIVENT être remplacés.

En d’autres termes, l’ensemble des en-têtes de bout en bout reçus dans le
la réponse entrante remplace tous les en-têtes de bout en bout correspondants
stocké avec l'entrée de cache (sauf pour les en-têtes Warning stockés avec
warn-code 1xx, qui sont supprimés même s'ils ne sont pas remplacés).

Remarque : cette règle permet à un serveur d'origine d'utiliser un 304 (non
Modifié) ou une réponse 206 (Contenu partiel) pour mettre à jour un en-tête
associé à une réponse précédente pour la même entité ou sous-
leurs plages, même si cela n'est pas toujours significatif ou
correct de le faire. Cette règle ne permet pas à un serveur d'origine d'utiliser
une réponse 304 (Non modifié) ou 206 (Contenu partiel) à
supprimer entièrement un en-tête qu'il avait fourni avec un précédent
réponse.



Fielding et coll. Voie des normes [Page 94]
 
RFC 2616 HTTP/1.1 juin 1999


13.5.4 Combinaison de plages d'octets

Une réponse peut transférer uniquement une sous-plage d'octets d'une entité.
corps, soit parce que la demande comprenait un ou plusieurs Range
spécifications, ou parce qu'une connexion a été interrompue prématurément. Après
plusieurs de ces transferts, un cache peut avoir reçu plusieurs plages de
le même corps-entité.

Si un cache contient un ensemble non vide de sous-plages stockées pour une entité, et
une réponse entrante transfère une autre sous-plage, le cache PEUT
combiner la nouvelle sous-plage avec l'ensemble existant si les deux éléments suivants
les conditions sont remplies :

- La réponse entrante et l'entrée du cache ont un cache
validateur.

- Les deux validateurs de cache correspondent en utilisant la comparaison forte
fonction (voir section 13.3.3).

Si l'une ou l'autre des exigences n'est pas satisfaite, le cache DOIT utiliser uniquement le plus
réponse partielle récente (basée sur les valeurs de date transmises avec
chaque réponse, et en utilisant la réponse entrante si ces valeurs sont
égale ou manquante), et DOIT éliminer les autres informations partielles.

13.6 Mise en cache des réponses négociées

Utilisation de la négociation de contenu pilotée par le serveur (section 12.1), comme indiqué
par la présence d'un champ d'en-tête Vary dans une réponse, modifie le
conditions et procédure par lesquelles un cache peut utiliser la réponse pour
demandes ultérieures. Voir la section 14.44 pour l'utilisation de l'en-tête Vary.
champ par serveurs.

Un serveur DEVRAIT utiliser le champ d'en-tête Vary pour informer un cache de ce qui
les champs d'en-tête de requête ont été utilisés pour sélectionner parmi plusieurs
représentations d'une réponse pouvant être mise en cache soumise à des contrôles pilotés par le serveur
négociation. L'ensemble des champs d'en-tête nommés par la valeur du champ Vary
est connu sous le nom d'en-têtes de requête "sélection".

Lorsque le cache reçoit une requête ultérieure dont Request-URI
spécifie une ou plusieurs entrées de cache incluant un champ d'en-tête Vary,
le cache NE DOIT PAS utiliser une telle entrée de cache pour construire une réponse à
la nouvelle requête à moins que tous les en-têtes de requête de sélection soient présents
dans la nouvelle requête correspond aux en-têtes de requête stockés correspondants dans
la demande initiale.

Les en-têtes de requête de sélection de deux requêtes sont définis pour correspondre
si et seulement si les en-têtes de requête de sélection dans la première requête peuvent
être transformé en en-têtes de requête de sélection dans la deuxième requête



Fielding et coll. Voie des normes [Page 95]
 
RFC 2616 HTTP/1.1 juin 1999


en ajoutant ou en supprimant un espace blanc linéaire (LWS) aux endroits où cela
est autorisé par la BNF correspondante, et/ou cumulant plusieurs
champs d'en-tête de message avec le même nom de champ suivant les règles
sur les en-têtes de message dans la section 4.2.

Une valeur de champ d'en-tête Vary de "*" ne correspond toujours pas et les
les requêtes sur cette ressource ne peuvent être correctement interprétées que par le
serveur d'origine.

Si les champs d'en-tête de demande de sélection pour l'entrée mise en cache ne
faire correspondre les champs d'en-tête de requête de sélection de la nouvelle requête, puis
le cache NE DOIT PAS utiliser une entrée mise en cache pour satisfaire la demande à moins que
il relaie d'abord la nouvelle requête au serveur d'origine de manière conditionnelle
demande et le serveur répond avec 304 (Non modifié), incluant un
balise d’entité ou Content-Location qui indique l’entité à utiliser.

Si une balise d'entité a été affectée à une représentation mise en cache, la
la demande transmise DEVRAIT être conditionnelle et inclure les balises d'entité
dans un champ d'en-tête If-None-Match à partir de toutes ses entrées de cache pour le
Ressource. Ceci transmet au serveur l'ensemble des entités actuellement
détenu par le cache, de sorte que si l'une de ces entités correspond au
entité demandée, le serveur peut utiliser le champ d'en-tête ETag dans ses 304
(Non modifié) réponse pour indiquer au cache quelle entrée est appropriée.
Si la balise d'entité de la nouvelle réponse correspond à celle d'une réponse existante
entrée, la nouvelle réponse DEVRAIT être utilisée pour mettre à jour les champs d'en-tête de
l'entrée existante et le résultat DOIT être retourné au client.

Si l'une des entrées de cache existantes ne contient qu'un contenu partiel
pour l'entité associée, son étiquette d'entité NE DEVRAIT PAS être incluse dans
le champ d'en-tête If-None-Match, sauf si la demande concerne une plage qui
serait pleinement satisfait de cette entrée.

Si un cache reçoit une réponse réussie dont Content-Location
Le champ correspond à celui d'une entrée de cache existante pour le même Request-
]URI, dont la balise d'entité diffère de celle de l'entrée existante, et
dont la Date est plus récente que celle de l'entrée existante, la
l'entrée existante NE DEVRAIT PAS être renvoyée en réponse à des demandes futures
et DEVRAIT être supprimé du cache.

13.7 Caches partagés et non partagés

Pour des raisons de sécurité et de confidentialité, il est nécessaire d'effectuer une
distinction entre les caches « partagés » et « non-partagés ». Un non partagé
le cache est celui qui n’est accessible qu’à un seul utilisateur. Accessibilité
dans ce cas, DEVRAIT être appliqué par des mécanismes de sécurité appropriés.
Tous les autres caches sont considérés comme « partagés ». D'autres sections de





Fielding et coll. Voie des normes [Page 96]
 
RFC 2616 HTTP/1.1 juin 1999


cette spécification impose certaines contraintes sur le fonctionnement de
caches partagés afin d'éviter la perte de confidentialité ou l'échec de
contrôles d'accès.

13.8 Erreurs ou comportement du cache de réponses incomplet

Un cache qui reçoit une réponse incomplète (par exemple, avec moins
octets de données que ceux spécifiés dans un en-tête Content-Length) PEUT stocker
la réponse. Cependant, le cache DOIT traiter cela comme une erreur partielle.
réponse. Les réponses partielles PEUVENT être combinées comme décrit dans la section
13.5.4 ; le résultat pourrait être une réponse complète ou pourrait encore être
partiel. Un cache NE DOIT PAS renvoyer une réponse partielle à un client
sans le marquer explicitement comme tel, en utilisant le 206 (Partial
Contenu) code d'état. Un cache NE DOIT PAS renvoyer une réponse partielle
en utilisant le code d'état 200 (OK).

Si un cache reçoit une réponse 5xx lors d'une tentative de revalidation d'un
entrée, il PEUT soit transmettre cette réponse au client demandeur,
ou faites comme si le serveur ne répondait pas. Dans ce dernier cas, il PEUT
renvoie une réponse précédemment reçue à moins que l'entrée mise en cache
inclut la directive de contrôle de cache "must-revalidate" (voir la section
14.9).

13.9 Effets secondaires de GET et HEAD

Sauf si le serveur d'origine interdit explicitement la mise en cache de leurs
réponses, l'application des méthodes GET et HEAD à toutes les ressources
NE DEVRAIT PAS avoir d'effets secondaires qui pourraient conduire à un comportement erroné si
ces réponses sont extraites d'un cache. Ils PEUVENT encore avoir un côté
effets secondaires, mais un cache n'est pas nécessaire pour prendre en compte ces effets secondaires dans
ses décisions de mise en cache. Les caches sont toujours censées observer un
restrictions explicites du serveur d'origine sur la mise en cache.

Notons une exception à cette règle : certaines applications ayant
on utilisait traditionnellement les GET et HEAD avec les URL de requête (ceux contenant un
"?" dans la partie rel_path) pour effectuer des opérations avec un côté significatif
effets, les caches NE DOIVENT PAS traiter les réponses à de tels URI comme étant fraîches, à moins que
le serveur fournit un délai d'expiration explicite. Ceci spécifiquement
signifie que les réponses des serveurs HTTP/1.0 pour de tels URI NE DEVRAIENT PAS
être extrait d'une cache. Voir la section 9.1.1 pour des informations connexes.

13.10 Invalidation après mises à jour ou suppressions

L'effet de certaines méthodes effectuées sur une ressource à l'origine
Le serveur peut rendre non-disponible une ou plusieurs entrées de cache existantes.
manifestement invalide. Autrement dit, même s'ils pourraient continuer à l'être
"frais", ils ne reflètent pas exactement ce que le serveur d'origine aurait
revenir pour une nouvelle demande sur cette ressource.



Fielding et coll. Voie des normes [Page 97]
 
RFC 2616 HTTP/1.1 juin 1999


Il n'existe aucun moyen pour le protocole HTTP de garantir que tous ces
les entrées du cache sont marquées comme invalides. Par exemple, la demande que
la raison pour laquelle le changement sur le serveur d'origine n'a peut-être pas été effectué
le proxy où une entrée de cache est stockée. Cependant, plusieurs règles aident
réduire la probabilité de comportements erronés.

Dans cette section, l'expression « invalider une entité » signifie que le
le cache supprimera toutes les instances de cette entité de son
stockage, ou les marquera comme "invalides" et nécessitant un contrôle obligatoire
revalidation avant de pouvoir être restitués en réponse à une demande ultérieure
demande.

Certaines méthodes HTTP DOIVENT provoquer l'invalidation d'une entité par un cache. C'est
soit l'entité référencée par le Request-URI, soit par l'emplacement
ou en-têtes Content-Location (le cas échéant). Ces méthodes sont :

- METTRE

- SUPPRIMER

- POSTE

Afin de prévenir les attaques par déni de service, une invalidation basée sur
sur l'URI dans un en-tête Location ou Content-Location DOIT uniquement être
effectuée si la partie hôte est la même que dans le Request-URI.

Un cache qui transmet les requêtes de méthodes, ce qu'il ne fait pas
comprendre DEVRAIT invalider toutes les entités mentionnées par le
URI de requête.

13.11 Écriture directe obligatoire

Toutes les méthodes susceptibles d'entraîner des modifications du
les ressources du serveur d'origine DOIVENT être écrites via l'origine
serveur. Cela inclut actuellement toutes les méthodes à l'exception de GET et HEAD.
Un cache NE DOIT PAS répondre à une telle requête d'un client avant d'avoir
transmis la requête au serveur entrant, et après avoir reçu un
réponse correspondante du serveur entrant. Cela n'empêche pas
un cache proxy d'envoyer une réponse 100 (Continuer) avant le
le serveur entrant a envoyé sa réponse finale.

L'alternative (connue sous le nom de mise en cache « écriture différée » ou « copie ») n'est pas
autorisé dans HTTP/1.1, en raison de la difficulté de fournir des
les mises à jour et les problèmes liés au serveur, au cache ou au réseau
échec avant la réécriture.






Fielding et coll. Voie des normes [Page 98]
 
RFC 2616 HTTP/1.1 juin 1999


13.12 Remplacement du cache

Si un nouveau cacheable (voir sections 14.9.2, 13.2.5, 13.2.6 et 13.8)
la réponse est reçue d'une ressource alors que toutes les réponses existantes pour
les mêmes ressources sont mises en cache, le cache DEVRAIT utiliser la nouvelle réponse
pour répondre à la demande en cours. Il PEUT l'insérer dans le stockage du cache
et PEUT, s'il répond à toutes les autres exigences, l'utiliser pour répondre à tout
demandes futures qui auraient auparavant provoqué l'ancienne réponse
être retourné. S'il insère la nouvelle réponse dans le stockage en cache,
les règles de la section 13.5.3 s’appliquent.

Remarque : une nouvelle réponse qui a une valeur d'en-tête Date plus ancienne que
les réponses mises en cache existantes ne peuvent pas être mises en cache.

13.13 Listes d'historique

Les agents utilisateurs disposent souvent de mécanismes d'historique, tels que des boutons "Retour" et
des listes d'historique, qui peuvent être utilisées pour réafficher une entité récupérée
plus tôt dans une séance.

Les mécanismes d'historique et les caches sont différents. En particulier l'histoire
les mécanismes NE DEVRAIENT PAS essayer de montrer une vue sémantiquement transparente de
l'état actuel d'une ressource. Il s'agit plutôt d'un mécanisme d'historique
pour montrer exactement ce que l'utilisateur a vu au moment où la ressource a été
récupéré.

Par défaut, aucun délai d'expiration ne s'applique aux mécanismes d'historique.
Si l'entité est toujours stockée, un mécanisme d'historique DEVRAIT afficher
même si l'entité a expiré, sauf si l'utilisateur a spécifiquement
configuré l'agent pour actualiser les documents d'historique expirés.

Cela ne doit pas être interprété comme interdisant au mécanisme historique de
indiquant à l'utilisateur qu'une vue peut être obsolète.

Remarque : si les mécanismes de liste d'historique empêchent inutilement les utilisateurs de
en visualisant des ressources obsolètes, cela aura tendance à forcer les auteurs de services
pour éviter d'utiliser les contrôles d'expiration HTTP et les contrôles de cache lorsque
ils le souhaiteraient autrement. Les auteurs de services peuvent l'envisager
Il est important que les utilisateurs ne reçoivent pas de messages d'erreur ou
messages d'avertissement lorsqu'ils utilisent les commandes de navigation (telles que RETOUR)
pour afficher les ressources précédemment récupérées. Même si parfois tel
les ressources ne doivent pas être mises en cache ou doivent expirer rapidement, l'utilisateur
les considérations d'interface peuvent forcer les auteurs de services à recourir à
d'autres moyens d'empêcher la mise en cache (par exemple, des URL « uniques ») afin
ne pas subir les effets d’un mauvais fonctionnement de l’histoire
mécanismes.





Fielding et coll. Voie des normes [Page 99]
 
RFC 2616 HTTP/1.1 juin 1999


14 Définitions des champs d'en-tête

Cette section définit la syntaxe et la sémantique de tous les standards
Champs d’en-tête HTTP/1.1. Pour les champs d'en-tête d'entité, à la fois l'expéditeur et
destinataire fait référence soit au client, soit au serveur, selon qui
envoie et qui reçoit l'entité.

14.1 Accepter

Le champ d'en-tête de demande Accepter peut être utilisé pour spécifier certains médias
types acceptables pour la réponse. Accepter les en-têtes peut être
utilisé pour indiquer que la demande est spécifiquement limitée à un petit
ensemble de types souhaités, comme dans le cas d'une demande de
image.

Accepter = "Accepter" ":"
#( media-range [ accept-params ] )

plage-média = ( "*/*"
| ( taper "/" "*" )
| (tapez "/" sous-type)
) *( paramètre ";" )
accept-params = ";" "q" "=" qvalue *( accepter-extension )
accepter-extension = ";" jeton [ "=" ( jeton | chaîne entre guillemets ) ]

Le caractère astérisque "*" est utilisé pour regrouper les types de médias en plages,
avec "*/*" indiquant tous les types de médias et "type/*" indiquant tous
sous-types de ce type. La plage multimédia PEUT inclure le type de média
paramètres applicables à cette plage.

Chaque plage multimédia PEUT être suivie d'un ou plusieurs paramètres d'acceptation,
commençant par le paramètre "q" pour indiquer une qualité relative
facteur. Le premier paramètre "q" (le cas échéant) sépare la plage multimédia
paramètre(s) des accept-params. Les facteurs de qualité permettent à l'utilisateur
ou un agent utilisateur pour indiquer le degré relatif de préférence pour cela
plage médiane, en utilisant l’échelle qvalue de 0 à 1 (section 3.9). Le
la valeur par défaut est q=1.

Remarque : Utilisation du nom du paramètre « q » pour séparer le type de média
paramètres d'Accepter les paramètres d'extension est dû à l'historique
pratique. Bien que cela empêche tout paramètre de type de média nommé
"q" d'être utilisé avec une gamme média, on pense qu'un tel événement
peu probable étant donné l'absence de paramètres "q" dans l'IANA
registre des types de médias et utilisation rare de tout type de média
paramètres dans Accepter. Les futurs types de médias sont déconseillés
en enregistrant n'importe quel paramètre nommé "q".





Fielding et coll. Voie des normes [Page 100]
 
RFC 2616 HTTP/1.1 juin 1999


L'exemple

Accepter : audio/* ; q=0,2, audio/basique

DEVRAIT être interprété comme "Je préfère l'audio/basique, mais envoyez-moi n'importe quel audio
tapez s'il s'agit du meilleur disponible après une réduction de qualité de 80 %. »

Si aucun champ d’en-tête Accept n’est présent, alors on suppose que le
le client accepte tous les types de médias. Si un champ d'en-tête Accepter est présent,
et si le serveur ne peut pas envoyer une réponse acceptable
selon la valeur combinée du champ Accepter, alors le serveur DEVRAIT
envoyer une réponse 406 (non acceptable).

Un exemple plus élaboré est

Accepter : texte/plain ; q=0,5, texte/html,
texte/x-dvi ; q=0,8, texte/xc

Verbalement, cela serait interprété comme "text/html et text/xc sont
les types de médias préférés, mais s'ils n'existent pas, envoyez le
text/x-dvi, et si cela n'existe pas, envoyez l'entité text/plain
entité."

Les plages de supports peuvent être remplacées par des plages de supports plus spécifiques ou
types de médias spécifiques. Si plusieurs plages de supports s'appliquent à une plage donnée
type, la référence la plus spécifique est prioritaire. Par exemple,

Accepter : text/*, text/html, text/html;level=1, */*

ont la priorité suivante :

1) texte/html;niveau=1
2) texte/html
3) texte/*
4) */*

Le facteur de qualité du type de média associé à un type donné est
déterminé en trouvant la plage multimédia avec la priorité la plus élevée
qui correspond à ce type. Par exemple,

Accepter : text/*;q=0.3, text/html;q=0.7, text/html;level=1,
texte/html;niveau=2;q=0.4, */*;q=0.5

entraînerait l'association des valeurs suivantes :

texte/html;niveau=1 = 1
texte/html = 0,7
texte/plain = 0,3



Fielding et coll. Voie des normes [Page 101]
 
RFC 2616 HTTP/1.1 juin 1999


image/jpeg = 0,5
texte/html;niveau=2 = 0,4
texte/html;niveau=3 = 0,7

Remarque : Un agent utilisateur peut recevoir un ensemble de qualités par défaut
valeurs pour certaines plages de supports. Cependant, à moins que l'agent utilisateur ne soit
un système fermé qui ne peut pas interagir avec d'autres agents de rendu,
cet ensemble par défaut doit être configurable par l'utilisateur.

14.2 Accepter le jeu de caractères

Le champ d'en-tête de requête Accept-Charset peut être utilisé pour indiquer ce
les jeux de caractères sont acceptables pour la réponse. Ce champ permet
clients capables de comprendre des solutions plus complètes ou plus spécialisées.
des jeux de caractères destinés à signaler cette capacité à un serveur qui est
capable de représenter des documents dans ces jeux de caractères.

Accepter-Charset = "Accepter-Charset" ":"
1#( ( jeu de caractères | "*" )[ ";" "q" "=" qvalue ] )


Les valeurs du jeu de caractères sont décrites dans la section 3.4. Chaque jeu de caractères PEUT
recevoir une valeur de qualité associée qui représente la valeur de l'utilisateur
préférence pour ce jeu de caractères. La valeur par défaut est q=1. Un exemple est

Accepter le jeu de caractères : iso-8859-5, unicode-1-1 ; q = 0,8

La valeur spéciale "*", si présente dans le champ Accept-Charset,
correspond à tous les jeux de caractères (y compris ISO-8859-1) qui ne sont pas
mentionné ailleurs dans le champ Accept-Charset. Si aucun "*" n'est présent
dans un champ Accept-Charset, alors tous les jeux de caractères ne sont pas explicitement
mentionnés obtiennent une valeur de qualité de 0, sauf pour ISO-8859-1, qui obtient
une valeur de qualité de 1 si elle n'est pas explicitement mentionnée.

Si aucun en-tête Accept-Charset n'est présent, la valeur par défaut est que tout
le jeu de caractères est acceptable. Si un en-tête Accept-Charset est présent,
et si le serveur ne peut pas envoyer une réponse acceptable
selon l'en-tête Accept-Charset, alors le serveur DEVRAIT envoyer
une réponse d'erreur avec le code d'état 406 (non acceptable), cependant
l'envoi d'une réponse inacceptable est également autorisé.

14.3 Accepter l'encodage

Le champ d’en-tête de requête Accept-Encoding est similaire à Accept, mais
restreint les codages de contenu (section 3.5) qui sont acceptables dans
la réponse.

Accepter-Encodage = "Accepter-Encodage" ":"



Fielding et coll. Voie des normes [Page 102]
 
RFC 2616 HTTP/1.1 juin 1999


1#( codages [ ";" "q" "=" qvalue ] )
codages = ( codage de contenu | "*" )

Des exemples de son utilisation sont :

Accepter l'encodage : compresser, gzip
Accepter-Encodage :
Accepter-Encodage : *
Accepter l'encodage : compress;q=0,5, gzip;q=1,0
Accepter-Encodage : gzip;q=1.0, identité ; q=0,5, *;q=0

Un serveur teste si un codage de contenu est acceptable, selon
un champ Accept-Encoding, en utilisant ces règles :

1. Si le codage de contenu est l'un des codages de contenu répertoriés dans
le champ Accept-Encoding, alors il est acceptable, à moins qu'il ne soit
accompagné d'une valeur q de 0. (Comme défini dans la section 3.9, un
une valeur de 0 signifie « non acceptable ».)

2. Le symbole spécial "*" dans un champ Accept-Encoding correspond à n'importe quel
le codage de contenu disponible n'est pas explicitement répertorié dans l'en-tête
champ.

3. Si plusieurs codages de contenu sont acceptables, alors le code acceptable
le codage de contenu avec la valeur q non nulle la plus élevée est préféré.

4. Le codage du contenu « identité » est toujours acceptable, sauf si
spécifiquement refusé car le champ Accept-Encoding inclut
"identity;q=0", ou parce que le champ inclut "*;q=0" et ne
n'inclut pas explicitement le codage de contenu « d'identité ». Si la
La valeur du champ Accept-Encoding est vide, alors seulement "l'identité"
l'encodage est acceptable.

Si un champ Accept-Encoding est présent dans une requête, et si le
le serveur ne peut pas envoyer une réponse acceptable selon le
En-tête Accept-Encoding, alors le serveur DEVRAIT envoyer une réponse d'erreur
avec le code d'état 406 (Non acceptable).

Si aucun champ Accept-Encoding n'est présent dans une requête, le serveur PEUT
supposez que le client acceptera tout codage de contenu. Dans ce cas,
si « identité » est l'un des codages de contenu disponibles, alors le
le serveur DEVRAIT utiliser le codage de contenu "identité", à moins qu'il n'ait
informations supplémentaires indiquant qu'un codage de contenu différent est significatif
au client.

Remarque : Si la demande n'inclut pas de champ Accept-Encoding,
et si le codage de contenu « identité » n'est pas disponible, alors
codages de contenu communément compris par les clients HTTP/1.0 (c'est-à-dire,



Fielding et coll. Voie des normes [Page 103]
 
RFC 2616 HTTP/1.1 juin 1999


"gzip" et "compress") sont préférés ; certains clients plus âgés
afficher de manière incorrecte les messages envoyés avec d’autres codages de contenu. Le
Le serveur peut également prendre cette décision sur la base d'informations sur
l'agent utilisateur ou le client particulier.

Remarque : La plupart des applications HTTP/1.0 ne reconnaissent ni n'obéissent aux qvalues.
associés aux codages de contenu. Cela signifie que les qvalues ​​ne seront pas
fonctionnent et ne sont pas autorisés avec x-gzip ou x-compress.

14.4 Accepter la langue

Le champ d'en-tête de requête Accept-Language est similaire à Accept, mais
restreint l'ensemble des langues naturelles qui sont préférées comme langue
réponse à la demande. Les balises de langue sont définies dans la section 3.10.

Accepter-Langue = "Accepter-Langue" ":"
1#( plage de langues [ ";" "q" "=" qvalue ] )
plage de langues = ( ( 1*8ALPHA *( "-" 1*8ALPHA ) ) | "*" )

Chaque plage de langues PEUT recevoir une valeur de qualité associée qui
représente une estimation de la préférence de l'utilisateur pour les langues
spécifié par cette plage. La valeur de qualité par défaut est "q=1". Pour
exemple,

Accepter la langue : da, en-gb;q=0.8, en;q=0.7

signifierait : "Je préfère le danois, mais j'accepterai l'anglais britannique et
d'autres types d'anglais." Une plage de langues correspond à une balise de langue si
il est exactement égal à la balise, ou s'il est exactement égal à un préfixe du
balise de telle sorte que le premier caractère de balise suivant le préfixe soit "-".
La plage spéciale "*", si présente dans le champ Accept-Langue,
correspond à toutes les balises qui ne correspondent à aucune autre plage présente dans le
Champ Accepter la langue.

Remarque : Cette utilisation d'une règle de correspondance de préfixe n'implique pas que
les balises de langue sont attribuées aux langues de telle manière qu'elles soient
toujours vrai que si un utilisateur comprend une langue avec un certain
balise, alors cet utilisateur comprendra également toutes les langues avec des balises
pour lequel cette balise est un préfixe. La règle du préfixe permet simplement au
utilisation de balises de préfixe si tel est le cas.

Le facteur de qualité de la langue attribué à une balise de langue par le
Le champ Accept-Language est la valeur de qualité de la langue la plus longue.
range dans le champ qui correspond à la balise de langue. Si aucune langue-
la plage dans le champ correspond à la balise, le facteur de qualité de la langue
attribué est 0. Si aucun en-tête Accept-Language n'est présent dans le
demande, le serveur




Fielding et coll. Voie des normes [Page 104]
 
RFC 2616 HTTP/1.1 juin 1999


DEVRAIT supposer que toutes les langues sont également acceptables. Si un
L'en-tête Accept-Language est présent, puis toutes les langues qui sont
auxquels un facteur de qualité supérieur à 0 est attribué sont acceptables.

Il pourrait être contraire aux attentes de l'utilisateur en matière de confidentialité
un en-tête Accept-Language avec les préférences linguistiques complètes de
l'utilisateur dans chaque demande. Pour une discussion sur cette question, voir
article 15.1.4.

Comme l'intelligibilité dépend fortement de l'utilisateur individuel, il est
recommandé que les applications clientes fassent le choix de la langue
préférence disponible pour l’utilisateur. Si le choix n'est pas fait
disponible, alors le champ d'en-tête Accept-Language NE DOIT PAS être renseigné dans
la demande.

Remarque : Lorsque vous donnez le choix de la préférence linguistique à
l'utilisateur, nous rappelons aux implémenteurs que les utilisateurs ne sont pas
familier avec les détails de la correspondance linguistique comme décrit ci-dessus,
et devrait fournir des conseils appropriés. A titre d'exemple, les utilisateurs
On pourrait supposer qu'en sélectionnant "en-gb", ils recevront n'importe quel
type de document en anglais si l’anglais britannique n’est pas disponible. UN
L'agent utilisateur pourrait suggérer dans un tel cas d'ajouter "en" pour obtenir le
meilleur comportement de correspondance.

14.5 Plages acceptées

Le champ d'en-tête de réponse Accept-Ranges permet au serveur de
indiquer son acceptation des demandes de portée pour une ressource :

Accept-Ranges = "Accept-Ranges" ":" gammes-acceptables
plages acceptables = 1#range-unit | "aucun"

Les serveurs d'origine qui acceptent les requêtes de plage d'octets PEUVENT envoyer

Plages acceptées : octets

mais ils ne sont pas obligés de le faire. Les clients PEUVENT générer une plage d'octets
requêtes sans avoir reçu cet entête pour la ressource
impliqué. Les unités de plage sont définies à la section 3.12.

Les serveurs qui n'acceptent aucun type de demande de plage pour un
la ressource PEUT envoyer

Plages acceptées : aucune

conseiller au client de ne pas tenter de demande de plage.





Fielding et coll. Voie des normes [Page 105]
 
RFC 2616 HTTP/1.1 juin 1999


14.6 Âge

Le champ d'en-tête de réponse Age transmet l'estimation de l'expéditeur du
le temps écoulé depuis que la réponse (ou sa revalidation) a été
généré sur le serveur d'origine. Une réponse mise en cache est « fraîche » si
son âge ne dépasse pas sa durée de vie fraîcheur. Les valeurs d'âge sont
calculé comme spécifié à la section 13.2.3.

Age = "Âge" ":" valeur d'âge
valeur d'âge = delta-secondes

Les valeurs d'âge sont des entiers décimaux non négatifs, représentant le temps écoulé
secondes.

Si un cache reçoit une valeur supérieure au plus grand positif
entier qu'il peut représenter, ou si l'un de ses calculs d'âge
déborde, il DOIT transmettre un en-tête Age avec une valeur de
2147483648 (2 ^ 31). Un serveur HTTP/1.1 qui inclut un cache DOIT
inclure un champ d'en-tête Age dans chaque réponse générée à partir de son
propre cache. Les caches DEVRAIENT utiliser un type arithmétique d'au moins 31
des morceaux de portée.

14.7 Autoriser

Le champ d’en-tête d’entité Autoriser répertorie l’ensemble des méthodes prises en charge
par la ressource identifiée par le Request-URI. Le but de ceci
ce champ est strictement destiné à informer le destinataire des méthodes valides
associés à la ressource. Un champ d’en-tête Allow DOIT être
présent dans une réponse 405 (Méthode non autorisée).

Autoriser = "Autoriser" ":" #Méthode

Exemple d'utilisation :

Autoriser : GET, HEAD, PUT

Ce champ ne peut pas empêcher un client d'essayer d'autres méthodes.
Cependant, les indications données par la valeur du champ d'en-tête Autoriser
DEVRAIT être suivi. L'ensemble réel des méthodes autorisées est défini
par le serveur d'origine au moment de chaque requête.

Le champ d'en-tête Allow PEUT être fourni avec une demande PUT pour
recommander les méthodes qui seront prises en charge par le nouveau ou le modifié
Ressource. Le serveur n'est pas obligé de prendre en charge ces méthodes et
DEVRAIT inclure un en-tête Allow dans la réponse donnant le réel
méthodes prises en charge.





Fielding et coll. Voie des normes [Page 106]
 
RFC 2616 HTTP/1.1 juin 1999


Un proxy NE DOIT PAS modifier le champ d'en-tête Allow même s'il ne le fait pas.
comprendre toutes les méthodes spécifiées, puisque l'agent utilisateur pourrait
disposer d'autres moyens de communication avec le serveur d'origine.

14.8 Autorisation

Un agent utilisateur qui souhaite s'authentifier auprès d'un serveur...
généralement, mais pas nécessairement, après avoir reçu une réponse 401 - est-ce que
donc en incluant un champ d'en-tête de demande d'autorisation avec le
demande. La valeur du champ Autorisation est constituée d'informations d'identification
contenant les informations d'authentification de l'agent utilisateur pour
le domaine de la ressource demandée.

Autorisation = "Autorisation" ":" identifiants

L'authentification d'accès HTTP est décrite dans « Authentification HTTP :
Authentification d'accès de base et Digest" [43]. Si une demande est
authentifié et un domaine spécifié, les mêmes informations d'identification DEVRAIENT
être valable pour toutes les autres demandes dans ce domaine (en supposant que
le schéma d'authentification lui-même n'exige pas le contraire, tel
comme informations d'identification qui varient en fonction d'une valeur de défi ou de l'utilisation
horloges synchronisées).

Lorsqu'un cache partagé (voir section 13.7) reçoit une requête
contenant un champ Autorisation, il NE DOIT PAS renvoyer le
réponse correspondante comme réponse à toute autre demande, à moins que l'on
des exceptions spécifiques suivantes s’appliquent :

1. Si la réponse inclut le contrôle de cache "s-maxage"
directive, le cache PEUT utiliser cette réponse pour répondre à une
demande ultérieure. Mais (si l'âge maximum spécifié a
passé) un cache proxy DOIT d'abord le revalider avec l'origine
serveur, en utilisant les en-têtes de requête de la nouvelle requête pour permettre
le serveur d'origine pour authentifier la nouvelle requête. (C'est le
comportement défini pour s-maxage.) Si la réponse inclut "s-
maxage=0", le proxy DOIT toujours le revalider avant de le réutiliser
il.

2. Si la réponse inclut le contrôle de cache « doit-revalider »
directive, le cache PEUT utiliser cette réponse pour répondre à une
demande ultérieure. Mais si la réponse est obsolète, tous les caches
DOIT d'abord le revalider auprès du serveur d'origine, en utilisant le
en-têtes de requête de la nouvelle requête pour autoriser le serveur d'origine
pour authentifier la nouvelle demande.

3. Si la réponse inclut la directive de contrôle de cache « public »,
il PEUT être retourné en réponse à toute demande ultérieure.




Fielding et coll. Voie des normes [Page 107]
 
RFC 2616 HTTP/1.1 juin 1999


14.9 Contrôle du cache

Le champ d'en-tête général Cache-Control est utilisé pour spécifier les directives
qui DOIT être respecté par tous les mécanismes de mise en cache le long du
chaîne de requête/réponse. Les directives précisent les comportements destinés à
empêcher les caches d’interférer négativement avec la requête ou
réponse. Ces directives remplacent généralement la mise en cache par défaut
algorithmes. Les directives de cache sont unidirectionnelles dans la mesure où la présence
d'une directive dans une demande n'implique pas que la même directive soit
à donner dans la réponse.

Notez que les caches HTTP/1.0 peuvent ne pas implémenter Cache-Control et
pourrait uniquement implémenter Pragma: no-cache (voir section 14.32).

Les directives de cache DOIVENT être transmises par un proxy ou une passerelle
demande, quelle que soit leur importance pour cette demande,
puisque les directives pourraient être applicables à tous les destinataires tout au long du
chaîne de requête/réponse. Il n'est pas possible de spécifier un cache.
directive pour un cache spécifique.

Cache-Control = "Cache-Control" ":" 1#cache-directive

directive-cache = directive-demande-cache
| directive-réponse-cache

directive de demande de cache =
"sans cache" ; Article 14.9.1
| "pas de magasin" ; Article 14.9.2
| "max-age" "=" delta-secondes ; Articles 14.9.3, 14.9.4
| "max-stale" [ "=" delta-secondes ] ; Article 14.9.3
| "min-fresh" "=" delta-secondes ; Article 14.9.3
| "pas de transformation" ; Article 14.9.5
| "uniquement si mis en cache" ; Article 14.9.4
| extension de cache ; Article 14.9.6

directive-réponse-cache =
"publique" ; Article 14.9.1
| "privé" [ "=" <"> 1#nom-champ <"> ] ; Article 14.9.1
| "pas de cache" [ "=" <"> 1#nom-champ <"> ]; Article 14.9.1
| "pas de magasin" ; Article 14.9.2
| "pas de transformation" ; Article 14.9.5
| "doit-revalider" ; Article 14.9.4
| "proxy-revalidation" ; Article 14.9.4
| "max-age" "=" delta-secondes ; Article 14.9.3
| "s-maxage" "=" delta-secondes ; Article 14.9.3
| extension de cache ; Article 14.9.6

cache-extension = jeton [ "=" ( jeton | chaîne entre guillemets ) ]



Fielding et coll. Voie des normes [Page 108]
 
RFC 2616 HTTP/1.1 juin 1999


Lorsqu'une directive apparaît sans aucun paramètre 1#field-name, le
La directive s’applique à l’ensemble de la demande ou de la réponse. Quand un tel
apparaît avec un paramètre 1#field-name, elle s'applique uniquement à
le ou les champs nommés, et non au reste de la requête ou
réponse. Ce mécanisme prend en charge l'extensibilité ; mises en œuvre de
les futures versions du protocole HTTP pourraient appliquer ces directives à
champs d'en-tête non définis dans HTTP/1.1.

Les directives de contrôle du cache peuvent être décomposées en ces lignes générales
catégories:

- Restrictions sur ce qui peut être mis en cache ; ceux-ci ne peuvent être imposés que par
le serveur d'origine.

- Restrictions sur ce qui peut être stocké par un cache ; ceux-ci peuvent être
imposé soit par le serveur d'origine, soit par l'agent utilisateur.

- Modifications du mécanisme d'expiration de base ; ceux-ci peuvent être
imposé soit par le serveur d'origine, soit par l'agent utilisateur.

- Contrôles de revalidation et de rechargement du cache ; ceux-ci ne peuvent être que
imposé par un agent utilisateur.

- Contrôle de la transformation des entités.

- Extensions du système de mise en cache.

14.9.1 Qu'est-ce qui peut être mis en cache

Par défaut, une réponse peut être mise en cache si les exigences du
méthode de demande, champs d'en-tête de demande et état de la réponse
indique qu'il peut être mis en cache. La section 13.4 résume ces valeurs par défaut
pour la mise en cache. Les directives de réponse Cache-Control suivantes
permettre à un serveur d'origine de remplacer la mise en cache par défaut d'un
réponse:

publique
Indique que la réponse PEUT être mise en cache par n'importe quel cache, même si elle
ne serait normalement pas mis en cache ou ne pourrait être mis en cache que dans un
cache partagé. (Voir également Autorisation, section 14.8, pour
Détails supplémentaires.)

privé
Indique que tout ou partie du message de réponse est destiné à
un seul utilisateur et NE DOIT PAS être mis en cache par un cache partagé. Ce
permet à un serveur d'origine d'indiquer que les parties spécifiées du





Fielding et coll. Voie des normes [Page 109]
 
RFC 2616 HTTP/1.1 juin 1999


Les réponses sont destinées à un seul utilisateur et ne constituent pas une réponse valide.
réponse aux demandes des autres utilisateurs. Un cache privé (non partagé)
PEUT mettre en cache la réponse.

Remarque : Cette utilisation du mot privé contrôle uniquement l'endroit où le
La réponse peut être mise en cache et ne peut pas garantir la confidentialité du
contenu du message.

sans cache
Si la directive no-cache ne spécifie pas de nom de champ, alors un
le cache NE DOIT PAS utiliser la réponse pour satisfaire une requête ultérieure
sans revalidation réussie avec le serveur d'origine. Ce
permet à un serveur d'origine d'empêcher la mise en cache même par les caches qui
ont été configurés pour renvoyer des réponses obsolètes aux demandes des clients.

Si la directive no-cache spécifie un ou plusieurs noms de champs,
alors un cache PEUT utiliser la réponse pour satisfaire une requête ultérieure,
sous réserve de toute autre restriction sur la mise en cache. Cependant, le
les noms de champs spécifiés NE DOIVENT PAS être envoyés dans la réponse à un
demande ultérieure sans revalidation réussie avec l'origine
serveur. Cela permet à un serveur d'origine d'empêcher la réutilisation de
certains champs d'en-tête dans une réponse, tout en permettant la mise en cache
du reste de la réponse.

Remarque : La plupart des caches HTTP/1.0 ne le reconnaîtront pas et n'y obéiront pas.
directif.

14.9.2 Ce qui peut être stocké dans les caches

sans magasin
L'objectif de la directive interdisant les magasins est d'empêcher le
divulgation ou conservation par inadvertance d'informations sensibles (par
exemple, sur les bandes de sauvegarde). La directive interdisant les magasins s'applique aux
message entier, et PEUT être envoyé soit dans une réponse, soit dans un
demande. S'il est envoyé dans une requête, un cache NE DOIT PAS stocker aucune partie de
soit cette demande, soit toute réponse à celle-ci. Si vous recevez une réponse,
un cache NE DOIT PAS stocker aucune partie de cette réponse ou du
demande qui l’a suscité. Cette directive s'applique aussi bien aux non-
caches partagés et partagés. « NE DOIT PAS stocker » dans ce contexte signifie
que le cache NE DOIT PAS stocker intentionnellement les informations dans
stockage non volatile et DOIT faire de son mieux pour
supprimer les informations du stockage volatile aussi rapidement que possible
possible après l'avoir transmis.

Même lorsque cette directive est associée à une réponse, les utilisateurs
pourrait stocker explicitement une telle réponse en dehors de la mise en cache
système (par exemple, avec une boîte de dialogue "Enregistrer sous"). Les tampons d'historique PEUVENT stocker
ces réponses dans le cadre de leur fonctionnement normal.



Fielding et coll. Voie des normes [Page 110]
 
RFC 2616 HTTP/1.1 juin 1999


Le but de cette directive est de répondre aux exigences énoncées
de certains utilisateurs et auteurs de services préoccupés par
divulgations accidentelles d’informations via des accès imprévus à
mettre en cache les structures de données. Même si l'utilisation de cette directive pourrait
améliorer la confidentialité dans certains cas, nous prévenons que ce n'est en aucun cas
manière un mécanisme fiable ou suffisant pour garantir la confidentialité. Dans
des caches particuliers, malveillants ou compromis peuvent ne pas reconnaître ou
obéissez à cette directive, et les réseaux de communication pourraient être
vulnérables aux écoutes clandestines.

14.9.3 Modifications du mécanisme d'expiration de base

L'heure d'expiration d'une entité PEUT être spécifiée par l'origine
serveur à l’aide de l’en-tête Expires (voir section 14.21). Alternativement,
il PEUT être spécifié en utilisant la directive max-age dans une réponse. Quand
la directive max-age cache-control est présente dans une réponse mise en cache,
la réponse est périmée si son âge actuel est supérieur à l'âge
valeur donnée (en secondes) lors d'une nouvelle requête pour celle-ci
Ressource. La directive max-age sur une réponse implique que le
la réponse peut être mise en cache (c'est-à-dire "publique") à moins qu'une autre réponse, plus
Une directive de cache restrictive est également présente.

Si une réponse inclut à la fois un en-tête Expires et un max-age
directive, la directive max-age remplace l'en-tête Expires, même
si l'en-tête Expires est plus restrictif. Cette règle permet une origine
serveur de fournir, pour une réponse donnée, un délai d'expiration plus long pour
un cache HTTP/1.1 (ou version ultérieure) plutôt qu'un cache HTTP/1.0. Cela pourrait être
utile si certains caches HTTP/1.0 calculent mal les âges ou
délais d'expiration, peut-être dus à des horloges désynchronisées.

De nombreuses implémentations de cache HTTP/1.0 traiteront une valeur Expires qui
est inférieur ou égal à la valeur de la date de réponse comme étant équivalente
à la directive de réponse Cache-Control "no-cache". Si un HTTP/1.1
le cache reçoit une telle réponse, et la réponse n'inclut pas de
champ d’en-tête Cache-Control, il DEVRAIT considérer la réponse comme étant
non mis en cache afin de conserver la compatibilité avec les serveurs HTTP/1.0.

Remarque : Un serveur d'origine peut souhaiter utiliser un protocole HTTP relativement nouveau.
fonctionnalité de contrôle du cache, telle que la directive "privée", sur un
réseau comprenant des caches plus anciens qui ne comprennent pas cela
fonctionnalité. Le serveur d'origine devra combiner la nouvelle fonctionnalité
avec un champ Expire dont la valeur est inférieure ou égale à la
Valeur de date. Cela empêchera les anciens caches d'être incorrectement
mettre en cache la réponse.







Fielding et coll. Voie des normes [Page 111]
 
RFC 2616 HTTP/1.1 juin 1999


s-maxage
Si une réponse inclut une directive s-maxage, alors pour un partage
cache (mais pas pour un cache privé), l'âge maximum spécifié par
cette directive remplace l'âge maximum spécifié soit par le
max-age ou l'en-tête Expires. La directive s-maxage
implique également la sémantique de la directive proxy-revalidate (voir
section 14.9.4), c'est-à-dire que le cache partagé ne doit pas utiliser le
entrée après qu'elle soit devenue obsolète pour répondre à une demande ultérieure
sans le revalider au préalable auprès du serveur d'origine. Le s-
La directive maxage est toujours ignorée par un cache privé.

Notez que la plupart des caches plus anciens, non conformes à cette spécification,
n'implémentez aucune directive de contrôle de cache. Un serveur d'origine
souhaitant utiliser une directive de contrôle de cache qui restreint, mais ne le fait pas
empêcher, la mise en cache par un cache compatible HTTP/1.1 PEUT exploiter le
l'exigence que la directive max-age remplace l'en-tête Expires,
et le fait que les caches pré-compatibles HTTP/1.1 ne respectent pas les
directive sur l'âge maximum.

D'autres directives permettent à un agent utilisateur de modifier l'expiration de base
mécanisme. Ces directives PEUVENT être spécifiées sur une requête :

âge maximum
Indique que le client est prêt à accepter une réponse dont
l'âge n'est pas supérieur au temps spécifié en secondes. Sauf si max-
Une directive périmée est également incluse, le client n'est pas disposé à
acceptez une réponse obsolète.

min-frais
Indique que le client est prêt à accepter une réponse dont
La durée de vie de la fraîcheur n'est pas inférieure à son âge actuel plus le
temps spécifié en secondes. Autrement dit, le client veut une réponse
qui sera encore frais pendant au moins le nombre spécifié de
secondes.

max-périmé
Indique que le client est prêt à accepter une réponse qui a
a dépassé son délai d'expiration. Si max-stale se voit attribuer une valeur,
alors le client est prêt à accepter une réponse qui a dépassé
son délai d'expiration pas plus que le nombre spécifié de
secondes. Si aucune valeur n'est attribuée à max-stale, alors le client est
prêt à accepter une réponse obsolète, quel que soit son âge.

Si un cache renvoie une réponse périmée, soit à cause d'un message max-stale
directive sur une requête, ou parce que le cache est configuré pour
ignorer le délai d'expiration d'une réponse, le cache DOIT attacher un
En-tête d'avertissement vers la réponse obsolète, en utilisant l'avertissement 110 (la réponse est
vicié).



Fielding et coll. Voie des normes [Page 112]
 
RFC 2616 HTTP/1.1 juin 1999


Un cache PEUT être configuré pour renvoyer des réponses périmées sans
validation, mais seulement si cela n'entre en conflit avec aucun niveau "MUST"
exigences concernant la validation du cache (par exemple, un "must-revalidate"
directive de contrôle de cache).

Si la nouvelle demande et l'entrée mise en cache incluent "max-age"
directives, alors la moindre des deux valeurs est utilisée pour déterminer
la fraîcheur de l'entrée mise en cache pour cette demande.

14.9.4 Contrôles de revalidation et de rechargement du cache

Parfois, un agent utilisateur peut vouloir ou devoir insister pour qu'un cache
revalider son entrée de cache auprès du serveur d'origine (et pas seulement avec
le cache suivant le long du chemin vers le serveur d'origine), ou pour recharger son
entrée de cache du serveur d'origine. La revalidation de bout en bout peut être
nécessaire si le cache ou le serveur d'origine a surestimé
le délai d'expiration de la réponse mise en cache. Le rechargement de bout en bout peut être
nécessaire si l’entrée du cache est corrompue pour une raison quelconque.

Une revalidation de bout en bout peut être demandée soit lorsque le client le fait
ne pas avoir sa propre copie en cache locale, auquel cas nous l'appelons
"revalidation de bout en bout non spécifiée", ou lorsque le client dispose d'un
copie locale en cache, auquel cas nous l'appelons « copie spécifique de bout en bout »
revalidation."

Le client peut spécifier ces trois types d'actions à l'aide de Cache-
Directives de demande de contrôle :

Rechargement de bout en bout
La requête inclut une directive de contrôle de cache "no-cache" ou, par exemple
compatibilité avec les clients HTTP/1.0, "Pragma : no-cache". Champ
les noms NE DOIVENT PAS être inclus avec la directive no-cache dans un
demande. Le serveur NE DOIT PAS utiliser de copie mise en cache lorsqu'il répond à
une telle demande.

Revalidation spécifique de bout en bout
La requête inclut une directive de contrôle de cache "max-age=0", qui
force chaque cache le long du chemin vers le serveur d'origine à
revalider sa propre entrée, le cas échéant, avec le prochain cache ou serveur.
La requête initiale comprend une condition de validation du cache avec
le validateur actuel du client.

Revalidation de bout en bout non spécifiée
La requête inclut la directive de contrôle de cache "max-age=0", qui
force chaque cache le long du chemin vers le serveur d'origine à
revalider sa propre entrée, le cas échéant, avec le prochain cache ou serveur.
La requête initiale n'inclut pas de validation de cache




Fielding et coll. Voie des normes [Page 113]
 
RFC 2616 HTTP/1.1 juin 1999


conditionnel; le premier cache le long du chemin (le cas échéant) qui contient un
l'entrée de cache pour cette ressource inclut un processus de validation du cache
conditionnel avec son validateur actuel.

âge maximum
Lorsqu'un cache intermédiaire est forcé, au moyen d'un max-age=0
directive, pour revalider sa propre entrée de cache, et le client a
fourni son propre validateur dans la requête, le validateur fourni
peut différer du validateur actuellement stocké avec le cache
entrée. Dans ce cas, le cache PEUT utiliser l'un ou l'autre des validateurs pour créer
sa propre demande sans affecter la transparence sémantique.

Cependant, le choix du validateur peut affecter les performances. Le
la meilleure approche est que le cache intermédiaire utilise le sien
validateur lors de sa demande. Si le serveur répond par 304
(Non modifié), alors le cache peut renvoyer sa copie désormais validée
au client avec une réponse 200 (OK). Si le serveur répond avec
une nouvelle entité et un validateur de cache, cependant, le cache intermédiaire
peut comparer le validateur renvoyé avec celui fourni dans le
demande du client, en utilisant la fonction de comparaison forte. Si la
le validateur du client est égal à celui du serveur d'origine, alors le
le cache intermédiaire renvoie simplement 304 (non modifié). Sinon,
il renvoie la nouvelle entité avec une réponse 200 (OK).

Si une requête inclut la directive no-cache, elle NE DEVRAIT PAS
inclure min-fresh, max-stale ou max-age.

seulement si mis en cache
Dans certains cas, comme lorsque le réseau est extrêmement médiocre
connectivité, un client peut souhaiter qu'un cache renvoie uniquement ces
réponses qu'il a actuellement stockées, et de ne pas recharger ou
revalider avec le serveur d'origine. Pour ce faire, le client peut
inclure la directive only-if-cached dans une requête. S'il reçoit
cette directive, un cache DEVRAIT soit répondre en utilisant une entrée mise en cache
qui est cohérent avec les autres contraintes de la demande, ou
répondez avec un statut 504 (Gateway Timeout). Cependant, si un groupe
des caches est exploité comme un système unifié avec de bonnes performances internes
connectivité, une telle demande PEUT être transmise au sein de ce groupe de
caches.

il faut revalider
Parce qu'un cache PEUT être configuré pour ignorer les informations spécifiées par un serveur
délai d'expiration, et parce qu'une demande client PEUT inclure un délai maximum-
directive obsolète (qui a un effet similaire), le protocole également
inclut un mécanisme permettant au serveur d'origine d'exiger une revalidation
d'une entrée de cache lors de toute utilisation ultérieure. Quand faut-il revalider
directive est présente dans une réponse reçue par un cache, ce cache
NE DOIT PAS utiliser l'entrée une fois qu'elle est devenue obsolète pour répondre à une



Fielding et coll. Voie des normes [Page 114]
 
RFC 2616 HTTP/1.1 juin 1999


demande ultérieure sans la revalider au préalable avec l'origine
serveur. (C'est-à-dire que le cache DOIT effectuer une revalidation de bout en bout tous les
heure, si, basée uniquement sur l'expiration ou l'âge maximum du serveur d'origine
valeur, la réponse mise en cache est obsolète.)

La directive à revalider est nécessaire pour soutenir des
fonctionnement pour certaines fonctionnalités du protocole. En toutes circonstances un
Le cache HTTP/1.1 DOIT obéir à la directive must-revalidate ; dans
en particulier, si le cache ne peut pas atteindre le serveur d'origine pour quelque raison que ce soit.
raison, il DOIT générer une réponse 504 (Gateway Timeout).

Les serveurs DEVRAIENT envoyer la directive must-revalidate si et seulement si
le fait de ne pas revalider une demande adressée à l'entité pourrait entraîner
opération incorrecte, telle qu'une opération financière silencieusement non exécutée
transaction. Les destinataires NE DOIVENT PAS entreprendre d'action automatisée qui
viole cette directive et NE DOIT PAS fournir automatiquement un
copie non validée de l’entité si la revalidation échoue.

Bien que cela ne soit pas recommandé, les agents utilisateurs opérant sous
des contraintes de connectivité sévères PEUVENT violer cette directive mais, si
donc, DOIT avertir explicitement l'utilisateur qu'une réponse non validée a
été fournis. L'avertissement DOIT être fourni sur chaque
accès, et DEVRAIT exiger une confirmation explicite de l'utilisateur.

proxy-revalidation
La directive proxy-revalidate a la même signification que le must-
directive de revalidation, sauf qu'elle ne s'applique pas aux
caches d'agent utilisateur. Il peut être utilisé en réponse à un
requête authentifiée pour permettre au cache de l'utilisateur de stocker et
renvoyer plus tard la réponse sans avoir besoin de la revalider (puisque
il a déjà été authentifié une fois par cet utilisateur), tout en étant
exiger que les proxys qui desservent de nombreux utilisateurs se revalident à chaque fois
(afin de s'assurer que chaque utilisateur a été authentifié).
Notez que ces réponses authentifiées nécessitent également le cache public
directive de contrôle afin de permettre leur mise en cache.

14.9.5 Directive de non-transformation

pas de transformation
Les implémenteurs de caches intermédiaires (proxy) l'ont trouvé utile
pour convertir le type de média de certains corps d'entité. Un non-
un proxy transparent pourrait, par exemple, convertir entre image
formats afin d'économiser de l'espace cache ou de réduire la quantité de
trafic sur une liaison lente.

De sérieux problèmes opérationnels surviennent cependant lorsque ces
les transformations sont appliquées aux organes de l'entité destinés à certains
types d'applications. Par exemple, les demandes d'autorisation médicale



Fielding et coll. Voie des normes [Page 115]
 
RFC 2616 HTTP/1.1 juin 1999


l'imagerie, l'analyse de données scientifiques et ceux utilisant de bout en bout
authentification, tout dépend de la réception d'un corps d'entité qui est peu
pour un bit identique au corps-entité d'origine.

Par conséquent, si un message inclut la directive no-transform, un
le cache intermédiaire ou le proxy NE DOIT PAS modifier les en-têtes qui sont
répertoriés à la section 13.5.2 comme étant soumis à l'obligation de non-transformation
directif. Cela implique que le cache ou le proxy NE DOIT PAS changer
tout aspect de l'entité-corps spécifié par ces en-têtes,
y compris la valeur de l’entité-corps elle-même.

14.9.6 Extensions de contrôle du cache

Le champ d'en-tête Cache-Control peut être étendu grâce à l'utilisation d'un
ou plusieurs jetons d'extension de cache, chacun avec une valeur attribuée facultative.
Les extensions informationnelles (celles qui ne nécessitent pas de changement de
comportement du cache) PEUT être ajouté sans changer la sémantique des autres
directives. Les extensions comportementales sont conçues pour fonctionner en agissant comme
modificateurs à la base existante de directives de cache. Le nouveau
directive et la directive standard sont fournies, de telle sorte que
les applications qui ne comprennent pas la nouvelle directive seront par défaut
au comportement spécifié par la directive standard, et ceux qui
comprendre que la nouvelle directive la reconnaîtra comme modifiant le
exigences associées à la directive standard. De cette façon,
des extensions aux directives de contrôle de cache peuvent être faites sans
nécessitant des modifications du protocole de base.

Ce mécanisme d'extension dépend d'un cache HTTP obéissant à toutes les
directives de contrôle de cache définies pour sa version HTTP native, obéissant
certaines extensions, et en ignorant toutes les directives qu'il ne fait pas
comprendre.

Par exemple, considérons une nouvelle directive de réponse hypothétique appelée
communauté qui agit comme un modificateur de la directive privée. Nous
définir cette nouvelle directive comme signifiant qu'en plus de tout
cache, tout cache partagé uniquement par les membres de la communauté
nommé dans sa valeur peut mettre en cache la réponse. Un serveur d'origine
souhaitant permettre à la communauté UCI d'utiliser un site autrement privé
réponse dans leur(s) cache(s) partagé(s) pourrait le faire en incluant

Cache-Control : privé, communauté="UCI"

Un cache voyant ce champ d'en-tête agira correctement même si le cache
ne comprend pas l'extension de cache communautaire, car elle le fera également
voir et comprendre la directive privée et donc passer par défaut au coffre-fort
comportement.





Fielding et coll. Voie des normes [Page 116]
 
RFC 2616 HTTP/1.1 juin 1999


Les directives de cache non reconnues DOIVENT être ignorées ; on suppose que tout
La directive de cache susceptible d'être non reconnue par un cache HTTP/1.1 sera
être combiné avec des directives standards (ou la valeur par défaut de la réponse)
capacité de cache) de sorte que le comportement du cache reste minimal
corriger même si le cache ne comprend pas la ou les extensions.

14.10 Connexion

Le champ d'en-tête général Connexion permet à l'expéditeur de spécifier
options souhaitées pour cette connexion particulière et NE DOIVENT PAS
être communiqués par des proxys via d'autres connexions.

L'en-tête Connection a la grammaire suivante :

Connexion = "Connexion" ":" 1#(jeton de connexion)
jeton de connexion = jeton

Les proxys HTTP/1.1 DOIVENT analyser le champ d'en-tête de connexion avant un
Le message est transmis et, pour chaque jeton de connexion dans ce champ,
supprimez tout champ d'en-tête du message portant le même nom que le
jeton de connexion. Les options de connexion sont signalées par la présence de
un jeton de connexion dans le champ d'en-tête Connection, et non par aucun
champ(s) d'en-tête supplémentaire(s) correspondant(s), puisque l'en-tête supplémentaire
Le champ ne peut pas être envoyé s'il n'y a aucun paramètre associé à ce champ.
option de connexion.

Les en-têtes de message répertoriés dans l'en-tête de connexion NE DOIVENT PAS inclure
en-têtes de bout en bout, tels que Cache-Control.

HTTP/1.1 définit l'option de connexion « fermer » pour que l'expéditeur
signaler que la connexion sera fermée une fois le processus terminé.
réponse. Par exemple,

Connexion : fermer

dans les champs d'en-tête de demande ou de réponse indique que
la connexion NE DEVRAIT PAS être considérée comme « persistante » (section 8.1)
une fois la demande/réponse en cours terminée.

Les applications HTTP/1.1 qui ne prennent pas en charge les connexions persistantes DOIVENT
incluez l’option de connexion « fermer » dans chaque message.

Un système recevant un message HTTP/1.0 (ou version inférieure) qui
inclut un en-tête de connexion DOIT, pour chaque jeton de connexion dans ce
champ, supprimez et ignorez tout champ d’en-tête du message avec
le même nom que le jeton de connexion. Cela protège contre les erreurs
transmission de ces champs d’en-tête par des proxys pré-HTTP/1.1. Voir section
19.6.2.



Fielding et coll. Voie des normes [Page 117]
 
RFC 2616 HTTP/1.1 juin 1999


14.11 Codage de contenu

Le champ d’en-tête d’entité Content-Encoding est utilisé comme modificateur du
type de support. Lorsqu'elle est présente, sa valeur indique quel contenu supplémentaire
les codages ont été appliqués à l'entité-corps, et donc quel décodage
des mécanismes doivent être appliqués afin d’obtenir le type de média
référencé par le champ d’en-tête Content-Type. L'encodage du contenu est
principalement utilisé pour permettre à un document d'être compressé sans perdre
l'identité de son type de média sous-jacent.

Content-Encoding = "Content-Encoding" ":" 1#content-coding

Les codages de contenu sont définis à la section 3.5. Un exemple de son utilisation est

Encodage du contenu : gzip

Le codage du contenu est une caractéristique de l'entité identifiée par
l'URI de requête. Généralement, le corps de l'entité est stocké avec ce
encodage et n’est décodé qu’avant le rendu ou une utilisation analogue.
Cependant, un proxy non transparent PEUT modifier le codage du contenu si le
le nouveau codage est jugé acceptable par le destinataire, à moins que le
La directive de contrôle de cache "no-transform" est présente dans le message.

Si le codage du contenu d'une entité n'est pas « l'identité », alors le
La réponse DOIT inclure un en-tête d'entité Content-Encoding (section
14.11) qui répertorie le(s) codage(s) de contenu non identitaire utilisé(s).

Si le codage du contenu d'une entité dans un message de requête n'est pas
acceptable pour le serveur d'origine, le serveur DEVRAIT répondre avec un
code d'état 415 (type de support non pris en charge).

Si plusieurs encodages ont été appliqués à une entité, le contenu
les codages DOIVENT être répertoriés dans l’ordre dans lequel ils ont été appliqués.
Des informations supplémentaires sur les paramètres de codage PEUVENT être fournies
par d'autres champs d'en-tête d'entité non définis par cette spécification.

14.12 Contenu-Langue

Le champ d’en-tête d’entité Content-Language décrit le
langue(s) du public visé pour l'entité ci-jointe. Note
que cela pourrait ne pas être équivalent à toutes les langues utilisées au sein
l’entité-corps.

Content-Language = "Content-Language" ":" 1#langue-tag







Fielding et coll. Voie des normes [Page 118]
 
RFC 2616 HTTP/1.1 juin 1999


Les balises de langue sont définies dans la section 3.10. Le but premier de
Le langage contenu doit permettre à un utilisateur d'identifier et de différencier
entités selon la langue préférée de l'utilisateur. Ainsi, si le
le contenu du corps est destiné uniquement à un public connaissant le danois, le
le champ approprié est

Contenu-Langue : da

Si aucun Content-Language n'est spécifié, la valeur par défaut est que le contenu
est destiné à tous les publics linguistiques. Cela pourrait signifier que le
l'expéditeur ne le considère pas comme spécifique à une langue naturelle,
ou que l'expéditeur ne sait pas à quelle langue il est destiné.

Plusieurs langues PEUVENT être répertoriées pour le contenu destiné à
plusieurs publics. Par exemple, une interprétation du « Traité de
Waitangi", présenté simultanément en version originale maori et anglaise
versions, nécessiteraient

Langue du contenu : mi, en

Cependant, ce n'est que parce que plusieurs langues sont présentes au sein d'une entité
ne signifie pas qu’il soit destiné à des publics linguistiques multiples.
Un exemple serait un manuel d'introduction à la langue pour débutants, tel que "A First
Leçon de Latin", qui est clairement destinée à être utilisée par un
Public anglophone. Dans ce cas, le Content-Language serait
n'inclure correctement que "en".

Content-Language PEUT être appliqué à n'importe quel type de média -- ce n'est pas le cas
limité aux documents textuels.

14.13 Longueur du contenu

Le champ d'en-tête d'entité Content-Length indique la taille du
entité-corps, en nombre décimal d'OCTET, envoyés au destinataire ou,
dans le cas de la méthode HEAD, la taille de l'entité-corps qui
aurait été envoyé si la demande avait été un GET.

Contenu-Longueur = "Contenu-Longueur" ":" 1*CHIFFRE

Un exemple est

Longueur du contenu : 3495

Les applications DEVRAIENT utiliser ce champ pour indiquer la longueur de transfert de
le corps du message, sauf si cela est interdit par les règles de la section
4.4.





Fielding et coll. Voie des normes [Page 119]
 
RFC 2616 HTTP/1.1 juin 1999


Toute longueur de contenu supérieure ou égale à zéro est une valeur valide.
La section 4.4 décrit comment déterminer la longueur d'un corps de message
si une longueur de contenu n'est pas donnée.

Notez que la signification de ce champ est très différente de celle
la définition correspondante dans MIME, où il s'agit d'un champ facultatif
utilisé dans le type de contenu "message/corps-externe". En HTTP, il
DEVRAIT être envoyé chaque fois que la longueur du message peut être déterminée avant
être transféré, sauf si cela est interdit par les règles du
rubrique 4.4.

14.14 Emplacement du contenu

Le champ d’en-tête d’entité Content-Location PEUT être utilisé pour fournir le
emplacement de la ressource pour l'entité incluse dans le message lorsque celui-ci
l'entité est accessible à partir d'un emplacement distinct de celui demandé
l'URI de la ressource. Un serveur DEVRAIT fournir un emplacement de contenu pour le
variante correspondant à l'entité de réponse ; surtout dans le cas
où une ressource est associée à plusieurs entités, et celles-ci
les entités ont en fait des emplacements distincts par lesquels elles peuvent être
accessible individuellement, le serveur DEVRAIT fournir un emplacement de contenu
pour la variante particulière qui est renvoyée.

Emplacement-Contenu = "Emplacement-Contenu" ":"
( URI absolu | URI relatif )

La valeur de Content-Location définit également l'URI de base pour le
entité.

La valeur Content-Location ne remplace pas la valeur d'origine
URI demandé ; ce n'est qu'une indication de l'emplacement de la ressource
correspondant à cette entité particulière au moment de la demande.
Les requêtes futures PEUVENT spécifier l'URI Content-Location comme requête-
URI si le désir est d’identifier la source de ce particulier
entité.

Un cache ne peut pas supposer qu'une entité avec un Content-Location
différent de l'URI utilisé pour le récupérer, il peut être utilisé pour répondre à
demandes ultérieures sur cet URI de localisation de contenu. Cependant, le contenu-
L'emplacement peut être utilisé pour différencier plusieurs entités
récupéré à partir d'une seule ressource demandée, comme décrit dans la section
13.6.

Si le Content-Location est un URI relatif, l'URI relatif est
interprété par rapport au Request-URI.

La signification de l'en-tête Content-Location dans les requêtes PUT ou POST est
indéfini; les serveurs sont libres de l'ignorer dans ces cas-là.



Fielding et coll. Voie des normes [Page 120]
 
RFC 2616 HTTP/1.1 juin 1999


14.15 Contenu-MD5

Le champ d'en-tête d'entité Content-MD5, tel que défini dans la RFC 1864 [23], est
un résumé MD5 de l'entité-corps dans le but de fournir un
vérification de l'intégrité du message (MIC) de bout en bout du corps de l'entité. (Pas de thé
MIC est bon pour détecter les modifications accidentelles du corps de l'entité
en transit, mais n'est pas à l'épreuve des attaques malveillantes.)

Contenu-MD5 = "Contenu-MD5" ":" md5-digest
md5-digest = <base64 du résumé MD5 128 bits selon RFC 1864>

Le champ d'en-tête Content-MD5 PEUT être généré par un serveur d'origine ou
client pour fonctionner comme un contrôle d’intégrité de l’entité-corps. Seulement
les serveurs ou clients d'origine PEUVENT générer le champ d'en-tête Content-MD5 ;
les proxys et les passerelles NE DOIVENT PAS le générer, car cela mettrait en échec son
valeur en tant que contrôle d’intégrité de bout en bout. Tout destinataire de l'entité-
corps, y compris les passerelles et les mandataires, PEUT vérifier que la valeur du résumé
dans ce champ d'en-tête correspond à celui de l'entité-corps tel que reçu.

Le résumé MD5 est calculé sur la base du contenu du corps de l'entité,
y compris tout codage de contenu qui a été appliqué, mais à l'exclusion
tout codage de transfert appliqué au corps du message. Si le message est
reçu avec un codage de transfert, ce codage DOIT être supprimé
avant de vérifier la valeur Content-MD5 par rapport à l'entité reçue.

Cela a pour résultat que le résumé est calculé sur les octets du
entité-corps exactement comme et dans l'ordre dans lequel ils seraient envoyés si
aucun codage de transfert n’était appliqué.

HTTP étend la RFC 1864 pour permettre au résumé d'être calculé pour MIME
types de médias composites (par exemple, multipart/* et message/rfc822), mais
cela ne change pas la façon dont le résumé est calculé comme défini dans le
paragraphe précédent.

Il y a plusieurs conséquences à cela. L'entité-corps pour composite
les types PEUVENT contenir de nombreuses parties de corps, chacune avec son propre MIME et HTTP
en-têtes (y compris Content-MD5, Content-Transfer-Encoding et
En-têtes Content-Encoding). Si une partie du corps a un Content-Transfer-
Encoding ou Content-Encoding, il est supposé que le contenu
de la partie du corps a reçu le codage appliqué, et la partie du corps est
inclus dans le résumé Content-MD5 tel quel, c'est-à-dire après le
application. Le champ d’en-tête Transfer-Encoding n’est pas autorisé dans
parties du corps.

La conversion de tous les sauts de ligne en CRLF NE DOIT PAS être effectuée avant
calculer ou vérifier le résumé : la convention de saut de ligne utilisée dans
le texte effectivement transmis DOIT rester inchangé lors du calcul
le résumé.



Fielding et coll. Voie des normes [Page 121]
 
RFC 2616 HTTP/1.1 juin 1999


Remarque : bien que la définition de Content-MD5 soit exactement la même pour
HTTP comme dans la RFC 1864 pour les corps d'entité MIME, il existe plusieurs manières
dans lequel l'application de Content-MD5 aux corps-entités HTTP
diffère de son application aux corps-entités MIME. L'un est que
HTTP, contrairement à MIME, n'utilise pas Content-Transfer-Encoding, et
utilise Transfer-Encoding et Content-Encoding. Un autre est que
HTTP utilise plus fréquemment des types de contenu binaires que MIME, il est donc
il convient de noter que, dans de tels cas, l'ordre des octets utilisé pour calculer
le résumé est l'ordre des octets de transmission défini pour le type.
Enfin, HTTP permet la transmission de types de texte avec plusieurs
conventions de saut de ligne et pas seulement la forme canonique utilisant CRLF.

14.16 Gamme de contenu

L'en-tête d'entité Content-Range est envoyé avec un corps d'entité partiel à
préciser où dans l'entité-corps complet le corps partiel doit être
appliqué. Les unités de plage sont définies à la section 3.12.

Content-Range = "Content-Range" ":" content-range-spec

content-range-spec = octet-content-range-spec
byte-content-range-spec = octets-unité SP
octet-range-resp-spec "/"
( longueur de l'instance | "*" )

byte-range-resp-spec = (premier octet-pos "-" dernier octet-pos)
| "*"
longueur d'instance = 1*CHIFFRE

L'en-tête DEVRAIT indiquer la longueur totale du corps d'entité complet,
à moins que cette longueur ne soit inconnue ou difficile à déterminer. L'astérisque
Le caractère "*" signifie que la longueur de l'instance est inconnue à ce moment-là
quand la réponse a été générée.

Contrairement aux valeurs de spécificateur de plages d'octets (voir section 14.35.1), un octet-
range-resp-spec DOIT spécifier une seule plage et DOIT contenir
positions absolues des octets pour le premier et le dernier octet du
gamme.

Une byte-content-range-spec avec une byte-range-resp-spec dont le dernier
La valeur byte-pos est inférieure à sa valeur du premier octet-pos, ou dont
la valeur de longueur d'instance est inférieure ou égale à sa position du dernier octet
valeur, n'est pas valide. Le destinataire d'un byte-content-range-
spec DOIT l'ignorer ainsi que tout contenu transféré avec lui.

Un serveur envoyant une réponse avec le code d'état 416 (plage demandée non
satisfiable) DEVRAIT inclure un champ Content-Range avec une plage d'octets-
resp-spec de "*". La longueur d'instance spécifie la longueur actuelle de



Fielding et coll. Voie des normes [Page 122]
 
RFC 2616 HTTP/1.1 juin 1999


la ressource sélectionnée. Une réponse avec le code d'état 206 (partiel
Content) NE DOIT PAS inclure de champ Content-Range avec une plage d'octets-
resp-spec de "*".

Exemples de valeurs byte-content-range-spec, en supposant que l'entité
contient un total de 1234 octets :

. Les 500 premiers octets :
octets 0-499/1234

. Les 500 seconds octets :
octets 500-999/1234

. Tous sauf les 500 premiers octets :
octets 500-1233/1234

. Les 500 derniers octets :
octets 734-1233/1234

Lorsqu'un message HTTP inclut le contenu d'une seule plage (par
exemple, une réponse à une requête sur une seule plage, ou à une requête
pour un ensemble de plages qui se chevauchent sans aucun trou), ce contenu est
transmis avec un en-tête Content-Range et un en-tête Content-Length
indiquant le nombre d'octets réellement transférés. Par exemple,

HTTP/1.1 206 Contenu partiel
Date : mercredi 15 novembre 1995, 06:25:24 GMT
Dernière modification : mercredi 15 novembre 1995 à 04:58:08 GMT
Plage de contenu : octets 21010-47021/47022
Longueur du contenu : 26012
Type de contenu : image/gif

Lorsqu'un message HTTP inclut le contenu de plusieurs plages (par exemple
exemple, une réponse à une demande de plusieurs
plages), ceux-ci sont transmis sous forme de message en plusieurs parties. Le multipart
le type de média utilisé à cette fin est "multipart/byteranges" tel que défini
en annexe 19.2. Voir l'annexe 19.6.3 pour un problème de compatibilité.

Une réponse à une demande pour une plage unique NE DOIT PAS être envoyée en utilisant le
Type de média multipart/byteranges. Une réponse à une demande de
plusieurs plages, dont le résultat est une seule plage, PEUVENT être envoyées sous forme de
Type de média multipart/byteranges avec une seule partie. Un client qui ne peut pas
décoder un message multipart/byteranges NE DOIT PAS en demander plusieurs
plages d'octets en une seule requête.

Lorsqu'un client demande plusieurs plages d'octets en une seule requête, le
le serveur DEVRAIT les renvoyer dans l'ordre dans lequel ils sont apparus dans le
demande.



Fielding et coll. Voie des normes [Page 123]
 
RFC 2616 HTTP/1.1 juin 1999


Si le serveur ignore une spécification de plage d'octets car elle est syntaxiquement
invalide, le serveur DEVRAIT traiter la requête comme si la plage invalide
le champ d'en-tête n'existait pas. (Normalement, cela signifie rendre 200
réponse contenant l’entité complète).

Si le serveur reçoit une requête (autre qu'une requête incluant un If-
Champ d'en-tête de demande de plage) avec une demande de plage insatisfaisante-
champ d'en-tête (c'est-à-dire dont toutes les valeurs de spécification de plage d'octets ont un
valeur du premier octet-pos supérieure à la longueur actuelle du fichier sélectionné
ressource), il DEVRAIT renvoyer un code de réponse de 416 (plage demandée
non satisfiable) (section 10.4.17).

Remarque : les clients ne peuvent pas dépendre des serveurs pour envoyer un 416 (demandé
plage non satisfiable) au lieu d'une réponse 200 (OK) pour
un en-tête de requête Range insatisfaisant, car tous les serveurs ne
implémentez cet en-tête de requête.

14.17 Type de contenu

Le champ d'en-tête d'entité Content-Type indique le type de média du
entité-corps envoyée au destinataire ou, dans le cas de la méthode HEAD,
le type de média qui aurait été envoyé si la demande avait été un GET.

Content-Type = "Content-Type" ":" type de média

Les types de médias sont définis à la section 3.7. Un exemple de champ est

Type de contenu : texte/html ; jeu de caractères = ISO-8859-4

Discussion plus approfondie sur les méthodes permettant d'identifier le type de média d'un
l’entité est fournie à la section 7.2.1.

14.18 Date

Le champ d'en-tête général Date représente la date et l'heure auxquelles
le message a été émis, ayant la même sémantique que orig-date dans
RFC 822. La valeur du champ est une date HTTP, comme décrit dans la section
3.3.1 ; il DOIT être envoyé au format de date RFC 1123 [8].

Date = "Date" ":" Date HTTP

Un exemple est

Date : mardi 15 novembre 1994 08:12:31 GMT

Les serveurs d'origine DOIVENT inclure un champ d'en-tête Date dans toutes les réponses,
sauf dans ces cas :




Fielding et coll. Voie des normes [Page 124]
 
RFC 2616 HTTP/1.1 juin 1999


1. Si le code d'état de la réponse est 100 (Continuer) ou 101 (Commutation
Protocoles), la réponse PEUT inclure un champ d'en-tête Date, à
l'option du serveur.

2. Si le code d'état de la réponse indique une erreur du serveur, par exemple 500
(Erreur interne du serveur) ou 503 (Service non disponible), et c'est
peu pratique ou impossible de générer une date valide.

3. Si le serveur ne dispose pas d'une horloge pouvant fournir une
approximation raisonnable de l'heure actuelle, ses réponses
NE DOIT PAS inclure de champ d’en-tête Date. Dans ce cas, les règles
à la section 14.18.1 DOIT être suivie.

Un message reçu qui n'a pas de champ d'en-tête Date DOIT être
attribué un par le destinataire si le message sera mis en cache par celui-ci
destinataire ou transité via un protocole qui nécessite une date. Un HTTP
une implémentation sans horloge NE DOIT PAS mettre en cache les réponses sans
en les revalidant à chaque utilisation. Un cache HTTP, notamment partagé
cache, DEVRAIT utiliser un mécanisme, tel que NTP [28], pour synchroniser son
horloge avec un étalon externe fiable.

Les clients DEVRAIENT envoyer uniquement un champ d'en-tête Date dans les messages qui incluent
une entité-corps, comme dans le cas des requêtes PUT et POST, et même
alors c'est facultatif. Un client sans horloge NE DOIT PAS envoyer de date
champ d’en-tête dans une requête.

La date HTTP envoyée dans un en-tête Date NE DEVRAIT PAS représenter une date et
moment postérieur à la génération du message. Il DEVRAIT représenter
la meilleure approximation disponible de la date et de l'heure du message
génération, à moins que l'implémentation n'ait aucun moyen de générer un
date et heure raisonnablement exactes. En théorie, la date devrait
représentent le moment juste avant la génération de l'entité. Dans
pratique, la date peut être générée à tout moment pendant le message
origine sans affecter sa valeur sémantique.

14.18.1 Fonctionnement du serveur Origin sans horloge

Certaines implémentations de serveur d'origine peuvent ne pas disposer d'horloge disponible.
Un serveur d'origine sans horloge NE DOIT PAS attribuer Expires ou Last-
Valeurs modifiées à une réponse, sauf si ces valeurs étaient associées
avec la ressource par un système ou un utilisateur doté d'une horloge fiable. Cela pourrait
attribuer une valeur Expire connue, au niveau ou avant le serveur
temps de configuration, être dans le passé (cela permet une "pré-expiration"
des réponses sans stocker des valeurs d'expiration distinctes pour chacune
Ressource).






Fielding et coll. Voie des normes [Page 125]
 
RFC 2616 HTTP/1.1 juin 1999


14.19 ETag

Le champ d'en-tête de réponse ETag fournit la valeur actuelle du
balise d’entité pour la variante demandée. Les en-têtes utilisés avec l'entité
les balises sont décrites dans les sections 14.24, 14.26 et 14.44. La balise d'entité
PEUT être utilisé à des fins de comparaison avec d'autres entités de la même ressource
(voir paragraphe 13.3.3).

ETag = "ETag" ":" balise-entité

Exemples:

ETag : "xyzzy"
ETag : W/"xyzzy"
Etag : ""

14h20 Attendez-vous

Le champ d'en-tête de requête Expect est utilisé pour indiquer ce problème particulier.
les comportements du serveur sont requis par le client.

Attendre = "Attendre" ":" 1#attente

attente = "100-continuer" | attente-extension
attente-extension = jeton [ "=" ( jeton | chaîne entre guillemets )
*expect-params ]
paramètres attendus = ";" jeton [ "=" ( jeton | chaîne entre guillemets ) ]


Un serveur qui ne comprend pas ou est incapable de se conformer à l'un des
les valeurs d'attente dans le champ Expect d'une requête DOIVENT répondre
avec le statut d'erreur approprié. Le serveur DOIT répondre avec un 417
Statut (Échec de l'attente) si l'une des attentes ne peut pas être satisfaite
ou, s'il y a d'autres problèmes avec la demande, un autre 4xx
statut.

Ce champ d'en-tête est défini avec une syntaxe extensible pour permettre
extensions futures. Si un serveur reçoit une requête contenant un
Champ Attendre qui inclut une extension d’attente qu’il n’inclut pas
support, il DOIT répondre avec un statut 417 (Echec de l'attente).

La comparaison des valeurs attendues n'est pas sensible à la casse pour les valeurs non citées
jetons (y compris le jeton 100-continue), et est sensible à la casse pour
extensions d'attente de chaîne entre guillemets.







Fielding et coll. Voie des normes [Page 126]
 
RFC 2616 HTTP/1.1 juin 1999


Le mécanisme Expect est saut par saut : c'est-à-dire qu'un proxy HTTP/1.1 DOIT
renvoie un statut 417 (Échec de l'attente) s'il reçoit une demande
avec une attente qu'il ne pourra pas satisfaire. Cependant, l'attente
l'en-tête de requête lui-même est de bout en bout ; il DOIT être transmis si le
la demande est transmise.

De nombreuses anciennes applications HTTP/1.0 et HTTP/1.1 ne comprennent pas le
Attendez-vous à l'en-tête.

Voir la section 8.2.3 pour l'utilisation du statut 100 (continuer).

14.21 Expire

Le champ d'en-tête d'entité Expire donne la date/heure après laquelle le
la réponse est considérée comme obsolète. Une entrée de cache obsolète ne peut normalement pas être
renvoyé par un cache (soit un cache proxy, soit un cache agent utilisateur)
sauf s'il est préalablement validé auprès du serveur d'origine (ou auprès d'un
cache intermédiaire qui possède une nouvelle copie de l'entité). Voir section
13.2 pour une discussion plus approfondie du modèle d'expiration.

La présence d'un champ Expire n'implique pas que l'original
la ressource changera ou cessera d’exister à, avant ou après cela
temps.

Le format est une date et une heure absolues telles que définies par HTTP-date dans
article 3.3.1 ; il DOIT être au format de date RFC 1123 :

Expire = "Expire" ":" Date HTTP

Un exemple de son utilisation est

Expire : jeu. 1 décembre 1994 16:00:00 GMT

Remarque : si une réponse inclut un champ Cache-Control avec le maximum
directive sur l’âge (voir la section 14.9.3), cette directive annule la
Champ Expire.

Les clients et caches HTTP/1.1 DOIVENT traiter d'autres formats de date invalides,
notamment en incluant la valeur "0", comme par le passé (c'est-à-dire "déjà
expiré").

Pour marquer une réponse comme « déjà expirée », un serveur d'origine envoie un
Date d'expiration égale à la valeur de l'en-tête Date. (Voir les règles
pour les calculs d'expiration dans la section 13.2.4.)







Fielding et coll. Voie des normes [Page 127]
 
RFC 2616 HTTP/1.1 juin 1999


Pour marquer une réponse comme « n'expire jamais », un serveur d'origine envoie un
Date d'expiration environ un an après la réception de la réponse.
envoyé. Les serveurs HTTP/1.1 NE DEVRAIENT PAS envoyer plusieurs dates d'expiration
année dans le futur.

La présence d'un champ d'en-tête Expires avec une valeur de date de quelques
temps dans le futur sur une réponse qui autrement serait par défaut
non-cacheable indique que la réponse peut être mise en cache, sauf si
indiqué autrement par un champ d’en-tête Cache-Control (section 14.9).

14.22 De

Le champ d'en-tête de requête From, s'il est fourni, DEVRAIT contenir un
adresse e-mail de l'utilisateur humain qui contrôle l'utilisateur demandeur
agent. L'adresse DEVRAIT être utilisable par une machine, telle que définie par "boîte aux lettres".
dans la RFC 822 [9] telle que mise à jour par la RFC 1123 [8] :

De = "De" ":"boîte aux lettres

Un exemple est :

De : webmaster@w3.org

Ce champ d'en-tête PEUT être utilisé à des fins de journalisation et comme moyen de
identifier la source des demandes invalides ou indésirables. Ça ne devrait pas
être utilisé comme une forme non sécurisée de protection d’accès. L'interprétation
de ce champ est que la demande est exécutée au nom du
personne donnée, qui accepte la responsabilité de la méthode appliquée. Dans
En particulier, les agents robots DEVRAIENT inclure cet en-tête afin que le
la personne responsable du fonctionnement du robot peut être contactée en cas de problème
se produisent du côté de la réception.

L'adresse e-mail Internet dans ce champ PEUT être distincte de l'adresse e-mail Internet dans ce champ.
Hôte Internet qui a émis la demande. Par exemple, lorsqu'une demande
est transmis via un proxy, l'adresse de l'émetteur d'origine DEVRAIT être
utilisé.

Le client NE DEVRAIT PAS envoyer le champ d'en-tête From sans l'accord de l'utilisateur.
approbation, car cela pourrait entrer en conflit avec les intérêts de confidentialité de l'utilisateur ou
la politique de sécurité de leur site. Il est fortement recommandé que le
l'utilisateur peut désactiver, activer et modifier la valeur de ce champ
à tout moment avant une demande.

14.23 Hôte

Le champ d'en-tête de requête Host spécifie l'hôte Internet et le port
numéro de la ressource demandée, tel qu'obtenu à partir de l'original
URI donné par l'utilisateur ou la ressource référente (généralement une URL HTTP,



Fielding et coll. Voie des normes [Page 128]
 
RFC 2616 HTTP/1.1 juin 1999


comme décrit à la section 3.2.2). La valeur du champ Hôte DOIT représenter
l'autorité de dénomination du serveur ou de la passerelle d'origine donnée par le
URL d'origine. Cela permet au serveur d'origine ou à la passerelle de
faire la différence entre les URL ambiguës en interne, telles que la racine "/"
URL d'un serveur pour plusieurs noms d'hôte sur une seule adresse IP.

Hôte = "Hôte" ":" hôte [ ":" port ] ; Section 3.2.2

Un "hôte" sans aucune information de port final implique la valeur par défaut
port du service demandé (par exemple, "80" pour une URL HTTP). Pour
exemple, une requête sur le serveur d'origine pour
<http://www.w3.org/pub/WWW/> inclurait correctement :

OBTENIR /pub/WWW/ HTTP/1.1
Hébergeur : www.w3.org

Un client DOIT inclure un champ d'en-tête Host dans toutes les requêtes HTTP/1.1
messages . Si l'URI demandé n'inclut pas d'hôte Internet
nom du service demandé, alors le champ d'en-tête Host DOIT
être donné avec une valeur vide. Un proxy HTTP/1.1 DOIT garantir que tout
le message de demande qu'il transmet contient un en-tête d'hôte approprié
champ qui identifie le service demandé par le proxy. Tous
Les serveurs HTTP/1.1 basés sur Internet DOIVENT répondre par un 400 (Bad Request)
code d'état à tout message de requête HTTP/1.1 dépourvu d'en-tête Host
champ.

Voir les sections 5.2 et 19.6.1.1 pour d'autres exigences relatives à
Hôte.

14.24 Si-correspondance

Le champ d'en-tête de requête If-Match est utilisé avec une méthode pour le rendre
conditionnel. Un client qui possède déjà une ou plusieurs entités
obtenu à partir de la ressource peut vérifier qu'une de ces entités est
actuel en incluant une liste de leurs balises d'entité associées dans le
Champ d’en-tête If-Match. Les balises d'entité sont définies dans la section 3.11. Le
le but de cette fonctionnalité est de permettre des mises à jour efficaces des fichiers mis en cache
informations avec un minimum de frais de transaction. C'est aussi
utilisé, lors des demandes de mise à jour, pour empêcher toute modification involontaire des
la mauvaise version d'une ressource. Comme cas particulier, la valeur "*"
correspond à n’importe quelle entité actuelle de la ressource.

If-Match = "If-Match" ":" ( "*" | 1#entity-tag )

Si l'une des balises d'entité correspond à la balise d'entité de l'entité qui
aurait été renvoyé en réponse à une demande GET similaire
(sans l'en-tête If-Match) sur cette ressource, ou si "*" est donné




Fielding et coll. Voie des normes [Page 129]
 
RFC 2616 HTTP/1.1 juin 1999


et que toute entité actuelle existe pour cette ressource, alors le serveur PEUT
exécuter la méthode demandée comme si le champ d'en-tête If-Match ne le faisait pas
exister.

Un serveur DOIT utiliser la fonction de comparaison forte (voir section 13.3.3)
pour comparer les balises d'entité dans If-Match.

Si aucune des balises d'entité ne correspond, ou si "*" est donné et qu'aucun
l'entité existe, le serveur NE DOIT PAS exécuter la méthode demandée, et
DOIT renvoyer une réponse 412 (Échec de la précondition). Ce comportement est
très utile lorsque le client souhaite empêcher une méthode de mise à jour, telle que
comme PUT, de modifier une ressource qui a changé depuis le client
l'a récupéré pour la dernière fois.

Si la requête, sans le champ d'en-tête If-Match, aboutissait à
autre chose qu'un statut 2xx ou 412, alors l'en-tête If-Match
DOIT être ignoré.

La signification de "If-Match: *" est que la méthode DEVRAIT être exécutée
si la représentation sélectionnée par le serveur d'origine (ou par un cache,
utilisant éventuellement le mécanisme Vary, voir section 14.44) existe, et
NE DOIT PAS être effectué si la représentation n’existe pas.

Une requête destinée à mettre à jour une ressource (par exemple, un PUT) PEUT inclure un
Champ d'en-tête If-Match pour signaler que la méthode de requête NE DOIT PAS être
appliqué si l'entité correspondant à la valeur If-Match (un seul
balise d'entité) n'est plus une représentation de cette ressource. Ce
permet à l'utilisateur d'indiquer qu'il ne souhaite pas que la demande soit
réussi si la ressource a été modifiée à leur insu.
Exemples:

Si-Match : "xyzzy"
Si-Match : "xyzzy", "r2d2xxxx", "c3piozzzz"
Si-Match : *

Le résultat d'une requête ayant à la fois un champ d'en-tête If-Match et
soit un champ d'en-tête If-None-Match ou If-Modified-Since est
non défini par cette spécification.

14.25 Si modifié depuis

Le champ d'en-tête de requête If-Modified-Since est utilisé avec une méthode pour
le rendre conditionnel : si la variante demandée n'a pas été modifiée
depuis l'heure indiquée dans ce champ, une entité ne sera plus
renvoyé du serveur ; à la place, une réponse 304 (non modifiée) sera
être renvoyé sans aucun corps de message.

If-Modified-Since = "If-Modified-Since" ": HTTP-date



Fielding et coll. Voie des normes [Page 130]
 
RFC 2616 HTTP/1.1 juin 1999


Un exemple de champ est :

Si modifié depuis : samedi 29 octobre 1994 à 19:43:31 GMT

Une méthode GET avec un en-tête If-Modified-Since et aucun en-tête Range
demande que l’entité identifiée soit transférée uniquement si elle a
été modifié depuis la date donnée par l'en-tête If-Modified-Since.
L'algorithme pour déterminer cela inclut les cas suivants :

a) Si la demande devait normalement aboutir à autre chose qu'un
200 (OK), ou si la date If-Modified-Since passée est
invalide, la réponse est exactement la même que pour un GET normal.
Une date postérieure à l'heure actuelle du serveur est
invalide.

b) Si la variante a été modifiée depuis le If-Modified-Since
date, la réponse est exactement la même que pour un GET normal.

c) Si la variante n'a pas été modifiée depuis un If-
Modifié-Depuis la date, le serveur DEVRAIT renvoyer un 304 (pas
Réponse modifiée).

Le but de cette fonctionnalité est de permettre des mises à jour efficaces des fichiers mis en cache
informations avec un minimum de frais de transaction.

Remarque : Le champ d'en-tête de requête Range modifie la signification de If-
Modifié depuis ; voir la section 14.35 pour plus de détails.

Remarque : Les heures If-Modified-Since sont interprétées par le serveur, dont
l'horloge peut ne pas être synchronisée avec le client.

Remarque : Lors de la gestion d'un champ d'en-tête If-Modified-Since, certains
les serveurs utiliseront une fonction de comparaison de dates exactes, plutôt qu'un
fonction inférieure à, pour décider d'envoyer ou non un 304 (non
Réponse modifiée). Pour obtenir de meilleurs résultats lors de l'envoi d'un If-
Modifié-Depuis le champ d'en-tête pour la validation du cache, les clients sont
Il est conseillé d'utiliser la chaîne de date exacte reçue lors d'un précédent Last-
Champ d’en-tête modifié chaque fois que possible.

Remarque : Si un client utilise une date arbitraire dans le champ If-Modified-Since
en-tête au lieu d'une date extraite de l'en-tête Last-Modified pour
la même demande, le client doit être conscient du fait que cela
la date est interprétée dans la compréhension de l'heure par le serveur. Le
le client doit prendre en compte les horloges non synchronisées et les problèmes d'arrondi
en raison des différents encodages de temps entre le client et
serveur. Cela inclut la possibilité de conditions de concurrence si le
le document a changé entre le moment où il a été demandé pour la première fois et
la date If-Modified-Depuis d'une demande ultérieure, et la



Fielding et coll. Voie des normes [Page 131]
 
RFC 2616 HTTP/1.1 juin 1999


possibilité de problèmes liés au décalage d'horloge si le paramètre If-Modified-
Puisque la date est dérivée de l'horloge du client sans correction
à l'horloge du serveur. Corrections pour différentes bases de temps
entre le client et le serveur sont au mieux approximatifs en raison du réseau
latence.

Le résultat d'une requête ayant à la fois un champ d'en-tête If-Modified-Since
et un champ d'en-tête If-Match ou If-Unmodified-Since est
non défini par cette spécification.

14.26 Si aucune correspondance

Le champ d'en-tête de requête If-None-Match est utilisé avec une méthode pour faire
c'est conditionnel. Un client qui possède déjà une ou plusieurs entités
obtenu à partir de la ressource peut vérifier qu'aucune de ces entités n'est
actuel en incluant une liste de leurs balises d'entité associées dans le
Champ d’en-tête If-None-Match. Le but de cette fonctionnalité est de permettre
mises à jour efficaces des informations mises en cache avec un minimum de
frais généraux de transaction. Il est également utilisé pour empêcher une méthode (par exemple PUT)
de modifier par inadvertance une ressource existante lorsque le client
estime que la ressource n’existe pas.

Comme cas particulier, la valeur "*" correspond à n'importe quelle entité actuelle du
Ressource.

If-None-Match = "If-None-Match" ":" ( "*" | 1#entity-tag )

Si l'une des balises d'entité correspond à la balise d'entité de l'entité qui
aurait été renvoyé en réponse à une demande GET similaire
(sans l'en-tête If-None-Match) sur cette ressource, ou si "*" est
donnée et qu'une entité actuelle existe pour cette ressource, alors le
le serveur NE DOIT PAS exécuter la méthode demandée, sauf si cela est requis
donc parce que la date de modification de la ressource ne correspond pas à celle
fourni dans un champ d’en-tête If-Modified-Since dans la demande.
Au lieu de cela, si la méthode de requête était GET ou HEAD, le serveur DEVRAIT
répondre avec une réponse 304 (Non modifié), y compris le cache-
champs d'en-tête associés (en particulier ETag) de l'une des entités qui
correspondait. Pour toutes les autres méthodes de requête, le serveur DOIT répondre avec
un statut de 412 (Échec de la précondition).

Voir la section 13.3.3 pour les règles sur la façon de déterminer si deux entités balisent
correspondre. La fonction de comparaison faible ne peut être utilisée qu'avec GET ou HEAD
demandes.








Fielding et coll. Voie des normes [Page 132]
 
RFC 2616 HTTP/1.1 juin 1999


Si aucune des balises d'entité ne correspond, alors le serveur PEUT effectuer la
méthode demandée comme si le champ d'en-tête If-None-Match n'existait pas,
mais DOIT également ignorer tout champ d'en-tête If-Modified-Since dans le
demande. Autrement dit, si aucune balise d'entité ne correspond, alors le serveur NE DOIT PAS
renvoie une réponse 304 (non modifiée).

Si la requête, sans le champ d'en-tête If-None-Match, aurait pour résultat
dans autre chose qu'un statut 2xx ou 304, alors le If-None-Match
l'en-tête DOIT être ignoré. (Voir la section 13.3.4 pour une discussion sur
comportement du serveur lorsque If-Modified-Since et If-None-Match apparaissent
dans la même demande.)

La signification de "If-None-Match: *" est que la méthode NE DOIT PAS être
effectuée si la représentation sélectionnée par le serveur d'origine (ou par
un cache, éventuellement en utilisant le mécanisme Vary, voir section 14.44)
existe, et DEVRAIT être effectué si la représentation n'existe pas.
Cette fonctionnalité est destinée à être utile pour empêcher les courses entre PUT
opérations.

Exemples:

Si aucune correspondance : "xyzzy"
Si-Aucun-Match : W/"xyzzy"
Si aucune correspondance : "xyzzy", "r2d2xxxx", "c3piozzzz"
Si aucune correspondance : W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"
Si aucune correspondance : *

Le résultat d'une requête ayant à la fois un champ d'en-tête If-None-Match et
soit un champ d'en-tête If-Match ou If-Unmodified-Since est
non défini par cette spécification.

14.27 Plage If

Si un client possède une copie partielle d'une entité dans son cache et souhaite
pour avoir une copie à jour de l'intégralité de l'entité dans son cache, il
pourrait utiliser l'en-tête de requête Range avec un GET conditionnel (en utilisant
l'un ou les deux de If-Unmodified-Since et If-Match.) Cependant, si le
La condition échoue car l'entité a été modifiée, le client
il faudrait alors faire une seconde demande pour obtenir la totalité du courant
entité-corps.

L'en-tête If-Range permet à un client de "court-circuiter" le second
demande. De manière informelle, sa signification est « si l'entité est inchangée, envoyez
moi la ou les pièces qui me manquent ; sinon, envoie-moi le tout nouveau
entité'.

If-Range = "If-Range" ":" ( balise d'entité | HTTP-date )




Fielding et coll. Voie des normes [Page 133]
 
RFC 2616 HTTP/1.1 juin 1999


Si le client n'a pas de balise d'entité pour une entité, mais dispose d'une balise Last-
Date de modification, il PEUT utiliser cette date dans un en-tête If-Range. (Le
Le serveur peut faire la distinction entre une date HTTP valide et toute forme de
balise d'entité en examinant pas plus de deux caractères.) La plage If
l'en-tête NE DEVRAIT être utilisé qu'avec un en-tête Range et DOIT être
ignoré si la requête n'inclut pas d'en-tête Range ou si le
Le serveur ne prend pas en charge l'opération de sous-plage.

Si la balise d'entité donnée dans l'en-tête If-Range correspond à la balise d'entité actuelle
balise d'entité pour l'entité, alors le serveur DEVRAIT fournir la
sous-plage spécifiée de l'entité à l'aide d'un 206 (contenu partiel)
réponse. Si la balise d'entité ne correspond pas, alors le serveur DEVRAIT
renvoie l'entité entière en utilisant une réponse 200 (OK).

14.28 Si non modifié depuis

Le champ d'en-tête de requête If-Unmodified-Since est utilisé avec une méthode pour
rendez-le conditionnel. Si la ressource demandée n'a pas été modifiée
depuis l'heure spécifiée dans ce champ, le serveur DEVRAIT effectuer la
opération demandée comme si l'en-tête If-Unmodified-Since n'était pas
présent.

Si la variante demandée a été modifiée depuis l'heure indiquée,
le serveur NE DOIT PAS effectuer l'opération demandée et DOIT renvoyer
un 412 (échec de la condition préalable).

If-Unmodified-Since = "If-Unmodified-Since" ": HTTP-date

Un exemple de champ est :

Si non modifié depuis : samedi 29 octobre 1994 19:43:31 GMT

Si la demande normalement (c'est-à-dire sans le If-Unmodified-Since)
en-tête) entraînerait autre chose qu'un statut 2xx ou 412, le
L’en-tête If-Unmodified-Since DEVRAIT être ignoré.

Si la date spécifiée n'est pas valide, l'en-tête est ignoré.

Le résultat d'une requête ayant à la fois un en-tête If-Unmodified-Since
champ et un en-tête If-None-Match ou If-Modified-Since
Les champs ne sont pas définis par cette spécification.

14.29 Dernière modification

Le champ d'en-tête d'entité Last-Modified indique la date et l'heure à
dont le serveur d'origine pense que la variante a été modifiée pour la dernière fois.

Last-Modified = "Dernière-Modification" ":" Date HTTP



Fielding et coll. Voie des normes [Page 134]
 
RFC 2616 HTTP/1.1 juin 1999


Un exemple de son utilisation est

Dernière modification : mardi 15 novembre 1994 à 12:45:26 GMT

La signification exacte de ce champ d'en-tête dépend de l'implémentation
du serveur d'origine et de la nature de la ressource d'origine. Pour
fichiers, il peut s'agir simplement de l'heure de la dernière modification du système de fichiers. Pour
entités avec des parties incluses dynamiquement, il peut s'agir de la plus récente
de l'ensemble des heures de dernière modification pour ses composants. Pour la base de données
passerelles, il peut s'agir de l'horodatage de la dernière mise à jour de l'enregistrement. Pour
objets virtuels, c'est peut-être la dernière fois que l'état interne a changé.

Un serveur d'origine NE DOIT PAS envoyer une date de dernière modification ultérieure
que l'heure d'origine du message par le serveur. Dans de tels cas, où
la dernière modification de la ressource indiquerait quelque temps dans le
futur, le serveur DOIT remplacer cette date par le message
date d'origine.

Un serveur d'origine DEVRAIT obtenir la valeur Last-Modified de l'entité
aussi proche que possible de l'heure à laquelle il génère la valeur Date de
sa réponse. Cela permet au destinataire de faire une évaluation précise
de l'heure de modification de l'entité, surtout si l'entité change
près du moment où la réponse est générée.

Les serveurs HTTP/1.1 DEVRAIENT envoyer Last-Modified chaque fois que cela est possible.

14h30 Localisation

Le champ d'en-tête de réponse Location est utilisé pour rediriger le destinataire
vers un emplacement autre que le Request-URI pour l'achèvement du
demande ou identification d’une nouvelle ressource. Pour 201 (Créé)
réponses, l'emplacement est celui de la nouvelle ressource qui a été créée
par la demande. Pour les réponses 3xx, l'emplacement DEVRAIT indiquer le
URI préféré du serveur pour la redirection automatique vers la ressource. Le
La valeur du champ consiste en un seul URI absolu.

Emplacement = "Emplacement" ":" absoluURI

Un exemple est :

Emplacement : http://www.w3.org/pub/WWW/People.html

Remarque : Le champ d'en-tête Content-Location (section 14.14) diffère
from Location en ce sens que le Content-Location identifie l'original
localisation de l'entité incluse dans la demande. Il est donc
possible qu'une réponse contienne des champs d'en-tête pour les deux emplacements
et emplacement du contenu. Voir également la section 13.10 pour le cache
exigences de certaines méthodes.



Fielding et coll. Voie des normes [Page 135]
 
RFC 2616 HTTP/1.1 juin 1999


14.31 Avances maximales

Le champ d'en-tête de requête Max-Forwards fournit un mécanisme avec le
TRACE (section 9.8) et OPTIONS (section 9.2) pour limiter les
nombre de proxys ou de passerelles pouvant transmettre la demande au
prochain serveur entrant. Cela peut être utile lorsque le client tente
pour tracer une chaîne de requêtes qui semble échouer ou faire une boucle
milieu de chaîne.

Max-Forwards = "Max-Forwards" ":" 1*CHIFFRE

La valeur Max-Forwards est un entier décimal indiquant le temps restant
nombre de fois où ce message de demande peut être transmis.

Chaque proxy ou passerelle destinataire d'une requête TRACE ou OPTIONS
contenant un champ d'en-tête Max-Forwards DOIT vérifier et mettre à jour son
valeur avant de transmettre la demande. Si la valeur reçue est nulle
(0), le destinataire NE DOIT PAS transmettre la demande ; à la place, il DOIT
répondre en tant que destinataire final. Si la valeur Max-Forwards reçue est
supérieur à zéro, alors le message transmis DOIT contenir une mise à jour
Champ Max-Forwards avec une valeur décrémentée de un (1).

Le champ d'en-tête Max-Forwards PEUT être ignoré pour toutes les autres méthodes
défini par cette spécification et pour toute méthode d'extension pour laquelle
il n'est pas explicitement mentionné dans le cadre de la définition de cette méthode.

14.32 Pragma

Le champ d'en-tête général Pragma est utilisé pour inclure l'implémentation-
directives spécifiques qui pourraient s'appliquer à tout destinataire tout au long du
chaîne de requête/réponse. Toutes les directives pragma spécifient facultatif
comportement du point de vue du protocole ; cependant, certains systèmes
PEUT exiger que le comportement soit cohérent avec les directives.

Pragma = "Pragma" ":" 1#pragma-directive
pragma-directive = "pas de cache" | extension-pragma
extension-pragma = jeton [ "=" ( jeton | chaîne entre guillemets ) ]

Lorsque la directive no-cache est présente dans un message de requête, un
l'application DEVRAIT transmettre la requête vers le serveur d'origine même
s'il a une copie en cache de ce qui est demandé. Ce pragme
a la même sémantique que la directive cache no-cache (voir
section 14.9) et est défini ici pour des raisons de compatibilité ascendante avec
HTTP/1.0. Les clients DEVRAIENT inclure les deux champs d'en-tête lors d'une opération sans cache
La requête est envoyée à un serveur dont on sait qu'il n'est pas conforme à HTTP/1.1.






Fielding et coll. Voie des normes [Page 136]
 
RFC 2616 HTTP/1.1 juin 1999


Les directives Pragma DOIVENT être transmises par un proxy ou une passerelle
demande, quelle que soit leur importance pour cette demande,
puisque les directives pourraient être applicables à tous les destinataires tout au long du
chaîne de requête/réponse. Il n'est pas possible de spécifier un pragma pour un
destinataire spécifique ; cependant, toute directive pragma non pertinente pour un
le destinataire DEVRAIT être ignoré par ce destinataire.

Les caches HTTP/1.1 DEVRAIENT traiter « Pragma : no-cache » comme si le client avait
envoyé "Cache-Control: no-cache". Aucune nouvelle directive Pragma ne sera
défini en HTTP.

Remarque : parce que la signification de "Pragma : no-cache en réponse
Le champ d'en-tête n'est pas réellement spécifié, il ne fournit pas de
remplacement fiable de "Cache-Control: no-cache" dans une réponse

14.33 Authentification par procuration

Le champ d’en-tête de réponse Proxy-Authenticate DOIT être inclus dans le cadre
d'une réponse 407 (Authentification proxy requise). La valeur du champ
consiste en un défi qui indique le schéma d'authentification et
paramètres applicables au proxy pour cette requête-URI.

Proxy-Authenticate = "Proxy-Authenticate" ":" 1#défi

Le processus d'authentification d'accès HTTP est décrit dans "HTTP
Authentification : authentification d'accès de base et Digest" [43]. Contrairement à
WWW-Authenticate, le champ d'en-tête Proxy-Authenticate s'applique uniquement à
la connexion actuelle et NE DEVRAIT PAS être transmise en aval
clients. Toutefois, un proxy intermédiaire devra peut-être obtenir son propre
informations d'identification en les demandant au client en aval, qui en
certaines circonstances apparaîtront comme si le mandataire transmettait le
Champ d’en-tête Proxy-Authenticate.

14.34 Autorisation par procuration

Le champ d'en-tête de demande Proxy-Authorization permet au client de
s'identifier (ou son utilisateur) auprès d'un proxy qui nécessite
authentification. La valeur du champ Proxy-Authorization comprend
informations d'identification contenant les informations d'authentification de l'utilisateur
agent pour le proxy et/ou le domaine de la ressource demandée.

Proxy-Authorization = "Proxy-Authorization" ":" informations d'identification

Le processus d'authentification d'accès HTTP est décrit dans "HTTP
Authentification : authentification d'accès de base et Digest" [43] . Contrairement à
Autorisation, le champ d'en-tête Proxy-Authorization s'applique uniquement à
le prochain proxy sortant qui a demandé une authentification à l'aide du proxy-
Champ d'authentification. Lorsque plusieurs proxys sont utilisés dans une chaîne, le



Fielding et coll. Voie des normes [Page 137]
 
RFC 2616 HTTP/1.1 juin 1999


Le champ d'en-tête Proxy-Authorization est consommé par le premier message sortant
proxy qui s'attendait à recevoir des informations d'identification. Un relais proxy PEUT
les informations d'identification de la demande du client au proxy suivant si tel est le cas
le mécanisme par lequel les mandataires authentifient de manière coopérative un
demande.

14h35 Portée

14.35.1 Plages d'octets

Puisque toutes les entités HTTP sont représentées dans les messages HTTP sous forme de séquences
d'octets, le concept de plage d'octets est significatif pour tout HTTP
entité. (Cependant, tous les clients et serveurs n'ont pas besoin de prendre en charge le byte-
opérations de portée.)

Les spécifications de plage d'octets dans HTTP s'appliquent à la séquence d'octets dans
le corps de l'entité (pas nécessairement le même que le corps du message).

Une opération de plage d'octets PEUT spécifier une seule plage d'octets, ou un ensemble
de plages au sein d’une même entité.

spécificateur de plages = spécificateur de plages d'octets
byte-ranges-specifier = octets-unit "=" octet-range-set
byte-range-set = 1#( byte-range-spec | suffixe-byte-range-spec )
byte-range-spec = premier octet-pos "-" [dernier octet-pos]
premier octet-pos = 1*CHIFFRE
dernier octet-pos = 1*CHIFFRE

La valeur du premier octet-pos dans une spécification de plage d'octets donne le décalage d'octet
du premier octet d'une plage. La valeur du dernier octet-pos donne le
décalage d'octet du dernier octet de la plage ; c'est-à-dire l'octet
les postes spécifiés sont inclusifs. Les décalages d'octets commencent à zéro.

Si la valeur du dernier octet-pos est présente, elle DOIT être supérieure ou
égal au premier octet-pos dans cette spécification de plage d'octets, ou à l'octet-
range-spec est syntaxiquement invalide. Le destinataire d'une plage d'octets-
ensemble qui inclut une ou plusieurs spécifications de plage d'octets syntaxiquement invalides
les valeurs DOIVENT ignorer le champ d'en-tête qui inclut cette plage d'octets.
ensemble.

Si la valeur du dernier octet-pos est absente ou si la valeur est supérieure à
ou égal à la longueur actuelle du corps de l'entité, le dernier octet-pos est
considéré comme égal à un de moins que la longueur actuelle de l'entité-
corps en octets.

Par son choix de pos du dernier octet, un client peut limiter le nombre de
octets récupérés sans connaître la taille de l'entité.




Fielding et coll. Voie des normes [Page 138]
 
RFC 2616 HTTP/1.1 juin 1999


suffix-byte-range-spec = "-" longueur du suffixe
longueur du suffixe = 1*CHIFFRE

Un suffixe-byte-range-spec est utilisé pour spécifier le suffixe du
corps-d'entité, d'une longueur donnée par la valeur suffixe-length. (C'est,
cette forme spécifie les N derniers octets d'un corps d'entité.) Si le
l'entité est plus courte que la longueur du suffixe spécifiée, l'intégralité
le corps d'entité est utilisé.

Si un ensemble de plage d'octets syntaxiquement valide comprend au moins un octet
range-spec dont le premier octet-pos est inférieur à la longueur actuelle de
le corps de l'entité, ou au moins un suffixe-byte-range-spec avec un non-
longueur de suffixe nulle, alors l'ensemble de plages d'octets est satisfiable.
Sinon, l'ensemble de plages d'octets n'est pas satisfaisant. Si l'ensemble de plage d'octets
est insatisfaisant, le serveur DEVRAIT retourner une réponse avec un statut
de 416 (plage demandée non satisfiable). Sinon, le serveur
DEVRAIT renvoyer une réponse avec un statut de 206 (Contenu partiel)
contenant les plages satisfiables de l’entité-corps.

Exemples de valeurs de spécificateur de plages d'octets (en supposant un corps d'entité de
longueur 10000) :

- Les 500 premiers octets (décalages d'octets 0-499 inclus) : octets=0-
499

- Les 500 seconds octets (décalages d'octets 500-999 inclus) :
octets = 500-999

- Les 500 derniers octets (décalages d'octets 9 500 à 9 999 inclus) :
octets=-500

- Ou octets=9500-

- Le premier et le dernier octets uniquement (octets 0 et 9999) : octets=0-0,-1

- Plusieurs spécifications légales mais non canoniques du second 500
octets (décalages d'octets 500 à 999 inclus) :
octets = 500-600,601-999
octets = 500-700,601-999

14.35.2 Requêtes de récupération de plage

Requêtes de récupération HTTP utilisant GET conditionnel ou inconditionnel
les méthodes PEUVENT demander une ou plusieurs sous-gammes de l'entité, au lieu de
l'entité entière, en utilisant l'en-tête de requête Range, qui s'applique à
l'entité a renvoyé à la suite de la demande :

Range = "Plage" ":" plages-spécificateur



Fielding et coll. Voie des normes [Page 139]
 
RFC 2616 HTTP/1.1 juin 1999


Un serveur PEUT ignorer l'en-tête Range. Cependant, l'origine HTTP/1.1
les serveurs et les caches intermédiaires doivent prendre en charge les plages d'octets lorsque
possible, puisque Range prend en charge une récupération efficace de partiellement
transferts échoués et prend en charge la récupération partielle efficace des fichiers volumineux
entités.

Si le serveur prend en charge l'en-tête Range et la plage spécifiée ou
les plages sont appropriées pour l’entité :

- La présence d'un entête Range dans un GET inconditionnel modifie
ce qui est renvoyé si le GET réussit par ailleurs. En d'autre
mots, la réponse porte un code d'état de 206 (partiel
Contenu) au lieu de 200 (OK).

- La présence d'un entête Range dans un GET conditionnel (une requête
en utilisant l'un ou les deux de If-Modified-Since et If-None-Match, ou
l'un ou les deux de If-Unmodified-Since et If-Match) modifie ce qui
est renvoyé si le GET réussit par ailleurs et que le
la condition est vraie. Cela n'affecte pas le 304 (non modifié)
réponse renvoyée si le conditionnel est faux.

Dans certains cas, il peut être plus approprié d'utiliser la méthode If-Range
(voir section 14.27) en plus de l'en-tête Range.

Si un proxy prenant en charge les plages reçoit une demande de plage, transmet
la requête à un serveur entrant, et reçoit une entité entière dans
réponse, il DEVRAIT uniquement renvoyer la plage demandée à son client. Il
DEVRAIT stocker la totalité de la réponse reçue dans son cache si cela est
conformément à ses politiques d'allocation de cache.

14.36 Référent

Le champ d'en-tête de requête Referer[sic] permet au client de spécifier,
au profit du serveur, l'adresse (URI) de la ressource de
lequel le Request-URI a été obtenu (le "référent", bien que le
Le champ d'en-tête est mal orthographié.) L'en-tête de requête Referer permet un
serveur pour générer des listes de back-links vers des ressources intéressantes,
journalisation, mise en cache optimisée, etc. Il permet également des informations obsolètes ou mal saisies.
liens à tracer pour la maintenance. Le champ Référent NE DOIT PAS être
envoyé si le Request-URI a été obtenu à partir d’une source qui n’a pas
son propre URI, comme la saisie à partir du clavier de l'utilisateur.

Référent = "Référent" ":" ( URI absolu | URI relatif )

Exemple:

Référent : http://www.w3.org/hypertext/DataSources/Overview.html




Fielding et coll. Voie des normes [Page 140]
 
RFC 2616 HTTP/1.1 juin 1999


Si la valeur du champ est un URI relatif, elle DEVRAIT être interprétée
par rapport au Request-URI. L'URI NE DOIT PAS inclure de fragment. Voir
section 15.1.3 pour les considérations de sécurité.

14.37 Réessayer après

Le champ d'en-tête de réponse Retry-After peut être utilisé avec un 503 (Service
Indisponible) réponse pour indiquer la durée prévue du service
être indisponible pour le client demandeur. Ce champ PEUT également être utilisé
avec n’importe quelle réponse 3xx (Redirection) pour indiquer la durée minimale pendant laquelle
Il est demandé à l'agent utilisateur d'attendre avant d'émettre la requête redirigée. Le
la valeur de ce champ peut être soit une date HTTP, soit un nombre entier
de secondes (en décimal) après l'heure de la réponse.

Réessayer-Après = "Réessayer-Après" ":" ( Date HTTP | delta-secondes )

Deux exemples de son utilisation sont

Réessayer après : vendredi 31 décembre 1999 23:59:59 GMT
Réessayer après : 120

Dans ce dernier exemple, le délai est de 2 minutes.

14.38 Serveur

Le champ d'en-tête de réponse du serveur contient des informations sur le
logiciel utilisé par le serveur d'origine pour traiter la requête. Le champ
peut contenir plusieurs jetons de produit (section 3.8) et des commentaires
identifier le serveur et tous les sous-produits importants. Le produit
les jetons sont répertoriés par ordre d'importance pour identifier le
application.

Serveur = "Serveur" ":" 1*( produit | commentaire )

Exemple:

Serveur : CERN/3.0 libwww/2.17

Si la réponse est transmise via un proxy, le proxy
L'application NE DOIT PAS modifier l'en-tête de réponse du serveur. Au lieu de cela, il
DEVRAIT inclure un champ Via (comme décrit à la section 14.45).

Remarque : La révélation de la version logicielle spécifique du serveur peut
permettre à la machine serveur de devenir plus vulnérable aux attaques
contre les logiciels connus pour contenir des failles de sécurité. Serveur
les implémenteurs sont encouragés à faire de ce champ un champ configurable
option.




Fielding et coll. Voie des normes [Page 141]
 
RFC 2616 HTTP/1.1 juin 1999


14h39 HE

Le champ d'en-tête de demande TE indique quels codes de transfert d'extension
il est prêt à accepter dans la réponse et si oui ou non
prêt à accepter les champs de fin dans un codage de transfert fragmenté. C'est
La valeur peut être constituée du mot-clé « trailers » et/ou d'un symbole séparé par des virgules.
liste des noms de codage de transfert d'extension avec acceptation facultative
paramètres (tels que décrits à la section 3.6).

TE = "TE" ":" #(t-codages)
t-codings = "remorques" | ( extension de transfert [ accept-params ] )

La présence du mot clé « trailers » indique que le client est
prêt à accepter les champs de fin dans un codage de transfert fragmenté, comme
défini à la section 3.6.1. Ce mot-clé est réservé à une utilisation avec
valeurs de codage de transfert même si elles ne représentent pas elles-mêmes un
transfert-codage.

Des exemples de son utilisation sont :

TE : dégonfler
TE :
TE : remorques, dégonfler ; q = 0,5

Le champ d'en-tête TE s'applique uniquement à la connexion immédiate.
Par conséquent, le mot-clé DOIT être fourni dans un en-tête de connexion
(section 14.10) chaque fois que TE est présent dans un message HTTP/1.1.

Un serveur teste si un codage de transfert est acceptable, selon
un champ TE, en utilisant ces règles :

1. Le codage de transfert « fragmenté » est toujours acceptable. Si la
mot-clé "remorques" est répertorié, le client indique qu'il est
prêt à accepter les champs de fin dans la réponse fragmentée sur
pour son compte et celui de tout client en aval. L'implication est
que, s'il est indiqué, le client déclare que soit tous
les clients en aval sont prêts à accepter les champs de fin dans le
réponse transmise, ou qu'il tentera de mettre en mémoire tampon la
réponse au nom des destinataires en aval.

Remarque : HTTP/1.1 ne définit aucun moyen pour limiter la taille d'un
réponse fragmentée de telle sorte qu'un client peut être assuré de la mise en mémoire tampon
toute la réponse.

2. Si le codage de transfert testé est l'un des codes de transfert
codages répertoriés dans le champ TE, alors il est acceptable à moins qu'il
est accompagné d'une valeur q de 0. (Comme défini dans la section 3.9, un
une valeur de 0 signifie « non acceptable ».)



Fielding et coll. Voie des normes [Page 142]
 
RFC 2616 HTTP/1.1 juin 1999


3. Si plusieurs codages de transfert sont acceptables, alors le
un codage de transfert acceptable avec la valeur q non nulle la plus élevée est
préféré. Le codage de transfert "en morceaux" a toujours une valeur q
de 1.

Si la valeur du champ TE est vide ou si aucun champ TE n'est présent, le seul
le codage de transfert est « fragmenté ». Un message sans codage de transfert est
toujours acceptable.

14h40 Remorque

La valeur du champ général Trailer indique que l'ensemble donné de
les champs d'en-tête sont présents dans la fin d'un message codé avec
codage de transfert fragmenté.

Bande-annonce = "Remorque" ":" 1#nom-champ

Un message HTTP/1.1 DEVRAIT inclure un champ d'en-tête Trailer dans un
message utilisant un codage de transfert fragmenté avec une fin non vide. Faire
permet ainsi au destinataire de savoir à quels champs d'en-tête s'attendre dans le
bande-annonce.

Si aucun champ d’en-tête de fin n’est présent, la fin NE DEVRAIT PAS inclure
tous les champs d’en-tête. Voir la section 3.6.1 pour les restrictions sur l'utilisation de
champs de fin dans un codage de transfert « fragmenté ».

Les champs d'en-tête de message répertoriés dans le champ d'en-tête de fin NE DOIVENT PAS
inclure les champs d'en-tête suivants :

. Encodage de transfert

. Longueur du contenu

. Bande-annonce

14.41 Transfert-Encodage

Le champ d'en-tête général Transfer-Encoding indique ce qui (le cas échéant)
type de transformation a été appliqué au corps du message afin
pour le transférer en toute sécurité entre l'expéditeur et le destinataire. Ce
diffère du codage de contenu en ce que le codage de transfert est un
propriété du message, pas de l’entité.

Transfer-Encoding = "Transfer-Encoding" ":" 1#transfer-coding

Les codages de transfert sont définis à la section 3.6. Un exemple est :

Encodage de transfert : fragmenté



Fielding et coll. Voie des normes [Page 143]
 
RFC 2616 HTTP/1.1 juin 1999


Si plusieurs codages ont été appliqués à une entité, le transfert
les codages DOIVENT être répertoriés dans l’ordre dans lequel ils ont été appliqués.
Des informations supplémentaires sur les paramètres de codage PEUVENT être fournies
par d'autres champs d'en-tête d'entité non définis par cette spécification.

De nombreuses anciennes applications HTTP/1.0 ne comprennent pas le protocole Transfer-
En-tête d’encodage.

14.42 Mise à niveau

L'en-tête général Upgrade permet au client de spécifier ce
protocoles de communication supplémentaires qu'il prend en charge et qu'il souhaite utiliser
si le serveur juge approprié de changer de protocole. Le serveur
DOIT utiliser le champ d'en-tête Upgrade dans un 101 (Switching Protocols)
réponse pour indiquer quel(s) protocole(s) sont en cours de commutation.

Mise à niveau = "Mise à niveau" ":" 1#product

Par exemple,

Mise à niveau : HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11

Le champ d'en-tête Upgrade est destiné à fournir un mécanisme simple
pour la transition de HTTP/1.1 vers un autre protocole incompatible. Il
le fait en permettant au client d'annoncer son désir d'utiliser un autre
protocole, comme une version ultérieure de HTTP avec une version majeure supérieure
numéro, même si la requête actuelle a été effectuée via HTTP/1.1.
Cela facilite la transition difficile entre des protocoles incompatibles en
permettant au client d'initier une demande de la manière la plus courante
protocole supporté tout en indiquant au serveur qu'il souhaite
utiliser un « meilleur » protocole si disponible (où « meilleur » est déterminé
par le serveur, éventuellement selon la nature de la méthode et/ou
ressource demandée).

Le champ d'en-tête Upgrade s'applique uniquement au changement de couche d'application.
protocoles sur la connexion de couche transport existante. Mise à niveau
ne peut pas être utilisé pour insister sur un changement de protocole ; son acceptation et son utilisation
par le serveur est facultatif. Les capacités et la nature du
la communication au niveau de l'application après le changement de protocole est entièrement
dépend du nouveau protocole choisi, bien que la première action
après avoir changé le protocole DOIT être une réponse au HTTP initial
requête contenant le champ d’en-tête Upgrade.

Le champ d’en-tête Upgrade s’applique uniquement à la connexion immédiate.
Par conséquent, le mot-clé de mise à niveau DOIT être fourni dans une connexion
champ d'en-tête (section 14.10) chaque fois que la mise à niveau est présente dans un
Message HTTP/1.1.




Fielding et coll. Voie des normes [Page 144]
 
RFC 2616 HTTP/1.1 juin 1999


Le champ d’en-tête Upgrade ne peut pas être utilisé pour indiquer un passage à un
protocole sur une connexion différente. Pour cela, il est plus
Il est approprié d'utiliser une réponse de redirection 301, 302, 303 ou 305.

Cette spécification définit uniquement le nom de protocole "HTTP" destiné à être utilisé par
la famille des protocoles de transfert hypertexte, telle que définie par le protocole HTTP
règles de version de la section 3.1 et les futures mises à jour de ce
spécification. N'importe quel jeton peut être utilisé comme nom de protocole ; Cependant, il
ne sera utile que si le client et le serveur associent le nom
avec le même protocole.

14.43 Agent utilisateur

Le champ d'en-tête de requête User-Agent contient des informations sur le
agent utilisateur à l’origine de la demande. Ceci est à des fins statistiques,
le traçage des violations de protocole et la reconnaissance automatisée des utilisateurs
agents dans le but d'adapter les réponses pour éviter des utilisateurs particuliers
limites des agents. Les agents utilisateurs DEVRAIENT inclure ce champ avec
demandes. Le champ peut contenir plusieurs jetons de produit (section 3.8)
et des commentaires identifiant l'agent et les éventuels sous-produits qui forment un
partie importante de l’agent utilisateur. Par convention, les jetons produits
sont classés par ordre d'importance pour l'identification des
application.

User-Agent = "User-Agent" ":" 1*( produit | commentaire )

Exemple:

Agent utilisateur : CERN-LineMode/2.15 libwww/2.17b3

14.44 Varier

La valeur du champ Vary indique l'ensemble des champs d'en-tête de demande qui
détermine entièrement, tant que la réponse est fraîche, si un cache est
autorisé à utiliser la réponse pour répondre à une demande ultérieure
sans revalidation. Pour les réponses impossibles à mettre en cache ou obsolètes, l'option Vary
la valeur du champ informe l'agent utilisateur des critères qui ont été utilisés
pour sélectionner la représentation. Une valeur de champ Varier de "*" implique que
un cache ne peut pas déterminer à partir des en-têtes de requête d'un
demander si cette réponse est la représentation appropriée. Voir
section 13.6 pour l'utilisation du champ d'en-tête Vary par les caches.

Vary = "Vary" ":" ( "*" | 1#nom-champ )

Un serveur HTTP/1.1 DEVRAIT inclure un champ d'en-tête Vary avec n'importe quel
réponse pouvant être mise en cache et soumise à une négociation pilotée par le serveur.
Cela permet à un cache d'interpréter correctement les futures requêtes à ce sujet.
ressource et informe l'agent utilisateur de la présence de négociation



Fielding et coll. Voie des normes [Page 145]
 
RFC 2616 HTTP/1.1 juin 1999


sur cette ressource. Un serveur PEUT inclure un champ d'en-tête Vary avec un
réponse non mise en cache soumise à une négociation pilotée par le serveur,
puisque cela pourrait fournir à l'agent utilisateur des informations utiles sur
les dimensions sur lesquelles la réponse varie au moment de la
réponse.

Une valeur de champ Vary composée d'une liste de noms de champs signale que
la représentation sélectionnée pour la réponse est basée sur une sélection
algorithme qui considère UNIQUEMENT les valeurs du champ d'en-tête de requête répertoriées
dans le choix de la représentation la plus appropriée. Un cache PEUT supposer
que la même sélection sera faite pour les demandes futures avec le
mêmes valeurs pour les noms de champs répertoriés, pendant toute la durée de
dont la réponse est fraîche.

Les noms de champs donnés ne se limitent pas à l'ensemble des normes
champs d'en-tête de requête définis par cette spécification. Les noms de champs sont
insensible à la casse.

Une valeur de champ Vary de "*" signale que des paramètres non spécifiés ne sont pas
limité aux en-têtes de requête (par exemple, l'adresse réseau du
client), jouent un rôle dans la sélection de la représentation de la réponse.
La valeur "*" NE DOIT PAS être générée par un serveur proxy ; ce n'est peut-être que
généré par un serveur d'origine.

14h45 Par

Le champ d'en-tête général Via DOIT être utilisé par les passerelles et les proxys pour
indiquer les protocoles et destinataires intermédiaires entre l'utilisateur
l'agent et le serveur sur requêtes, et entre le serveur d'origine et
le client sur les réponses. Il est analogue au champ "Reçu" de
RFC 822 [9] et est destiné à être utilisé pour suivre les transferts de messages,
éviter les boucles de requêtes et identifier les capacités de protocole de
tous les expéditeurs tout au long de la chaîne demande/réponse.

Via = "Via" ":" 1#( protocole-reçu reçu-par [ commentaire ] )
protocole-reçu = [nom-protocole "/" ] version-protocole
nom-protocole = jeton
version du protocole = jeton
reçu par = ( hôte [ ":" port ] ) | pseudonyme
pseudonyme = jeton

Le protocole reçu indique la version du protocole du message
reçu par le serveur ou le client le long de chaque segment du
chaîne de requête/réponse. La version du protocole reçu est annexée à
la valeur du champ Via lorsque le message est transféré afin que les informations
sur les capacités protocolaires des applications en amont reste
visible par tous les destinataires.




Fielding et coll. Voie des normes [Page 146]
 
RFC 2616 HTTP/1.1 juin 1999


Le nom du protocole est facultatif si et seulement s'il s'agit de "HTTP". Le
Le champ reçu par est normalement l'hôte et le numéro de port facultatif d'un
serveur destinataire ou client qui a ensuite transféré le message.
Cependant, si l'hôte réel est considéré comme une information sensible,
il PEUT être remplacé par un pseudonyme. Si le port n'est pas indiqué, il PEUT
être supposé être le port par défaut du protocole reçu.

Les valeurs du champ Multiple Via représentent chaque proxy ou passerelle qui a
a transmis le message. Chaque destinataire DOIT joindre ses informations
de telle sorte que le résultat final soit ordonné selon la séquence de
transmission des candidatures.

Les commentaires PEUVENT être utilisés dans le champ d’en-tête Via pour identifier le logiciel
du proxy ou de la passerelle destinataire, analogue au User-Agent et
Champs d'en-tête du serveur. Cependant, tous les commentaires dans le champ Via sont
facultatif et PEUT être supprimé par tout destinataire avant de transmettre le
message.

Par exemple, un message de requête peut être envoyé par un utilisateur HTTP/1.0
agent à un proxy interne nommé "fred", qui utilise HTTP/1.1 pour
transmettre la demande à un proxy public sur nowhere.com, qui complète
la demande en la transmettant au serveur d'origine à l'adresse www.ics.uci.edu.
La demande reçue par www.ics.uci.edu aurait alors le texte suivant
Via le champ d'en-tête :

Via : 1.0 fred, 1.1 nowhere.com (Apache/1.1)

Proxy et passerelles utilisés comme portail via un pare-feu réseau
NE DEVRAIT PAS, par défaut, transmettre les noms et les ports des hôtes dans
la région du pare-feu. Cette information NE DEVRAIT être propagée que si
explicitement activé. S'il n'est pas activé, l'hôte reçu par n'importe quel hôte
derrière le pare-feu DEVRAIT être remplacé par un pseudonyme approprié
pour cet hôte.

Pour les organisations qui ont des exigences strictes en matière de confidentialité pour cacher
structures internes, un proxy PEUT combiner une sous-séquence ordonnée de
Via des entrées de champ d'en-tête avec des valeurs de protocole reçues identiques dans
une seule de ces entrées. Par exemple,

Via : 1.0 Ricky, 1.1 Ethel, 1.1 Fred, 1.0 Lucy

pourrait être réduit à

Via : 1.0 ricky, 1.1 mertz, 1.0 lucy







Fielding et coll. Voie des normes [Page 147]
 
RFC 2616 HTTP/1.1 juin 1999


Les candidatures NE DEVRAIENT PAS combiner plusieurs entrées à moins qu'elles ne soient toutes
sous le même contrôle organisationnel et les hôtes ont déjà été
remplacés par des pseudonymes. Les candidatures NE DOIVENT PAS combiner des entrées qui
ont des valeurs de protocole de réception différentes.

14.46 Avertissement

Le champ d’en-tête général Avertissement est utilisé pour transporter des
informations sur l'état ou la transformation d'un message qui
pourrait ne pas être reflété dans le message. Ces informations sont généralement
utilisé pour avertir d'un éventuel manque de transparence sémantique de la part de
opérations de mise en cache ou transformations appliquées au corps de l'entité de
le message.

Les en-têtes d'avertissement sont envoyés avec les réponses en utilisant :

Avertissement = "Avertissement" ":" 1#warning-value

valeur d'avertissement = code d'avertissement SP agent d'avertissement SP texte d'avertissement
[Date d'avertissement SP]

code d'avertissement = 3DIGIT
warn-agent = ( hôte [ ":" port ] ) | pseudonyme
; le nom ou le pseudonyme du serveur ajoutant
; l'en-tête Warning, à utiliser pour le débogage
texte d'avertissement = chaîne entre guillemets
date d'avertissement = <"> Date-HTTP <">

Une réponse PEUT porter plus d’un en-tête Warning.

Le texte d'avertissement DEVRAIT être dans un langage naturel et un jeu de caractères qui
est le plus susceptible d'être intelligible pour l'utilisateur humain recevant le
réponse. Cette décision PEUT être basée sur toutes les connaissances disponibles, telles que
comme emplacement du cache ou de l'utilisateur, le champ Accept-Language dans un
requête, le champ Content-Language dans une réponse, etc. La valeur par défaut
La langue est l'anglais et le jeu de caractères par défaut est ISO-8859-1.

Si un jeu de caractères autre que ISO-8859-1 est utilisé, il DOIT être codé
dans le texte d'avertissement en utilisant la méthode décrite dans la RFC 2047 [14].

Les en-têtes d'avertissement peuvent en général être appliqués à n'importe quel message, cependant
certains codes d'avertissement spécifiques sont spécifiques aux caches et ne peuvent être
appliqué aux messages de réponse. De nouveaux en-têtes d'avertissement DEVRAIENT être ajoutés
après tout en-tête d'avertissement existant. Un cache NE DOIT PAS supprimer
En-tête d'avertissement qu'il a reçu avec un message. Cependant, si un cache
valide avec succès une entrée de cache, il DEVRAIT supprimer tout avertissement
en-têtes précédemment attachés à cette entrée, sauf indication contraire pour




Fielding et coll. Voie des normes [Page 148]
 
RFC 2616 HTTP/1.1 juin 1999


Codes d'avertissement spécifiques. Il DOIT alors ajouter tous les en-têtes d'avertissement reçus
dans la réponse de validation. En d'autres termes, les en-têtes d'avertissement sont ceux
qui serait joint à la réponse pertinente la plus récente.

Lorsque plusieurs en-têtes d'avertissement sont attachés à une réponse, l'utilisateur
l'agent doit en informer l'utilisateur du plus grand nombre possible, dans le
ordre qu'ils apparaissent dans la réponse. S'il n'est pas possible de
informer l'utilisateur de tous les avertissements, l'agent utilisateur DEVRAIT suivre
ces heuristiques :

- Les avertissements qui apparaissent tôt dans la réponse ont la priorité sur
ceux apparaissant plus tard dans la réponse.

- Les avertissements dans le jeu de caractères préféré de l'utilisateur sont prioritaires
sur les avertissements dans d'autres jeux de caractères mais avec un avertissement identique
codes et agents d'avertissement.

Les systèmes qui génèrent plusieurs en-têtes d'avertissement DEVRAIENT les commander avec
ce comportement de l'agent utilisateur à l'esprit.

Les exigences relatives au comportement des caches par rapport aux avertissements sont
indiqué à la section 13.1.2.

Il s'agit d'une liste des codes d'avertissement actuellement définis, chacun avec un
Texte d'avertissement recommandé en anglais et description de sa signification.

110 La réponse est obsolète
DOIT être inclus chaque fois que la réponse renvoyée est périmée.

111 Échec de la revalidation
DOIT être inclus si un cache renvoie une réponse obsolète car un
La tentative de revalidation de la réponse a échoué, en raison d'une incapacité à
atteindre le serveur.

112 Fonctionnement déconnecté
DEVRAIT être inclus si le cache est intentionnellement déconnecté de
le reste du réseau pendant un certain temps.

113 Expiration heuristique
DOIT être inclus si le cache a choisi heuristiquement une fraîcheur
durée de vie supérieure à 24 heures et l'âge de la réponse est supérieur
que 24 heures.

199 Avertissement divers
Le texte d'avertissement PEUT inclure des informations arbitraires à présenter
à un utilisateur humain ou connecté. Un système recevant cet avertissement DOIT
NE PAS entreprendre d'action automatisée, en plus de présenter l'avertissement à
l'utilisateur.



Fielding et coll. Voie des normes [Page 149]
 
RFC 2616 HTTP/1.1 juin 1999


214 Transformation appliquée
DOIT être ajouté par un cache intermédiaire ou un proxy s'il en applique
transformation modifiant le codage du contenu (comme spécifié dans le
Content-Encoding) ou le type de média (comme spécifié dans le
Content-Type) de la réponse, ou le corps de l'entité du
réponse, sauf si ce code d'avertissement apparaît déjà dans la réponse.

299 Divers avertissement persistant
Le texte d'avertissement PEUT inclure des informations arbitraires à présenter
à un utilisateur humain ou connecté. Un système recevant cet avertissement DOIT
NE prenez aucune action automatisée.

Si une implémentation envoie un message avec un ou plusieurs en-têtes d'avertissement
dont la version est HTTP/1.0 ou inférieure, alors l'expéditeur DOIT inclure dans
chaque valeur d'avertissement est une date d'avertissement qui correspond à la date indiquée dans la réponse.

Si une implémentation reçoit un message avec une valeur d'avertissement qui
inclut une date d'avertissement, et cette date d'avertissement est différente de la date
valeur dans la réponse, alors cette valeur d'avertissement DOIT être supprimée de
le message avant de le stocker, de le transférer ou de l’utiliser. (Cela évite
mauvaises conséquences de la mise en cache naïve des champs d'en-tête Warning.) Si tous
des valeurs d'avertissement sont supprimées pour cette raison, l'en-tête Warning
DOIT également être supprimé.

14.47 WWW-Authentifier

Le champ d’en-tête de réponse WWW-Authenticate DOIT être inclus dans 401
Messages de réponse (non autorisés). La valeur du champ se compose d'au
au moins un défi qui indique le(s) schéma(s) d'authentification et
paramètres applicables au Request-URI.

WWW-Authenticate = "WWW-Authenticate" ":" 1#challenge

Le processus d'authentification d'accès HTTP est décrit dans "HTTP
Authentification : authentification d'accès de base et Digest" [43]. Utilisateur
Il est conseillé aux agents de prendre un soin particulier lors de l'analyse du WWW-
Authentifiez la valeur du champ car elle peut contenir plusieurs défis,
ou si plusieurs champs d'en-tête WWW-Authenticate sont fournis, le
le contenu d'un défi lui-même peut contenir une liste de noms séparés par des virgules
paramètres d'authentification.

15 considérations de sécurité

Cette section est destinée à informer les développeurs d'applications, les informations
fournisseurs et utilisateurs des limitations de sécurité dans HTTP/1.1 comme
décrit par ce document. La discussion n'inclut pas
des solutions définitives aux problèmes révélés, même si cela donne
quelques suggestions pour réduire les risques de sécurité.



Fielding et coll. Voie des normes [Page 150]
 
RFC 2616 HTTP/1.1 juin 1999


15.1 Informations personnelles

Les clients HTTP ont souvent accès à de grandes quantités d'informations personnelles
(par exemple, le nom de l'utilisateur, l'emplacement, l'adresse e-mail, les mots de passe, le cryptage
clés, etc.), et DEVRAIT être très prudent pour éviter toute
fuite de ces informations via le protocole HTTP vers d’autres sources.
Nous recommandons fortement qu'une interface pratique soit fournie
pour que l'utilisateur contrôle la diffusion de ces informations, et que
les concepteurs et les exécutants soient particulièrement prudents dans ce domaine.
L'histoire montre que les erreurs dans ce domaine créent souvent une sécurité sérieuse
et/ou des problèmes de confidentialité et génèrent une publicité très négative pour le
société du réalisateur.

15.1.1 Abus des informations du journal du serveur

Un serveur est en mesure de sauvegarder des données personnelles sur un utilisateur
demandes qui pourraient identifier leurs habitudes de lecture ou leurs sujets de
intérêt. Ces informations sont clairement de nature confidentielle et leur
la manipulation peut être limitée par la loi dans certains pays. Les personnes utilisant
le protocole HTTP pour fournir les données est chargé de garantir que
ce matériel n'est pas distribué sans l'autorisation de quiconque
individus identifiables par les résultats publiés.

15.1.2 Transfert d'informations sensibles

Comme tout protocole générique de transfert de données, HTTP ne peut pas réguler le
contenu des données transférées, ni aucune information a priori
méthode de détermination de la sensibilité d’un élément particulier de
informations dans le cadre d’une demande donnée. Donc,
les applications DEVRAIENT fournir autant de contrôle sur ces informations que
possible au fournisseur de ces informations. Quatre champs d'en-tête sont
méritent une mention particulière dans ce contexte : Server, Via, Referer et From.

Révéler la version spécifique du logiciel du serveur peut permettre au
la machine serveur devient plus vulnérable aux attaques contre les logiciels
qui est connu pour contenir des failles de sécurité. Les responsables de la mise en œuvre DEVRAIENT faire le
Champ d’en-tête du serveur, une option configurable.

Les proxys qui servent de portail à travers un pare-feu réseau DEVRAIENT
prendre des précautions particulières concernant le transfert des informations d'en-tête
qui identifie les hôtes derrière le pare-feu. En particulier, ils
DEVRAIT supprimer, ou remplacer par des versions aseptisées, tous les champs Via
généré derrière le pare-feu.

L’en-tête Referer permet d’étudier et d’inverser les modèles de lecture
liens dessinés. Bien qu’il puisse être très utile, son pouvoir peut être abusé
si les détails de l'utilisateur ne sont pas séparés des informations contenues dans




Fielding et coll. Voie des normes [Page 151]
 
RFC 2616 HTTP/1.1 juin 1999


le Référent. Même lorsque les informations personnelles ont été supprimées, le
L'en-tête du référent peut indiquer l'URI d'un document privé dont
la publication serait inappropriée.

Les informations envoyées dans le champ De peuvent entrer en conflit avec celles de l'utilisateur.
intérêts de confidentialité ou la politique de sécurité de leur site, et donc il
NE DEVRAIT PAS être transmis sans que l'utilisateur puisse désactiver,
activer et modifier le contenu du champ. L'utilisateur DOIT être capable
pour définir le contenu de ce champ dans une préférence utilisateur ou
configuration des paramètres par défaut de l'application.

Nous suggérons, sans toutefois l'exiger, qu'une interface à bascule pratique
être fourni à l'utilisateur pour activer ou désactiver l'envoi de From et
Informations sur le référent.

L’en-tête User-Agent (section 14.43) ou Server (section 14.38)
Les champs peuvent parfois être utilisés pour déterminer qu'un client spécifique ou
Le serveur présente une faille de sécurité particulière qui pourrait être exploitée.
Malheureusement, ces mêmes informations sont souvent utilisées à d'autres fins.
à des fins pour lesquelles HTTP ne dispose actuellement pas de meilleur mécanisme.

15.1.3 Codage des informations sensibles dans les URI

Parce que la source d'un lien peut être une information privée ou
révéler une source d'informations par ailleurs privée, il est fortement
Il est recommandé que l'utilisateur puisse choisir si le
Le champ référent est envoyé. Par exemple, un client de navigateur pourrait avoir un
interrupteur à bascule pour une navigation ouverte/anonyme, ce qui
respectivement activer/désactiver l'envoi de Referer et From
information.

Les clients NE DEVRAIENT PAS inclure de champ d'en-tête Referer dans un fichier (non sécurisé)
Requête HTTP si la page référente a été transférée avec un protocole sécurisé
protocole.

Les auteurs de services utilisant le protocole HTTP NE DEVRAIENT PAS utiliser GET
formulaires basés sur la soumission de données sensibles, car cela
provoquer le codage de ces données dans le Request-URI. De nombreux existants
les serveurs, les proxys et les agents utilisateurs enregistreront l'URI de la demande dans certains
endroit où il pourrait être visible par des tiers. Les serveurs peuvent utiliser
Soumission de formulaire basée sur POST à ​​la place

15.1.4 Problèmes de confidentialité liés à l'acceptation des en-têtes

Accepter les en-têtes de requête peut révéler des informations sur l'utilisateur à tous
serveurs auxquels on accède. L'en-tête Accept-Language en particulier
peut révéler des informations que l'utilisateur considérerait comme étant d'ordre privé
nature, car la compréhension de langues particulières est souvent



Fielding et coll. Voie des normes [Page 152]
 
RFC 2616 HTTP/1.1 juin 1999


fortement corrélée à l’appartenance à un groupe ethnique particulier.
Agents utilisateurs qui offrent la possibilité de configurer le contenu d'un
L'en-tête Accept-Language à envoyer dans chaque requête est fortement
encouragé à laisser le processus de configuration inclure un message qui
fait prendre conscience à l’utilisateur de la perte de vie privée qu’elle implique.

Une approche qui limite la perte de confidentialité serait d'utiliser un agent utilisateur
d'omettre l'envoi des en-têtes Accept-Language par défaut, et de demander
l'utilisateur s'il doit ou non commencer à envoyer des en-têtes Accept-Language à un
serveur s'il détecte, en recherchant les champs d'en-tête de réponse Vary
générés par le serveur, qu'un tel envoi pourrait améliorer la qualité
de service.

Élaborer des champs d'en-tête d'acceptation personnalisés par l'utilisateur envoyés dans chaque demande,
en particulier si celles-ci incluent des valeurs de qualité, peuvent être utilisées par les serveurs
en tant qu'identifiants d'utilisateur relativement fiables et durables. Un tel utilisateur
les identifiants permettraient aux fournisseurs de contenu d'effectuer un suivi des traces de clics,
et permettrait aux fournisseurs de contenu collaborateurs de correspondre entre les serveurs
des parcours de clics ou des soumissions de formulaires d'utilisateurs individuels. Notez que pour
de nombreux utilisateurs non derrière un proxy, l'adresse réseau de l'hôte
l'exécution de l'agent utilisateur servira également d'utilisateur de longue durée
identifiant. Dans les environnements où des proxys sont utilisés pour améliorer
confidentialité, les agents utilisateurs doivent être conservateurs en proposant d'accepter
options de configuration d’en-tête aux utilisateurs finaux. Comme une intimité extrême
Par mesure de mesure, les proxys pourraient filtrer les en-têtes d'acceptation dans les requêtes relayées.
Agents utilisateurs à usage général qui fournissent un haut degré d'en-tête
la configurabilité DEVRAIT avertir les utilisateurs de la perte de confidentialité qui peut
être impliqué.

15.2 Attaques basées sur les noms de fichiers et de chemins

Les implémentations de serveurs d'origine HTTP DEVRAIENT veiller à restreindre
les documents renvoyés par les requêtes HTTP soient uniquement ceux qui ont été
prévu par les administrateurs du serveur. Si un serveur HTTP traduit
URI HTTP directement dans les appels du système de fichiers, le serveur DOIT prendre
attention particulière à ne pas signifier des fichiers qui n'étaient pas destinés à être
livré aux clients HTTP. Par exemple, UNIX, Microsoft Windows et
d'autres systèmes d'exploitation utilisent ".." comme composant de chemin pour indiquer un
niveau du répertoire au-dessus du niveau actuel. Sur un tel système, un HTTP
le serveur DOIT interdire une telle construction dans le Request-URI s'il
permettrait autrement l'accès à une ressource en dehors de celles destinées à
être accessible via le serveur HTTP. De même, les fichiers destinés à
référence uniquement en interne au serveur (comme le contrôle d'accès
fichiers, fichiers de configuration et code de script) DOIT être protégé contre
récupération inappropriée, car ils peuvent contenir des informations sensibles
information. L'expérience a montré que des bugs mineurs dans un tel serveur HTTP
les mises en œuvre se sont transformées en risques pour la sécurité.




Fielding et coll. Voie des normes [Page 153]
 
RFC 2616 HTTP/1.1 juin 1999


15.3 Usurpation DNS

Les clients utilisant HTTP s'appuient fortement sur le service de noms de domaine et sont
donc généralement sujets à des attaques de sécurité basées sur la volonté délibérée
mauvaise association des adresses IP et des noms DNS. Les clients doivent être
prudent en supposant la validité continue d’un numéro IP/nom DNS
association.

En particulier, les clients HTTP DEVRAIENT s'appuyer sur leur résolveur de noms pour
confirmation d’une association numéro IP/nom DNS, plutôt que
mise en cache du résultat des recherches précédentes de nom d'hôte. De nombreuses plateformes
peut déjà mettre en cache les recherches de nom d'hôte localement, le cas échéant, et
ils DEVRAIENT être configurés pour le faire. Il convient que ces recherches
être mis en cache, cependant, uniquement lorsque les informations TTL (Time To Live)
signalé par le serveur de noms, il est probable que le fichier mis en cache
les informations resteront utiles.

Si les clients HTTP mettent en cache les résultats des recherches de noms d'hôtes afin de
obtenir une amélioration des performances, ils DOIVENT respecter le TTL
informations rapportées par DNS.

Si les clients HTTP ne respectent pas cette règle, ils pourraient être usurpés lorsque
l'adresse IP d'un serveur précédemment consulté change. En tant que réseau
la renumérotation devrait devenir de plus en plus courante [24], le
la possibilité de cette forme d’attaque va augmenter. En observant ceci
Cette exigence réduit ainsi cette vulnérabilité potentielle en matière de sécurité.

Cette exigence améliore également le comportement d'équilibrage de charge des clients
pour les serveurs répliqués utilisant le même nom DNS et réduit le
probabilité qu'un utilisateur rencontre un échec dans l'accès à des sites qui
utilisez cette stratégie.

15.4 En-têtes d'emplacement et usurpation d'identité

Si un seul serveur prend en charge plusieurs organisations qui ne font pas confiance
les uns les autres, alors il DOIT vérifier les valeurs de Location et Content-
En-têtes d'emplacement dans les réponses générées sous le contrôle de
ont déclaré aux organisations de s'assurer qu'elles ne tentent pas de
invalider des ressources sur lesquelles ils n’ont aucune autorité.

15.5 Problèmes de disposition du contenu

RFC 1806 [35], à partir de laquelle le Content-Disposition souvent implémenté
(voir section 19.5.1) l'en-tête en HTTP est dérivé, a un certain nombre de très
de sérieuses considérations de sécurité. Content-Disposition ne fait pas partie de
la norme HTTP, mais comme elle est largement implémentée, nous sommes
documenter son utilisation et ses risques pour les implémenteurs. Voir RFC 2183 [49]
(qui met à jour la RFC 1806) pour plus de détails.



Fielding et coll. Voie des normes [Page 154]
 
RFC 2616 HTTP/1.1 juin 1999


15.6 Identifiants d'authentification et clients inactifs

Les clients HTTP et les agents utilisateurs existants conservent généralement l'authentification
informations indéfiniment. HTTP/1.1. ne fournit pas de méthode pour un
serveur pour demander aux clients de supprimer ces informations d'identification mises en cache. C'est
un défaut important qui nécessite des extensions supplémentaires à HTTP.
Circonstances dans lesquelles la mise en cache des informations d'identification peut interférer avec le
Le modèle de sécurité de l'application inclut, sans s'y limiter :

- Clients restés inactifs pendant une période prolongée suite à
que le serveur pourrait souhaiter amener le client à réinviter le
utilisateur pour les informations d’identification.

- Applications qui incluent une indication de fin de session
(comme un bouton « déconnexion » ou « validation » sur une page), après quoi
le côté serveur de l'application « sait » qu'il n'y a pas de
raison supplémentaire pour laquelle le client conserve ses informations d'identification.

Cette question fait actuellement l'objet d'une étude distincte. Il existe un certain nombre de travaux-
contourne certaines parties de ce problème, et nous encourageons l'utilisation de
protection par mot de passe dans les économiseurs d'écran, les délais d'inactivité et autres
méthodes qui atténuent les problèmes de sécurité inhérents à ce
problème. En particulier, les agents utilisateurs qui mettent en cache les informations d'identification sont
encouragés à fournir un mécanisme facilement accessible pour se débarrasser
informations d'identification mises en cache sous le contrôle de l'utilisateur.

15.7 Proxy et mise en cache

De par leur nature même, les proxys HTTP sont des hommes du milieu, et
représentent une opportunité pour les attaques de l’homme du milieu. Compromis de
les systèmes sur lesquels fonctionnent les proxys peuvent entraîner une sécurité sérieuse
et les problèmes de confidentialité. Les proxys ont accès aux informations liées à la sécurité
informations, informations personnelles sur les utilisateurs individuels et
organisations et informations exclusives appartenant aux utilisateurs et
fournisseurs de contenu. Un proxy compromis, ou un proxy mis en œuvre ou
configuré sans égard aux considérations de sécurité et de confidentialité,
pourrait être utilisé pour commettre un large éventail d’attaques potentielles.

Les opérateurs de proxy doivent protéger les systèmes sur lesquels les proxys s'exécutent.
ils protégeraient tout système contenant ou transportant des informations sensibles
information. En particulier, les informations de journalisation recueillies auprès des proxys sont souvent
contient des informations personnelles hautement sensibles et/ou des informations
sur les organisations. Les informations du journal doivent être soigneusement gardées et
des directives d'utilisation appropriées sont élaborées et suivies. (Section
15.1.1).






Fielding et coll. Voie des normes [Page 155]
 
RFC 2616 HTTP/1.1 juin 1999


Les proxys de mise en cache fournissent des vulnérabilités potentielles supplémentaires, car
le contenu du cache représente une cible attractive pour
exploitation malveillante. Parce que le contenu du cache persiste après un HTTP
la requête est terminée, une attaque sur le cache peut révéler des informations
longtemps après qu'un utilisateur estime que les informations ont été supprimées de
le réseau. Par conséquent, le contenu du cache doit être protégé comme
information sensible.

Les responsables de la mise en œuvre du proxy doivent tenir compte de la confidentialité et de la sécurité
implications de leurs décisions de conception et de codage, ainsi que des
options de configuration qu'ils proposent aux opérateurs proxy (en particulier les
configuration par défaut).

Les utilisateurs d'un proxy doivent être conscients qu'ils ne sont pas plus dignes de confiance que
les personnes qui gèrent le proxy ; HTTP lui-même ne peut pas résoudre ce problème.

L'utilisation judicieuse de la cryptographie, le cas échéant, peut suffire à
protéger contre un large éventail d’attaques en matière de sécurité et de confidentialité. Tel
la cryptographie dépasse la portée de la spécification HTTP/1.1.

15.7.1 Attaques par déni de service sur les proxys

Ils existent. Il est difficile de se défendre contre eux. Les recherches se poursuivent.
Méfiez-vous.

16 Remerciements

Cette spécification fait un usage intensif du BNF augmenté et du générique
constructions définies par David H. Crocker pour la RFC 822 [9]. De même, il
réutilise de nombreuses définitions fournies par Nathaniel Borenstein et
Ned Freed pour MIME [7]. Nous espérons que leur inclusion dans ce
la spécification aidera à réduire la confusion passée sur la relation
entre les formats de messages HTTP et Internet.

Le protocole HTTP a considérablement évolué au fil des années. Il a
bénéficié d'une communauté de développeurs importante et active - les nombreux
personnes qui ont participé à la liste de diffusion www-talk - et c'est
cette communauté qui a été la plus responsable du succès de
HTTP et du World-Wide Web en général. Marc Andreessen, Robert
Cailliau, Daniel W. Connolly, Bob Denny, John Franks, Jean-François
Groff, Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob
McCool, Lou Montulli, Dave Raggett, Tony Sanders et Marc
VanHeyningen mérite une reconnaissance particulière pour ses efforts dans
définir les premiers aspects du protocole.

Ce document a grandement bénéficié des commentaires de tous ceux
participer au HTTP-WG. En plus de ceux déjà mentionnés,
les personnes suivantes ont contribué à cette spécification :



Fielding et coll. Voie des normes [Page 156]
 
RFC 2616 HTTP/1.1 juin 1999


Gary AdamsRoss Patterson
Harald Tveit Alvestrand Albert Lunde
Keith Ball John C. Mallery
Brian BehlendorfJean-Philippe Martin-Flatin
Paul Burchard-Mitra
Maurizio CodognoDavid Morris
Mike Cowlishaw Gavin Nicol
Roman CzyborraBill Perry
Michael A. Dolan Jeffrey Perry
David J. Fiander Scott Powers
Alan FreierOwen Rees
Marc Hedlund Luigi Rizzo
Greg HerlihyDavid Robinson
Koen HoltmanMarc Salomon
Alex Hopmann Rich Salz
Bob JerniganAllan M. Schiffman
Shel KaphanJim Seidman
Rohit KhareChuck Shotton
John Klensin Eric W. Évier
Martijn Koster Simon E. Spero
Alexei KosutRichard N.Taylor
David M. Kristol Robert S. Thau
Daniel LaLiberte Bill (BearHeart) Weinman
Ben Laurie François Yergeau
Paul J. LeachMary Ellen Zurko
Daniel DuBois, Josh Cohen


Une grande partie du contenu et de la présentation de la conception de la mise en cache est due à
suggestions et commentaires de personnes, notamment : Shel Kaphan,
Paul Leach, Koen Holtman, David Morris et Larry Masinter.

La plupart des spécifications des gammes sont basées sur le travail effectué à l'origine.
par Ari Luotonen et John Franks, avec la contribution supplémentaire de Steve
Zilles.

Merci aux "hommes des cavernes" de Palo Alto. Tu sais qui tu es.

Jim Gettys (le rédacteur actuel de ce document) souhaite particulièrement
remercier Roy Fielding, le précédent rédacteur en chef de ce document, ainsi que
avec John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen
Holtman, John Franks, Josh Cohen, Alex Hopmann, Scott Lawrence et
Larry Masinter pour leur aide. Et merci particulièrement à Jeff
Mogul et Scott Lawrence pour avoir effectué l'audit « DOIT/MAI/DEVRAIT ».







Fielding et coll. Voie des normes [Page 157]
 
RFC 2616 HTTP/1.1 juin 1999


Le groupe Apache, Anselm Baird-Smith, auteur de Jigsaw, et Henrik
Frystyk a implémenté la RFC 2068 très tôt et nous souhaitons les remercier pour le
découverte de nombreux problèmes que ce document tente de résoudre
rectifier.

17 Références

[1] H. Alvestrand, "Balises pour l'identification des langues", RFC
1766, mars 1995.

[2] Anklesaria, F., McCahill, M., Lindner, P., Johnson, D., Torrey,
D. et B. Alberti, "The Internet Gopher Protocol (un protocole distribué
RFC 1436, mars 1993.

[3] T. Berners-Lee, "Identificateurs de ressources universels sur le Web", RFC
1630, juin 1994.

[4] Berners-Lee, T., Masinter, L. et M. McCahill, "Uniform Resource
Localisateurs (URL)", RFC 1738, décembre 1994.

[5] Berners-Lee, T. et D. Connolly, "Langage de balisage hypertexte -
2.0", RFC 1866, novembre 1995.

[6] Berners-Lee, T., Fielding, R. et H. Frystyk, "Transfert hypertexte
Protocole -- HTTP/1.0", RFC 1945, mai 1996.

[7] Freed, N. et N. Borenstein, « Messagerie Internet polyvalente
Extensions (MIME) Première partie : Format des corps des messages Internet",
RFC2045, novembre 1996.

[8] Braden, R., "Exigences pour les hôtes Internet -- Communication
Couches", STD 3, RFC 1123, octobre 1989.

[9] Crocker, D., "Norme pour le format du texte Internet ARPA
Messages", STD 11, RFC 822, août 1982.

[10] Davis, F., Kahle, B., Morris, H., Salem, J., Shen, T., Wang, R.,
Sui, J. et M. Grinbaum, "Prototype du protocole d'interface WAIS
Spécification fonctionnelle », (v1.5), Thinking Machines
Société, avril 1990.

[11] R. Fielding, "Localisateurs de ressources uniformes relatifs", RFC 1808,
Juin 1995.

[12] Horton, M. et R. Adams, "Standard pour l'échange de USENET
Messages", RFC 1036, décembre 1987.





Fielding et coll. Voie des normes [Page 158]
 
RFC 2616 HTTP/1.1 juin 1999


[13] B. Kantor et P. Lapsley, "Protocole de transfert de nouvelles sur le réseau", RFC.
977, février 1986.

[14] Moore, K., "MIME (MultiPurpose Internet Mail Extensions) Partie
Troisième : Extensions d'en-tête de message pour le texte non-ASCII", RFC 2047,
Novembre 1996.

[15] E. Nebel et L. Masinter, "Téléchargement de fichiers basé sur un formulaire en HTML", RFC
1867, novembre 1995.

[16] J. Postel, "Simple Mail Transfer Protocol", STD 10, RFC 821,
Août 1982.

[17] J. Postel, "Procédure d'enregistrement du type de support", RFC 1590,
Novembre 1996.

[18] J. Postel et J. Reynolds, "Protocole de transfert de fichiers", STD 9, RFC
959, octobre 1985.

[19] J. Reynolds et J. Postel, "Numéros attribués", STD 2, RFC 1700,
Octobre 1994.

[20] Sollins, K. et L. Masinter, « Exigences fonctionnelles pour
Noms de ressources uniformes", RFC 1737, décembre 1994.

[21] US-ASCII. Jeu de caractères codés - Code standard américain 7 bits pour
Échange d'informations. Norme ANSI X3.4-1986, ANSI, 1986.

[22] ISO-8859. Norme internationale -- Traitement de l'information --
Jeux de caractères graphiques codés sur un octet sur 8 bits --
Partie 1 : alphabet latin n° 1, ISO-8859-1:1987.
Partie 2 : alphabet latin n°2, ISO-8859-2, 1987.
Partie 3 : Alphabet latin n° 3, ISO-8859-3, 1988.
Partie 4 : Alphabet latin n°4, ISO-8859-4, 1988.
Partie 5 : alphabet latin/cyrillique, ISO-8859-5, 1988.
Partie 6 : Alphabet latin/arabe, ISO-8859-6, 1987.
Partie 7 : alphabet latin/grec, ISO-8859-7, 1987.
Partie 8 : alphabet latin/hébreu, ISO-8859-8, 1988.
Partie 9 : Alphabet latin n° 5, ISO-8859-9, 1990.

[23] J. Meyers et M. Rose, "Le champ d'en-tête Content-MD5", RFC
1864, octobre 1995.

[24] B. Carpenter et Y. Rekhter, "La renumérotation nécessite du travail", RFC.
1900, février 1996.

[25] Deutsch, P., "Spécification du format de fichier GZIP version 4.3", RFC
1952, mai 1996.



Fielding et coll. Voie des normes [Page 159]
 
RFC 2616 HTTP/1.1 juin 1999


[26] Venkata N. Padmanabhan et Jeffrey C. Mogul. "Améliorer HTTP
Latence", Réseaux informatiques et systèmes RNIS, v. 28, pp. 25-35,
Décembre 1995. Version légèrement révisée de l'article dans Proc. 2ème
Conférence internationale WWW '94 : Mosaic and the Web, octobre 1994,
qui est disponible sur
http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLat
ency.html.

[27] Joe Touch, John Heidemann et Katia Obraczka. "Analyse du HTTP
Performance", <URL : http://www.isi.edu/touch/pubs/http-perf96/>,
Rapport de recherche ISI ISI/RR-98-463 (rapport original daté du 1er août 2017).
1996), USC/Information Sciences Institute, août 1998.

[28] Mills, D., "Spécification du protocole de temps réseau (version 3),
Mise en œuvre et analyse", RFC 1305, mars 1992.

[29] Deutsch, P., "Spécification du format de données compressées DEFLATE
RFC 1951, version 1.3, mai 1996.

[30] S. Spero, « Analyse des problèmes de performances HTTP »,
http://sunsite.unc.edu/mdma-release/http-prob.html.

[31] Deutsch, P. et J. Gailly, "Format de données compressées ZLIB
Spécification version 3.3", RFC 1950, mai 1996.

[32] Franks, J., Hallam-Baker, P., Hostetler, J., Leach, P.,
Luotonen, A., Sink, E. et L. Stewart, « Une extension au HTTP :
"Authentification d'accès Digest", RFC 2069, janvier 1997.

[33] Fielding, R., Gettys, J., Mogul, J., Frystyk, H. et T.
Berners-Lee, "Protocole de transfert hypertexte -- HTTP/1.1", RFC
2068, janvier 1997.

[34] Bradner, S., "Mots clés à utiliser dans les RFC pour indiquer les exigences
Niveaux", BCP 14, RFC 2119, mars 1997.

[35] Troost, R. et Dorner, S., "Présentation communicative
Informations dans les messages Internet : la disposition du contenu
En-tête", RFC 1806, juin 1995.

[36] Mogul, J., Fielding, R., Gettys, J. et H. Frystyk, « Utilisation et
Interprétation des numéros de version HTTP", RFC 2145, mai 1997.
[jg639]

[37] J. Palme, "En-têtes de messages Internet courants", RFC 2076, février
1997. [jg640]





Fielding et coll. Voie des normes [Page 160]
 
RFC 2616 HTTP/1.1 juin 1999


[38] Yergeau, F., "UTF-8, un format de transformation d'Unicode et
ISO-10646", RFC 2279, janvier 1998. [jg641]

[39] Nielsen, HF, Gettys, J., Baird-Smith, A., Prud'hommeaux, E.,
Lie, H. et C. Lilley. "Effets sur les performances du réseau de
HTTP/1.1, CSS1 et PNG," Actes de l'ACM SIGCOMM '97, Cannes
France, septembre 1997.[jg642]

[40] Freed, N. et N. Borenstein, "MultiPurpose Internet Mail
Extensions (MIME), deuxième partie : types de médias", RFC 2046, novembre.
1996. [jg643]

[41] Alvestrand, H., "Politique de l'IETF sur les jeux de caractères et les langues",
RFC 2277, BCP 18, janvier 1998. [jg644]

[42] Berners-Lee, T., Fielding, R. et L. Masinter, "Uniform Resource
Identifiants (URI) : syntaxe et sémantique génériques", RFC 2396,
Août 1998. [jg645]

[43] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
Leach, P., Luotonen, A., Sink, E. et L. Stewart, "HTTP
Authentification : authentification d'accès de base et Digest", RFC
2617, juin 1999. [jg646]

[44] Luotonen, A., "Tunnelage des protocoles basés sur TCP via un proxy Web
serveurs », Work in Progress. [jg647]

[45] Palme, J. et A. Hopmann, "MIME E-mail Encapsulation of
Documents agrégés, tels que HTML (MHTML)", RFC 2110, mars
1997.

[46] Bradner, S., "Le processus de normalisation Internet - Révision 3", BCP
9, RFC 2026, octobre 1996.

[47] Masinter, L., "Protocole de contrôle de la cafetière hypertexte
(HTCPCP/1.0)", RFC 2324, 1er avril 1998.

[48] ​​Freed, N. et N. Borenstein, "MultiPurpose Internet Mail
Extensions (MIME), cinquième partie : critères de conformité et exemples",
RFC2049, novembre 1996.

[49] Troost, R., Dorner, S. et K. Moore, "Présentation communicative
Informations dans les messages Internet : l'en-tête Content-Disposition
Field", RFC 2183, août 1997.

Fielding et coll. Voie des normes [Page 161]
 
RFC 2616 HTTP/1.1 juin 1999


18 adresses d'auteurs

Roy T. Fielding
Information et informatique
Université de Californie, Irvine
Irvine, Californie 92697-3425, États-Unis

Télécopieur : +1 (949) 824-1715
Courriel : fielding@ics.uci.edu


James Gettys
World Wide Web Consortium
Laboratoire d'informatique du MIT
545 Place de la Technologie
Cambridge, MA 02139, États-Unis

Télécopie : +1 (617) 258 8682
Courriel : jg@w3.org


Jeffrey C. Mogul
Laboratoire de recherche occidental
Société informatique Compaq
250, avenue de l'Université
Palo Alto, Californie, 94305, États-Unis

Courriel : mogul@wrl.dec.com


Henrik Frystyk Nielsen
World Wide Web Consortium
Laboratoire d'informatique du MIT
545 Place de la Technologie
Cambridge, MA 02139, États-Unis

Télécopie : +1 (617) 258 8682
Courriel : friedstyk@w3.org


Larry Masinter
Société Xerox
3333, chemin Coyote Hill
Palo Alto, Californie 94034, États-Unis

Courriel : masinter@parc.xerox.com

Fielding et coll. Voie des normes [Page 162]
 
RFC 2616 HTTP/1.1 juin 1999


Paul J.Leach
Microsoft Corporation
1 méthode Microsoft
Redmond, WA 98052, États-Unis

Courriel : paulle@microsoft.com


Tim Berners-Lee
Directeur, Consortium World Wide Web
Laboratoire d'informatique du MIT
545 Place de la Technologie
Cambridge, MA 02139, États-Unis

Télécopie : +1 (617) 258 8682
Courriel : timbl@w3.org

Fielding et coll. Voie des normes [Page 163]
 
RFC 2616 HTTP/1.1 juin 1999


19 Annexes

19.1 Type de média Internet message/http et application/http

En plus de définir le protocole HTTP/1.1, ce document sert
comme spécification pour le type de média Internet "message/http" et
"application/http". Le type message/http peut être utilisé pour joindre un
requête HTTP unique ou message de réponse, à condition qu'il obéisse aux
Restrictions MIME pour tous les types de "messages" concernant la longueur de ligne et
encodages. Le type application/http peut être utilisé pour joindre un
pipeline d'un ou plusieurs messages de requête ou de réponse HTTP (non
mélangés). Ce qui suit doit être enregistré auprès de l'IANA [17].

Nom du type de média : message
Nom du sous-type de média : http
Paramètres requis : aucun
Paramètres facultatifs : version, msgtype
version : le numéro de version HTTP du message ci-joint
(par exemple, "1.1"). Si elle n'est pas présente, la version peut être
déterminé à partir de la première ligne du corps.
msgtype : le type de message – « demande » ou « réponse ». Sinon
présent, le type peut être déterminé à partir du premier
ligne du corps.
Considérations d'encodage : seuls "7 bits", "8 bits" ou "binaire" sont
permis
Considérations de sécurité : aucune

Nom du type de média : application
Nom du sous-type de média : http
Paramètres requis : aucun
Paramètres facultatifs : version, msgtype
version : le numéro de version HTTP des messages ci-joints
(par exemple, "1.1"). Si elle n'est pas présente, la version peut être
déterminé à partir de la première ligne du corps.
msgtype : le type de message – « demande » ou « réponse ». Sinon
présent, le type peut être déterminé à partir du premier
ligne du corps.
Considérations sur le codage : messages HTTP entourés par ce type
sont au format « binaire » ; l'utilisation d'un produit approprié
Content-Transfer-Encoding est requis lorsque
transmis par e-mail.
Considérations de sécurité : aucune









Fielding et coll. Voie des normes [Page 164]
 
RFC 2616 HTTP/1.1 juin 1999


19.2 Type de média Internet multipart/byteranges

Lorsqu'un message de réponse HTTP 206 (Contenu partiel) inclut le
contenu de plusieurs plages (une réponse à une demande de plusieurs
plages ne se chevauchant pas), celles-ci sont transmises sous forme de fichiers en plusieurs parties
Corps du message. Le type de média à cet effet est appelé
"multipart/byteranges".

Le type de média multipart/byteranges comprend deux ou plusieurs parties, chacune
avec ses propres champs Content-Type et Content-Range. Le nécessaire
Le paramètre de limite spécifie la chaîne de limite utilisée pour séparer
chaque partie du corps.

Nom du type de média : multipart
Nom du sous-type de média : octets
Paramètres obligatoires : limite
Paramètres facultatifs : aucun
Considérations d'encodage : seuls "7 bits", "8 bits" ou "binaire" sont
permis
Considérations de sécurité : aucune


Par exemple:

HTTP/1.1 206 Contenu partiel
Date : mercredi 15 novembre 1995, 06:25:24 GMT
Dernière modification : mercredi 15 novembre 1995 à 04:58:08 GMT
Type de contenu : multipart/byteranges ; limite=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES
Type de contenu : application/pdf
Plage de contenu : octets 500-999/8000

...la première gamme...
--THIS_STRING_SEPARATES
Type de contenu : application/pdf
Plage de contenu : octets 7 000 à 7 999/8 000

...la deuxième gamme
--THIS_STRING_SEPARATES--

Remarques:

1) Des CRLF supplémentaires peuvent précéder la première chaîne de limite dans le
entité.






Fielding et coll. Voie des normes [Page 165]
 
RFC 2616 HTTP/1.1 juin 1999


2) Bien que la RFC 2046 [40] permette à la chaîne de limite d'être
cité, certaines implémentations existantes gèrent une limite citée
chaîne de manière incorrecte.

3) Un certain nombre de navigateurs et de serveurs ont été codés selon une première version
de la spécification byteranges pour utiliser un type de média de
multipart/x-byteranges, ce qui est presque, mais pas tout à fait
compatible avec la version documentée dans HTTP/1.1.

19.3 Applications tolérantes

Bien que ce document spécifie les exigences pour la génération
des messages HTTP/1.1, toutes les applications ne seront pas correctes dans leur
mise en œuvre. Nous recommandons donc que les applications opérationnelles
être tolérant envers les écarts chaque fois que ces écarts peuvent être
interprété sans ambiguïté.

Les clients DEVRAIENT être tolérants dans l'analyse de la Status-Line et des serveurs
tolérant lors de l'analyse de la Request-Line. En particulier, ils DEVRAIENT
accepter n'importe quelle quantité de caractères SP ou HT entre les champs, même si
un seul SP est requis.

Le terminateur de ligne pour les champs d'en-tête de message est la séquence CRLF.
Cependant, nous recommandons aux applications, lors de l'analyse de ces en-têtes,
reconnaître un seul LF comme terminateur de ligne et ignorer le CR principal.

Le jeu de caractères d'un corps d'entité DEVRAIT être étiqueté comme le plus bas
dénominateur commun des codes de caractères utilisés au sein de ce corps, avec
l'exception selon laquelle il est préférable de ne pas étiqueter l'entité plutôt que de l'étiqueter
l'entité avec les étiquettes US-ASCII ou ISO-8859-1. Voir la section 3.7.1
et 3.4.1.

Règles supplémentaires pour les exigences relatives à l'analyse et au codage des dates
et d'autres problèmes potentiels avec les encodages de date incluent :

- Les clients et caches HTTP/1.1 DEVRAIENT supposer qu'une date RFC-850
qui semble se situer dans plus de 50 ans est en fait
dans le passé (cela aide à résoudre le problème de "l'an 2000").

- Une implémentation HTTP/1.1 PEUT représenter en interne un
La date d'expiration est antérieure à la valeur appropriée, mais NE DOIT PAS
représente en interne une date d'expiration analysée comme postérieure à la
valeur appropriée.

- Tous les calculs liés à l'expiration DOIVENT être effectués en GMT. Le
le fuseau horaire local NE DOIT PAS influencer le calcul ou la comparaison
d'un âge ou d'un délai d'expiration.




Fielding et coll. Voie des normes [Page 166]
 
RFC 2616 HTTP/1.1 juin 1999


- Si un en-tête HTTP porte incorrectement une valeur de date avec une heure
zone autre que GMT, elle DOIT être convertie en GMT à l'aide du
conversion la plus conservatrice possible.

19.4 Différences entre les entités HTTP et les entités RFC 2045

HTTP/1.1 utilise de nombreuses constructions définies pour Internet Mail (RFC
822 [9]) et les extensions de messagerie Internet polyvalentes (MIME [7]) pour
permettre aux entités d'être transmises dans une variété ouverte de
représentations et avec des mécanismes extensibles. Cependant, la RFC 2045
traite du courrier, et HTTP possède quelques fonctionnalités différentes de
celles décrites dans la RFC 2045. Ces différences ont été soigneusement choisies
pour optimiser les performances sur les connexions binaires, pour permettre une plus grande
liberté dans l'utilisation de nouveaux types de médias, pour faire des comparaisons de dates
plus facile, et de reconnaître la pratique de certains premiers serveurs HTTP
et clients.

Cette annexe décrit les domaines spécifiques dans lesquels HTTP diffère de RFC.
2045. Les proxys et les passerelles vers des environnements MIME stricts DEVRAIENT être
conscient de ces différences et fournir les conversions appropriées
Où il faut. Proxy et passerelles des environnements MIME vers HTTP
il faut également être conscient des différences car certaines conversions
pourrait être nécessaire.

19.4.1 Version MIME

HTTP n'est pas un protocole compatible MIME. Cependant, les messages HTTP/1.1 PEUVENT
inclure un seul champ d'en-tête général MIME-Version pour indiquer ce que
version du protocole MIME a été utilisée pour construire le message. Utiliser
du champ d'en-tête MIME-Version indique que le message est en
conformité totale avec le protocole MIME (tel que défini dans la RFC 2045[7]).
Les proxys/passerelles sont chargés de garantir une conformité totale (lorsque
possible) lors de l'exportation de messages HTTP vers des environnements MIME stricts.

Version MIME = "Version MIME" ":" 1*CHIFFRE "." 1 * CHIFFRE

La version MIME « 1.0 » est la version par défaut pour une utilisation dans HTTP/1.1. Cependant,
L'analyse et la sémantique des messages HTTP/1.1 sont définies par ce document
et non la spécification MIME.

19.4.2 Conversion en forme canonique

La RFC 2045 [7] exige qu'une entité de messagerie Internet soit convertie en
forme canonique avant d'être transférée, comme décrit à la section 4
de la RFC 2049 [48]. La section 3.7.1 de ce document décrit les formulaires
autorisé pour les sous-types du type de média "texte" lorsqu'ils sont transmis via
HTTP. La RFC 2046 exige que le contenu avec un type de « texte » représente
les sauts de ligne sont CRLF et interdisent l'utilisation de CR ou LF en dehors de la ligne



Fielding et coll. Voie des normes [Page 167]
 
RFC 2616 HTTP/1.1 juin 1999


séquences de rupture. HTTP permet aux CRLF, CR nu et LF nu d'indiquer un
saut de ligne dans le contenu du texte lorsqu'un message est transmis via
HTTP.

Lorsque cela est possible, un proxy ou une passerelle HTTP vers un MIME strict
l'environnement DEVRAIT traduire tous les sauts de ligne dans le support texte
types décrits dans la section 3.7.1 de ce document selon la RFC 2049
forme canonique de CRLF. Attention cependant, cela peut être compliqué
par la présence d'un Content-Encoding et par le fait que HTTP
permet l'utilisation de certains jeux de caractères qui n'utilisent pas les octets 13 et
10 pour représenter CR et LF, comme c'est le cas pour certains multi-octets
jeux de caractères.

Les développeurs doivent noter que la conversion brisera tout système cryptographique.
sommes de contrôle appliquées au contenu original à moins que le contenu original
est déjà sous forme canonique. La forme canonique est donc
recommandé pour tout contenu utilisant de telles sommes de contrôle dans HTTP.

19.4.3 Conversion des formats de date

HTTP/1.1 utilise un ensemble restreint de formats de date (section 3.3.1) pour
simplifier le processus de comparaison de dates. Proxy et passerelles de
d'autres protocoles DEVRAIENT garantir que tout champ d'en-tête Date présent dans un
le message est conforme à l'un des formats HTTP/1.1 et réécrivez la date
si nécessaire.

19.4.4 Introduction du codage de contenu

La RFC 2045 n'inclut aucun concept équivalent à celui de HTTP/1.1
Champ d’en-tête Content-Encoding. Puisque cela agit comme un modificateur sur le
type de média, proxys et passerelles de HTTP à compatible MIME
les protocoles DOIVENT soit changer la valeur de l'en-tête Content-Type
champ ou décoder le corps de l’entité avant de transmettre le message. (Quelques
des applications expérimentales de Content-Type pour la messagerie Internet ont utilisé
un paramètre de type de média de ";conversions=<content-coding>" à effectuer
une fonction équivalente à Content-Encoding. Cependant, ce paramètre est
ne fait pas partie de la RFC 2045.)

19.4.5 Aucun encodage de transfert de contenu

HTTP n'utilise pas le champ Content-Transfer-Encoding (CTE) de la RFC
2045. Proxies et passerelles des protocoles compatibles MIME vers HTTP DOIVENT
supprimer tout encodage CTE non identitaire ("quoted-printable" ou "base64")
avant de transmettre le message de réponse à un client HTTP.

Les proxys et les passerelles des protocoles compatibles HTTP vers MIME sont
responsable de s’assurer que le message est dans le bon format
et le codage pour un transport sûr sur ce protocole, où « sécurisé



Fielding et coll. Voie des normes [Page 168]
 
RFC 2616 HTTP/1.1 juin 1999


transport" est défini par les limitations du protocole utilisé.
Un tel proxy ou passerelle DEVRAIT étiqueter les données avec un
Content-Transfer-Encoding si cela améliorera la probabilité de
transport sûr selon le protocole de destination.

19.4.6 Introduction du codage par transfert

HTTP/1.1 introduit le champ d'en-tête Transfer-Encoding (section
14.41). Les proxys/passerelles DOIVENT supprimer tout codage de transfert avant
transmettre un message via un protocole compatible MIME.

Un processus de décodage du codage de transfert « fragmenté » (section 3.6)
peut être représenté en pseudo-code comme suit :

longueur := 0
lire la taille du morceau, l'extension du morceau (le cas échéant) et le CRLF
while (taille du morceau > 0) {
lire les données en bloc et CRLF
ajouter des données de bloc au corps de l'entité
longueur := longueur + taille du morceau
lire la taille des morceaux et le CRLF
}
lire l'en-tête de l'entité
while (en-tête d'entité non vide) {
ajouter l'en-tête d'entité aux champs d'en-tête existants
lire l'en-tête de l'entité
}
Contenu-Longueur := longueur
Supprimer « chunked » de Transfer-Encoding

19.4.7 Limites de MHTML et de longueur de ligne

Implémentations HTTP qui partagent du code avec les implémentations MHTML [45]
devez être conscient des limitations de longueur de ligne MIME. Puisque HTTP ne
ayant cette limitation, HTTP ne plie pas les longues lignes. Messages MHTML
transportés par HTTP suivent toutes les conventions de MHTML, y compris
limitations de longueur de ligne et pliage, canonisation, etc., puisque
HTTP transporte tous les corps de message en tant que charge utile (voir section 3.7.2) et
n'interprète pas le contenu ni les lignes d'en-tête MIME qui pourraient être
contenues dans celui-ci.

19.5 Fonctionnalités supplémentaires

Les RFC 1945 et RFC 2068 documentent les éléments de protocole utilisés par certains
implémentations HTTP existantes, mais pas de manière cohérente et correcte
dans la plupart des applications HTTP/1.1. Il est conseillé aux responsables de la mise en œuvre d'être
conscient de ces caractéristiques, mais ne peut pas compter sur leur présence ou
interopérabilité avec d’autres applications HTTP/1.1. Certains d'entre eux



Fielding et coll. Voie des normes [Page 169]
 
RFC 2616 HTTP/1.1 juin 1999


décrire les fonctionnalités expérimentales proposées, et certaines décrire les fonctionnalités
que le déploiement expérimental a trouvé manquant et qui sont maintenant abordés dans
la spécification HTTP/1.1 de base.

Un certain nombre d'autres en-têtes, tels que Content-Disposition et Title,
à partir de SMTP et MIME sont également souvent implémentés (voir RFC 2076 [37]).

19.5.1 Disposition du contenu

Le champ d’en-tête de réponse Content-Disposition a été proposé comme
signifie que le serveur d'origine suggère un nom de fichier par défaut si l'utilisateur
demande que le contenu soit enregistré dans un fichier. Cet usage est dérivé
à partir de la définition de Content-Disposition dans la RFC 1806 [35].

content-disposition = "Contenu-Disposition" ":"
type de disposition *( ";" parm-disposition )
disposition-type = "pièce jointe" | jeton d'extension disp
disposition-parm = nom de fichier-parm | disp-extension-parm
filename-parm = "filename" "=" chaîne entre guillemets
disp-extension-token = jeton
disp-extension-parm = jeton "=" ( jeton | chaîne citée )

Un exemple est

Contenu-Disposition : pièce jointe ; nom de fichier = "nomf.ext"

L'agent utilisateur récepteur NE DEVRAIT respecter aucun chemin de répertoire
informations présentes dans le paramètre filename-parm, qui est le seul
paramètre censé s'appliquer aux implémentations HTTP à l'heure actuelle. Le
le nom de fichier DEVRAIT être traité uniquement comme un composant de terminal.

Si cet en-tête est utilisé dans une réponse avec l'application/octet-
type de contenu de flux, la suggestion implicite est que l'agent utilisateur
ne doit pas afficher la réponse, mais saisir directement une réponse « enregistrer la réponse »
comme...' dialogue.

Voir la section 15.5 pour les problèmes de sécurité liés à la disposition du contenu.

19.6 Compatibilité avec les versions précédentes

Il est au-delà de la portée d'une spécification de protocole d'exiger
conformité avec les versions précédentes. HTTP/1.1 a été délibérément
conçu, cependant, pour faciliter la prise en charge des versions précédentes. C'est
il convient de noter qu'au moment de la rédaction de cette spécification
(1996), nous nous attendrions à ce que les serveurs HTTP/1.1 commerciaux :

- reconnaître le format de la Request-Line pour HTTP/0.9, 1.0 et
1.1 demandes ;



Fielding et coll. Voie des normes [Page 170]
 
RFC 2616 HTTP/1.1 juin 1999


- comprendre toute requête valide au format HTTP/0.9, 1.0 ou
1.1 ;

- répondre de manière appropriée avec un message dans la même version majeure
utilisé par le client.

Et nous nous attendons à ce que les clients HTTP/1.1 :

- reconnaître le format de la Status-Line pour HTTP/1.0 et 1.1
réponses ;

- comprendre toute réponse valide au format HTTP/0.9, 1.0 ou
1.1.

Pour la plupart des implémentations de HTTP/1.0, chaque connexion est établie
par le client avant la demande et fermé par le serveur après
envoyer la réponse. Certaines implémentations implémentent le Keep-Alive
version des connexions persistantes décrites dans la section 19.7.1 de la RFC
2068 [33].

19.6.1 Modifications par rapport à HTTP/1.0

Cette section résume les principales différences entre les versions HTTP/1.0
et HTTP/1.1.

19.6.1.1 Modifications visant à simplifier les serveurs Web multi-résidents et à conserver l'IP
Adresses

Les exigences selon lesquelles les clients et les serveurs prennent en charge la demande d'hôte -
en-tête, signaler une erreur si l'en-tête de requête hôte (section 14.23) est
manquant dans une requête HTTP/1.1, et accepte les URI absolus (section
5.1.2) font partie des changements les plus importants définis par le présent
spécification.

Les anciens clients HTTP/1.0 supposaient une relation un-à-un d'IP
adresses et serveurs ; il n'existait aucun autre mécanisme établi pour
distinguer le serveur prévu d'une requête de l'adresse IP
à qui cette demande était adressée. Les changements décrits ci-dessus seront
permettre à Internet, une fois que les anciens clients HTTP ne seront plus courants, de
prendre en charge plusieurs sites Web à partir d'une seule adresse IP, grandement
simplifiant les grands serveurs Web opérationnels, où l'allocation de nombreux
Les adresses IP d'un seul hôte ont créé de sérieux problèmes. Le
Internet pourra également récupérer les adresses IP qui ont été
alloué dans le seul but de permettre un domaine à usage spécial
noms à utiliser dans les URL HTTP au niveau racine. Compte tenu du taux de croissance de
le Web, et le nombre de serveurs déjà déployés, c'est extrêmement





Fielding et coll. Voie des normes [Page 171]
 
RFC 2616 HTTP/1.1 juin 1999


important que toutes les implémentations de HTTP (y compris les mises à jour de
applications HTTP/1.0 existantes) les implémentent correctement
exigences:

- Les clients et les serveurs DOIVENT prendre en charge l'en-tête de requête Host.

- Un client qui envoie une requête HTTP/1.1 DOIT envoyer un en-tête Host.

- Les serveurs DOIVENT signaler une erreur 400 (Bad Request) si une requête HTTP/1.1
La requête n'inclut pas d'en-tête de requête Host.

- Les serveurs DOIVENT accepter les URI absolus.

19.6.2 Compatibilité avec les connexions persistantes HTTP/1.0

Certains clients et serveurs peuvent souhaiter être compatibles avec certains
implémentations précédentes de connexions persistantes dans HTTP/1.0
clients et serveurs. Les connexions persistantes dans HTTP/1.0 sont
explicitement négocié car il ne s’agit pas du comportement par défaut. HTTP/1.0
les implémentations expérimentales de connexions persistantes sont défectueuses,
et les nouvelles fonctionnalités de HTTP/1.1 sont conçues pour remédier à ces problèmes.
problèmes. Le problème était que certains clients 1.0 existants pouvaient être
envoyer Keep-Alive à un serveur proxy qui ne comprend pas
Connexion, qui le transmettrait ensuite par erreur au prochain
serveur entrant, qui établirait la connexion Keep-Alive et
entraîner un proxy HTTP/1.0 bloqué en attente de la fermeture du
réponse. Le résultat est que les clients HTTP/1.0 doivent être empêchés de
utiliser Keep-Alive lorsque vous parlez à des proxys.

Cependant, parler à des proxys est l'utilisation la plus importante de la persistance.
connexions, de sorte que cette interdiction est clairement inacceptable. Donc,
nous avons besoin d'un autre mécanisme pour indiquer une connexion persistante
est souhaité, ce qui est sûr à utiliser même lorsque vous parlez à un ancien proxy
qui ignore la connexion. Les connexions persistantes sont la valeur par défaut pour
Messages HTTP/1.1 ; nous introduisons un nouveau mot-clé (Connexion : close) pour
déclarant la non-persistance. Voir la section 14.10.

La forme HTTP/1.0 originale des connexions persistantes (la connexion :
Keep-Alive et l'en-tête Keep-Alive) est documenté dans la RFC 2068. [33]

19.6.3 Modifications par rapport à la RFC 2068

Cette spécification a été soigneusement auditée pour corriger et
lever l'ambiguïté sur l'utilisation des mots clés ; La RFC 2068 présentait de nombreux problèmes en ce qui concerne
les conventions énoncées dans la RFC 2119 [34].

Clarification du code d'erreur à utiliser en cas de panne du serveur entrant
(par exemple, échecs DNS). (Section 10.5.5).



Fielding et coll. Voie des normes [Page 172]
 
RFC 2616 HTTP/1.1 juin 1999


CREATE avait une course qui nécessitait l'envoi d'un Etag lorsqu'une ressource est
créé en premier. (Section 10.2.2).

Content-Base a été supprimé de la spécification : ce n'était pas le cas
largement mis en œuvre, et il n’existe aucun moyen simple et sûr de l’introduire
sans mécanisme d'extension robuste. De plus, il est utilisé dans un
de manière similaire, mais pas identique, en MHTML [45].

Le codage de transfert et la longueur des messages interagissent tous de manière à
nécessaire de corriger exactement quand le codage en morceaux est utilisé (pour permettre
codage de transfert qui peut ne pas être auto-délimité) ; c'était important
pour clarifier exactement la façon dont la longueur des messages est calculée. (Sections
3.6, 4.4, 7.2.2, 13.5.2, 14.13, 14.16)

Un codage de contenu de « l'identité » a été introduit pour résoudre les problèmes
découvert dans la mise en cache. (article 3.5)

Des valeurs de qualité de zéro devraient indiquer que « Je ne veux pas de quelque chose »
pour permettre aux clients de refuser une représentation. (Section 3.9)

L'utilisation et l'interprétation des numéros de version HTTP ont été clarifiées
par RFC 2145. Exiger que les proxys mettent à niveau les requêtes vers le protocole le plus élevé
version qu'ils prennent en charge pour résoudre les problèmes découverts dans HTTP/1.0
implémentations (Section 3.1)

Le caractère générique du jeu de caractères est introduit pour éviter l'explosion du jeu de caractères.
noms dans les en-têtes d’acceptation. (article 14.2)

Un cas a été manqué dans le modèle Cache-Control de HTTP/1.1 ; s-maxage
a été introduit pour ajouter ce cas manquant. (Articles 13.4, 14.8, 14.9,
14.9.3)

La directive Cache-Control: max-age n'était pas correctement définie pour
réponses. (Section 14.9.3)

Il existe des situations où un serveur (en particulier un proxy) ne
connaître toute la longueur d'une réponse, mais est capable de servir un
demande byterange. Nous avons donc besoin d'un mécanisme pour autoriser les byteranges
avec une plage de contenu n'indiquant pas la longueur totale du message.
(article 14.16)

Les réponses aux demandes de plage deviendraient très verbeuses si toutes les métadonnées
étaient toujours retournés; en permettant au serveur d'envoyer uniquement le nécessaire
en-têtes dans une réponse 206, ce problème peut être évité. (Section
10.2.7, 13.5.3 et 14.27)






Fielding et coll. Voie des normes [Page 173]
 
RFC 2616 HTTP/1.1 juin 1999


Correction d'un problème avec les demandes de plage insatisfaisantes ; il y a deux cas :
problèmes syntaxiques et la plage n'existe pas dans le document. Le 416
un code d'état était nécessaire pour résoudre cette ambiguïté nécessaire pour indiquer
une erreur pour une demande de plage d'octets qui se situe en dehors de la plage d'octets réelle
contenu d'un document. (Sections 10.4.17, 14.16)

Réécriture des exigences de transmission des messages pour rendre la tâche beaucoup plus difficile
pour que les implémenteurs se trompent, comme conséquences des erreurs ici
peut avoir un impact significatif sur Internet, et pour faire face au
problèmes suivants :

1. Remplacement de « HTTP/1.1 ou version ultérieure » par « HTTP/1.1 », dans les contextes où
cela imposait à tort une exigence sur le comportement de
une implémentation d'une future version de HTTP/1.x

2. Il est clair que les agents utilisateurs doivent réessayer les requêtes, et non
« clients » en général.

3. Exigences converties pour que les clients ignorent les 100 inattendus
(Continuer) réponses, et pour que les mandataires transmettent 100 réponses,
en une exigence générale de réponses 1xx.

4. Modification d'un langage spécifique à TCP, pour rendre plus clair que
Les transports non TCP sont possibles pour HTTP.

5. Exiger que le serveur d'origine NE DOIT PAS attendre la demande
body avant d’envoyer la réponse 100 (Continuer) requise.

6. Autoriser, plutôt que d'exiger, un serveur à omettre 100 (Continuer) si
il a déjà vu une partie du corps de la demande.

7. Autoriser les serveurs à se défendre contre les attaques par déni de service et
clients brisés.

Cette modification ajoute l'en-tête Expect et le code d'état 417. Le message
Les correctifs relatifs aux exigences de transmission se trouvent dans les sections 8.2, 10.4.18,
8.1.2.2, 13.11 et 14.20.

Les proxys devraient pouvoir ajouter Content-Length le cas échéant.
(Section 13.5.2)

Nettoyez la confusion entre les réponses 403 et 404. (Section 10.4.4,
10.4.5 et 10.4.11)

Les avertissements peuvent être mal mis en cache ou ne pas être mis à jour correctement.
(Sections 13.1.2, 13.2.4, 13.5.2, 13.5.3, 14.9.3 et 14.46) Avertissement
devait également être un en-tête général, comme PUT ou d'autres méthodes peuvent l'avoir
besoin dans les demandes.



Fielding et coll. Voie des normes [Page 174]
 
RFC 2616 HTTP/1.1 juin 1999


Le codage par transfert présentait des problèmes importants, en particulier avec
interactions avec un codage fragmenté. La solution est que le transfert-
les codages deviennent aussi complets que les codages de contenu. Cela implique
l'ajout d'un registre IANA pour les codages de transfert (séparé du contenu
codages), un nouveau champ d'en-tête (TE) et l'activation des en-têtes de fin dans le
avenir. Le codage de transfert constitue un avantage majeur en termes de performances.
mérite d'être réparé [39]. TE résout également un autre problème obscur, descendant
problème d'interopérabilité qui aurait pu survenir en raison d'interactions
entre les bandes-annonces d'authentification, l'encodage fragmenté et HTTP/1.0
clients. (Sections 3.6, 3.6.1 et 14.39)

Les méthodes PATCH, LINK, UNLINK ont été définies mais pas couramment
implémenté dans les versions précédentes de cette spécification. Voir RFC2068.
[33].

Les alternatives, Content-Version, Derived-From, Link, URI, Public et
Les champs d'en-tête Content-Base ont été définis dans les versions précédentes de ce
spécification, mais pas couramment mis en œuvre. Voir la RFC 2068 [33].

20. Indice

Veuillez consulter la version PostScript de cette RFC pour l'INDEX.

Fielding et coll. Voie des normes [Page 175]
 
RFC 2616 HTTP/1.1 juin 1999


21. Déclaration complète de droits d'auteur

Copyright (C) L'Internet Society (1999). Tous droits réservés.

Ce document et ses traductions peuvent être copiés et fournis à
d'autres et des œuvres dérivées qui le commentent ou l'expliquent d'une autre manière
ou aider à sa mise en œuvre peut être préparé, copié, publié
et distribué, en tout ou en partie, sans restriction de quelque nature que ce soit.
nature, à condition que l'avis de droit d'auteur ci-dessus et ce paragraphe soient
inclus sur toutes ces copies et œuvres dérivées. Cependant, ceci
Le document lui-même ne peut en aucun cas être modifié, par exemple en supprimant
l'avis de droit d'auteur ou les références à l'Internet Society ou à d'autres
Organisations Internet, sauf si cela est nécessaire aux fins de
développer des normes Internet, auquel cas les procédures de
les droits d'auteur définis dans le processus des normes Internet doivent être
suivi, ou, si nécessaire, de le traduire dans des langues autres que
Anglais.

Les autorisations limitées accordées ci-dessus sont perpétuelles et ne seront pas
révoqué par l'Internet Society ou ses successeurs ou ayants droit.

Ce document et les informations qu'il contient sont fournis sur un
Base "EN L'ÉTAT" et LA SOCIÉTÉ INTERNET ET L'INGÉNIERIE INTERNET
TASK FORCE DÉCLINE TOUTE GARANTIE, EXPRESSE OU IMPLICITE, Y COMPRIS
MAIS SANS LIMITATION À TOUTE GARANTIE QUE L'UTILISATION DES INFORMATIONS
LES PRÉSENTES NE VIONT PAS AUCUN DROIT OU GARANTIE IMPLICITE DE
QUALITÉ MARCHANDE OU ADÉQUATION À UN USAGE PARTICULIER.

Reconnaissance

Le financement de la fonction RFC Editor est actuellement assuré par le
Société Internet.

Fielding et coll. Voie des normes [Page 176]
 
